<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>centos上使用docker部署hexo</title>
    <link href="/posts/19452.html"/>
    <url>/posts/19452.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="需求1234"><a href="#需求1234" class="headerlink" title="需求1234"></a>需求1234</h3><p>最近有个需求，服务器上运行三个docker容器，目前分别使用ip:4000、ip:18000、ip:18080来访问，但这样子记得很麻烦，ip本身不规律，很不好记，于是有了域名+端口号的写法 <a href="http://kkkkkong.top:4000/">(kkkkkong.top:4000)</a></p><p>但是用久了感觉还是不够流畅，写端口号的方式会显得比较low，因此考虑使用nginx反向代理的方式实现优雅的访问</p><h3 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h3><blockquote><p>现有三个服务分别运行在三个docker容器中，其占用的宿主机端口号分别为4000&#x2F;18000&#x2F;18080，容器内部端口号都为80</p></blockquote><ul><li>采用kkkkkong.top来访问4000端口</li><li>采用kkkkkong.top&#x2F;nextcloud 来访问18000端口</li><li>采用kkkkkong.top&#x2F;opengrok 来访问18080端口</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>先进行hexo的docker版本的部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create -it --name=hexo -e HEXO_SERVER_PORT=4000 -e GIT_USER=&quot;kong&quot; -e GIT_EMAIL=&quot;376634352@qq.com&quot; -v /mnt/blog.kong.site:/app -p 4000:80 bloodstar/hexo<br></code></pre></td></tr></table></figure><h3 id="配置nginx-docker"><a href="#配置nginx-docker" class="headerlink" title="配置nginx -docker"></a>配置nginx -docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name=nginx -d -p 80:80<br></code></pre></td></tr></table></figure><p>修改nginx的配置，通过命令找到其他容器的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect containsID<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230413191601873.png" alt="image-20230413191601873" style="zoom: 67%;" /><p>图中红框部分即为我们需要的容器IP地址</p><h3 id="配置nginx的代理"><a href="#配置nginx的代理" class="headerlink" title="配置nginx的代理"></a>配置nginx的代理</h3><p>进入容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it nginx bash<br></code></pre></td></tr></table></figure><p>找到nginx的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/nginx/conf.d/default.conf<br></code></pre></td></tr></table></figure><p>将你需要的信息添加到location中</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230413191958986.png" alt="image-20230413191958986"></p><p>三个红框分别为匹配规则，匹配路径和匹配的url</p><ul><li>匹配规则可以参考官方文档 <a href="https://nginx.org/">nginx news</a></li><li>匹配路径是设置跟在域名后的名字</li><li>url是由容器的ip+内部暴露的端口号构成</li></ul><p>保存退出，查看配置信息是否可用，看见有successful ，成功（这里如果不留神改错了，会导致重启容器后修改比较麻烦）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -t<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230413192338410.png" alt="image-20230413192338410"></p><p>退出容器重启就可以优雅的访问了</p><p><a href="http://www.kkkkkong.top/">虫兑变的博客 (kkkkkong.top)</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/dotnet261010/p/12596185.html">Docker教程：使用Docker容器运行Nginx并实现反向代理 - .NET开发菜鸟 - 博客园 (cnblogs.com)</a></p><p><a href="https://github.com/appotry/docker-hexo">Appotry&#x2F;docker-hexo： hexo docker 一键部署环境。增加CJK中国环境适配和常用软件，hexo 插件等易用设置。开箱即用。 (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 92</title>
    <link href="/posts/26852.html"/>
    <url>/posts/26852.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/rev2ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，主要在于找到被反转的链表，然后切割，与无关字符串断开</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.9 MB, 在所有 Java 提交中击败了84.13%的用户</p><p>通过测试用例：44 &#x2F; 44</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        ListNode zeroNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode res=zeroNode;<br>        zeroNode.next=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left-<span class="hljs-number">1</span>;i++)&#123;<br>            zeroNode=zeroNode.next;<br>        &#125;<br>        ListNode prev=zeroNode;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>            zeroNode=zeroNode.next;<br>        &#125;<br>        ListNode rightNode=zeroNode;<br>        ListNode leftNode=prev.next;<br>        prev.next=<span class="hljs-literal">null</span>;<br>        ListNode afNode=rightNode.next;<br>        rightNode.next=<span class="hljs-literal">null</span>;<br>        prev.next= reverseList(leftNode);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>            prev=prev.next;<br>        &#125;<br>        prev.next=afNode;<br>        <span class="hljs-keyword">return</span> res.next;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        ListNode prev=<span class="hljs-literal">null</span>;<br>        ListNode curr=head;<br>        <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp=curr.next;<br>            curr.next=prev;<br>            prev=curr;<br>            curr=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 196</title>
    <link href="/posts/44910.html"/>
    <url>/posts/44910.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode.cn/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></h4><p>SQL架构</p><p>表: <code>Person</code></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| id          | int     |<br><span class="hljs-section">| email       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br>id是该表的主键列。<br>该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。<br></code></pre></td></tr></table></figure><p>编写一个 SQL <strong>删除语句</strong>来 <strong>删除</strong> 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。</p><p>以 <strong>任意顺序</strong> 返回结果表。 （<strong>注意</strong>： 仅需要写删除语句，将自动对剩余结果进行查询）</p><p>查询结果格式如下所示。</p><p><strong>示例 1:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">输入: <br><span class="hljs-section">Person 表:</span><br><span class="hljs-section">+----+------------------+</span><br><span class="hljs-section">| id | email            |</span><br><span class="hljs-section">+----+------------------+</span><br>| 1  | john@example.com |<br>| 2  | bob@example.com  |<br><span class="hljs-section">| 3  | john@example.com |</span><br><span class="hljs-section">+----+------------------+</span><br><span class="hljs-section">输出: </span><br><span class="hljs-section">+----+------------------+</span><br><span class="hljs-section">| id | email            |</span><br><span class="hljs-section">+----+------------------+</span><br>| 1  | john@example.com |<br><span class="hljs-section">| 2  | bob@example.com  |</span><br><span class="hljs-section">+----+------------------+</span><br>解释: john@example.com重复两次。我们保留最小的Id = 1。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解</li></ol><blockquote><p>执行用时：577 ms, 在所有 MySQL 提交中击败了82.16%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：22 &#x2F; 22</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Please write a <span class="hljs-keyword">DELETE</span> statement <span class="hljs-keyword">and</span> DO <span class="hljs-keyword">NOT</span> write a <span class="hljs-keyword">SELECT</span> statement.<br># Write your MySQL query statement below<br><span class="hljs-keyword">DELETE</span> p1<br><span class="hljs-keyword">from</span><br>person p1,person p2<br><span class="hljs-keyword">where</span> p1.email<span class="hljs-operator">=</span>p2.email <span class="hljs-keyword">and</span> p1.id<span class="hljs-operator">&gt;</span>p2.id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 182</title>
    <link href="/posts/64622.html"/>
    <url>/posts/64622.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode.cn/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></h4><p>SQL架构</p><p>表: <code>Person</code></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| id          | int     |<br><span class="hljs-section">| email       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br>id 是该表的主键列。<br>此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。<br></code></pre></td></tr></table></figure><p>编写一个 SQL 查询来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。</p><p>以 <strong>任意顺序</strong> 返回结果表。</p><p>查询结果格式如下例。</p><p><strong>示例 1:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">输入: <br><span class="hljs-section">Person 表:</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">| id | email   |</span><br><span class="hljs-section">+----+---------+</span><br>| 1  | a@b.com |<br>| 2  | c@d.com |<br><span class="hljs-section">| 3  | a@b.com |</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">输出: </span><br><span class="hljs-section">+---------+</span><br><span class="hljs-section">| Email   |</span><br><span class="hljs-section">+---------+</span><br><span class="hljs-section">| a@b.com |</span><br><span class="hljs-section">+---------+</span><br>解释: a@b.com 出现了两次。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先建立一个子表，在查询</li></ol><blockquote><p>执行用时：378 ms, 在所有 MySQL 提交中击败了58.00%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：15 &#x2F; 15</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span><br>Email<br><span class="hljs-keyword">from</span><br>(<span class="hljs-keyword">select</span><br>email,<span class="hljs-built_in">count</span>(email) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">from</span> person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>email) <span class="hljs-keyword">as</span> tab<br><span class="hljs-keyword">where</span> num <span class="hljs-operator">&gt;</span><span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><ol><li>group by+having</li></ol><blockquote><p>执行用时：435 ms, 在所有 MySQL 提交中击败了15.93%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：15 &#x2F; 15</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span><br>Email<br><span class="hljs-keyword">from</span> <br>Person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>Email<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(Email)<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 144</title>
    <link href="/posts/65259.html"/>
    <url>/posts/65259.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>难度简单1028收藏分享切换为英文接收动态反馈</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了35.01%的用户</p><p>通过测试用例：70 &#x2F; 70</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; list;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        getNode(root);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNode</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ;<br>        list.add(root.val);<br>        getNode(root.left);<br>        getNode(root.right);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 145</title>
    <link href="/posts/15914.html"/>
    <url>/posts/15914.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>难度简单1009收藏分享切换为英文接收动态反馈</p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/pre1.jpg" alt="img"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了38.80%的用户</p><p>通过测试用例：68 &#x2F; 68</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;Integer&gt; list;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        getNode(root);<br>        <span class="hljs-keyword">return</span> list;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNode</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ;<br>        getNode(root.left);<br>        getNode(root.right);<br>        list.add(root.val);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DragonOS前三个进程的创建</title>
    <link href="/posts/13195.html"/>
    <url>/posts/13195.html</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统加载过程"><a href="#操作系统加载过程" class="headerlink" title="操作系统加载过程"></a>操作系统加载过程</h2><ol><li>内核引导<ol><li>POST</li><li>BIOS</li><li>MBR：主引导记录</li><li>硬盘启动，grub，选择启用哪个系统</li><li>操作系统：start，手动创建0号进程</li></ol></li><li>加载init，1，2号进程的初始化</li><li>系统初始化：加载开机启动程序 init.d</li><li>建立终端</li><li>用户登录</li></ol><p><img src="https://e1sw9jmnjt.feishu.cn/space/api/box/stream/download/asynccode/?code=NGZlMDI2YTA3NmY3NzQ0MjQyYjUyODVkNWI5YWVhMmNfQlRMc21VVXROWjU5NjljRzFPeUxuRTliYjlUMGdOcXBfVG9rZW46WkNVWmIzbHBZb1NiZTV4c1F3dGNyTGFkbm9lXzE2NzkzMDMzMDg6MTY3OTMwNjkwOF9WNA" alt="img"></p><h2 id="进程创建的时机"><a href="#进程创建的时机" class="headerlink" title="进程创建的时机"></a>进程创建的时机</h2><p>do_fork()</p><p>任何进程都是由其他进程创建的。<strong>操作系统通过系统调用fork(),vfork()和clone()函数来完成进程的创建。</strong></p><ul><li><strong>这三个系统调用最终都调用了内核函数do_fork()</strong></li><li><strong>这三个函数的唯一区别在于随后调用do_fork(0时设置的标志不同。</strong></li></ul><h2 id="进程的功能"><a href="#进程的功能" class="headerlink" title="进程的功能"></a>进程的功能</h2><h3 id="0号进程：IDLE"><a href="#0号进程：IDLE" class="headerlink" title="0号进程：IDLE"></a>0号进程：IDLE</h3><p>系统中的第一个进程，PID为0，是init进程和kthread的父进程，</p><h3 id="1号进程：init"><a href="#1号进程：init" class="headerlink" title="1号进程：init"></a>1号进程：init</h3><p>是第一个用户空间的进程，PID为1，是其他用户空间进程的父进程</p><h3 id="2号进程：kthreadd"><a href="#2号进程：kthreadd" class="headerlink" title="2号进程：kthreadd"></a>2号进程：kthreadd</h3><p>是内核空间其他内核进程的父进程，PID为2，</p><p>负责内核线程的创建工作</p><p>结构树(篇幅原因移除部分子进程)</p><blockquote><p>[root@VM-8-5-centos ~]# pstree 0 -p<br>?()─┬─kthreadd(2)─┬─ata_sff(257)<br>    │             ├─bioset(23)<br>    │             ├─bioset(24)<br>    │             ├─bioset(25)<br>    │             ├─crypto(38)<br>    └─systemd(1)─┬─YDLive(1789)─┬─YDService(2493)─┬─sh(2603)─┬─{sh}(2604)<br>                 │              │                 │          ├─{sh}(2605)<br>                 │              │                 │          ├─{sh}(2609)<br>                 │              │                 │          ├─{sh}(2610)<br>                 │              │                 │          └─{sh}(15243)<br>                 │              │                 ├─{YDService}(2494)<br>                 │              │                 ├─{YDService}(2497)<br>                 │              ├─{YDLive}(1790)<br>                 │              ├─{YDLive}(1796)<br>                 │              └─{YDLive}(6911)<br>                 ├─abrt-dbus(21662)─┬─{abrt-dbus}(21663)<br>                 │                  └─{abrt-dbus}(21665)<br>                 ├─acpid(666)</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/joggingpig/article/details/110239518">Linux中的特殊进程：idle进程、init进程、kthreadd进程_JoggingPig的博客-CSDN博客</a></p><p>sql语句查询过程</p><p>查缓存</p><p>解析器：语法、词法</p><p>优化器：逻辑优化、物理</p><p>执行器：</p><h1 id="解决由于在中断上下文以外，sched-enqueue时，未关中断导致cpu-queue双重加锁的问题-201"><a href="#解决由于在中断上下文以外，sched-enqueue时，未关中断导致cpu-queue双重加锁的问题-201" class="headerlink" title="解决由于在中断上下文以外，sched_enqueue时，未关中断导致cpu_queue双重加锁的问题 #201"></a>解决由于在中断上下文以外，sched_enqueue时，未关中断导致cpu_queue双重加锁的问题 #201</h1>]]></content>
    
    
    <categories>
      
      <category>DragonOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 部署opengrok方便代码阅读</title>
    <link href="/posts/1728.html"/>
    <url>/posts/1728.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>接上次部署NextCloud，继续把原来服务器上的opengrok部署过来。</p><p>opengrok是我们在开发DragonOS的过程中的源码阅读工具，用起来还不错，可以实现函数的跳转，方便快速查找内容。同时还可以查看历史版本。推荐大家使用，让我们一起<strong>RTFSC</strong>(Reading The F**king Source Code!)— Linus</p><h2 id="OpenGrok介绍"><a href="#OpenGrok介绍" class="headerlink" title="OpenGrok介绍"></a>OpenGrok介绍</h2><p>OpenGrok是一种流行的、功能强大的源代码搜索和交叉引用引擎，允许用户在多个存储库和语言中搜索和分析源代码。OpenGrok最初由Sun Microsystems创建，并在后来在CDDL许可下开源。</p><p>OpenGrok提供基于Web的界面，允许用户浏览、搜索和分析源代码，包括代码历史、语法高亮和交叉引用等功能。它支持广泛的编程语言和源代码控制系统，包括Git、Mercurial、Subversion、CVS和ClearCase等。</p><p>OpenGrok广泛应用于软件开发人员、系统管理员和其他需要处理大型代码库的技术专业人员。它可以帮助用户快速找到和分析代码、识别依赖关系和跟踪时间的变化等用例。OpenGrok还具有高度的可定制性，允许用户配置其行为以适应其特定需求。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>本文是在CentOS7.6，docker版本是23.0.1</p><ol><li><p>获取最新opengrok镜像：docker pull opengrok&#x2F;docker</p></li><li><p>运行opengrok容器</p><ol><li><p><code>docker run -d -v &lt;path/to/your/src&gt;:/opengrok/src -e SYNC_PERIOD_MINUTES=30 -p 18080:8080 opengrok/docker:latest</code></p></li><li><p>参数说明</p><ol><li>-d：后台运行</li><li>-v：将宿主机的某个目录挂载到容器内的目录，这里是将某个目录挂载到<code>/opengrok/src</code></li><li>-p：将宿主机的18080端口映射到容器的8080端口</li><li>-e：设置环境变量，SYNC_PERIOD_MINUTES是索引的更新周期，这里设置半小时更新一次</li></ol></li><li><p>映射包含以下目录</p><ol><li><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/opengrok/etc</code></td><td>存储 Web 应用和索引器的配置</td></tr><tr><td><code>/opengrok/data</code></td><td>数据根 - 索引数据</td></tr><tr><td><code>/opengrok/src</code></td><td>源根目录 - 输入数据</td></tr><tr><td><code>/scripts</code></td><td>启动脚本和顶级配置。除非进行调试，否则不要重写。</td></tr></tbody></table></li><li><p>更多配置可以参考opengrok官网，<a href="https://github.com/oracle/opengrok/tree/master/docker">Opengrok&#x2F;docker at Master ·甲骨文&#x2F;Opengrok (github.com)</a></p></li></ol></li></ol></li><li><p>进入容器</p><ol><li><code>docker exec -it &lt;container&gt; bash</code>通过命令进入容器修改你想要的配置</li></ol></li><li><p>访问索引的源代码。一旦索引完成，您就可以使用OpenGrok Web界面搜索和查看您的源代码了。</p><ol><li>我这里通过 <code>ip:18080</code>访问</li></ol></li></ol><blockquote><p>需要注意的是，你的仓库如果是在github上，你需要在保证仓库是完整的放在 &lt;path&#x2F;to&#x2F;your&#x2F;src&gt;下的，我最开始的时候，只是从windows上复制了文件到linux上，但文件夹里没有.git的信息，所以他没被识别为git仓库，所以建索引的时候会报一些错误，导致无法定时更新索引，我猜是因为他找不到目标地址。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/oracle/opengrok/tree/master/docker">Opengrok&#x2F;docker at Master ·甲骨文&#x2F;Opengrok (github.com)</a></p><p><a href="https://blog.csdn.net/yinni11/article/details/81559175">【docker】docker run命令详解_yinni11的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>opengrok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 183</title>
    <link href="/posts/15535.html"/>
    <url>/posts/15535.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode.cn/problems/customers-who-never-order/">183. 从不订购的客户</a></h4><p>难度简单429收藏分享切换为英文接收动态反馈</p><p>SQL架构</p><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p><code>Customers</code> 表：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>-------+<br><span class="hljs-section">| Id | Name  |</span><br><span class="hljs-section">+----+-------+</span><br>| 1  | Joe   |<br>| 2  | Henry |<br>| 3  | Sam   |<br><span class="hljs-section">| 4  | Max   |</span><br><span class="hljs-section">+----+-------+</span><br></code></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------------+<br><span class="hljs-section">| Id | CustomerId |</span><br><span class="hljs-section">+----+------------+</span><br>| 1  | 3          |<br><span class="hljs-section">| 2  | 1          |</span><br><span class="hljs-section">+----+------------+</span><br></code></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------+</span><br><span class="hljs-section">| Customers |</span><br><span class="hljs-section">+-----------+</span><br>| Henry     |<br><span class="hljs-section">| Max       |</span><br><span class="hljs-section">+-----------+</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>leftjoin</li></ol><blockquote><p>执行用时：320 ms, 在所有 MySQL 提交中击败了88.37%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：11 &#x2F; 11</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span><br>name <span class="hljs-keyword">as</span> Customers<br><br><span class="hljs-keyword">from</span><br><br>customers <span class="hljs-keyword">as</span> c <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> orders <span class="hljs-keyword">as</span> o<br><br><span class="hljs-keyword">on</span> c.id<span class="hljs-operator">=</span>o.customerid<br><br><span class="hljs-keyword">where</span> o.customerid <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 225</title>
    <link href="/posts/40665.html"/>
    <url>/posts/40665.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;MyStack&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyStack myStack = <span class="hljs-keyword">new</span> MyStack();<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>myStack.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.empty(); <span class="hljs-comment">// 返回 False</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>一个队列模拟：N个长度的队列，出队n-1次，下一次出队的元素就是我们要的。主要主要pop的时候对于top元素的保存</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.2 MB, 在所有 Java 提交中击败了67.93%的用户</p><p>通过测试用例：17 &#x2F; 17</p><p>时间 n</p><p>空间 n</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    ArrayList&lt;Integer&gt; list;<br>    <span class="hljs-type">int</span> top;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        top=<span class="hljs-number">0</span>;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        list.add(x);<br>        top=x;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> size=list.size();<br>        <span class="hljs-keyword">while</span>(size&gt;<span class="hljs-number">1</span>)&#123;<br>            top=list.get(<span class="hljs-number">0</span>);<br>            list.add(list.remove(<span class="hljs-number">0</span>));<br>            size--;<br>        &#125;<br>        <span class="hljs-type">int</span> tmp=list.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> tmp;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 232</title>
    <link href="/posts/52377.html"/>
    <url>/posts/52377.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><p>难度简单857收藏分享切换为英文接收动态反馈</p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();<br>myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span><br>myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span><br>myQueue.peek(); <span class="hljs-comment">// return 1</span><br>myQueue.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span><br>myQueue.empty(); <span class="hljs-comment">// return false</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>两个栈模拟队列</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了43.68%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(n)，平均O(1)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    Stack&lt;Integer&gt; s1,s2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>        s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        s1.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(s2.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!s1.isEmpty())&#123;<br>                s2.push(s1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s2.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(s2.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!s1.isEmpty())&#123;<br>                s2.push(s1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s2.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.isEmpty()&amp;&amp;s2.isEmpty();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 460</title>
    <link href="/posts/23803.html"/>
    <url>/posts/23803.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU 缓存</a></h4><p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：<br>[<span class="hljs-string">&quot;LFUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, null, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, null, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释：<br><span class="hljs-regexp">//</span> cnt(x) = 键 x 的使用计数<br><span class="hljs-regexp">//</span> cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）<br>LFUCache lfu = new LFUCache(<span class="hljs-number">2</span>);<br>lfu.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);   <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">1</span>,_], cnt(<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br>lfu.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);   <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], cnt(<span class="hljs-number">2</span>)=<span class="hljs-number">1</span>, cnt(<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br>lfu.get(<span class="hljs-number">1</span>);      <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">1</span><br>                 <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], cnt(<span class="hljs-number">2</span>)=<span class="hljs-number">1</span>, cnt(<span class="hljs-number">1</span>)=<span class="hljs-number">2</span><br>lfu.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);   <span class="hljs-regexp">//</span> 去除键 <span class="hljs-number">2</span> ，因为 cnt(<span class="hljs-number">2</span>)=<span class="hljs-number">1</span> ，使用计数最小<br>                 <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], cnt(<span class="hljs-number">3</span>)=<span class="hljs-number">1</span>, cnt(<span class="hljs-number">1</span>)=<span class="hljs-number">2</span><br>lfu.get(<span class="hljs-number">2</span>);      <span class="hljs-regexp">//</span> 返回 -<span class="hljs-number">1</span>（未找到）<br>lfu.get(<span class="hljs-number">3</span>);      <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">3</span><br>                 <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], cnt(<span class="hljs-number">3</span>)=<span class="hljs-number">2</span>, cnt(<span class="hljs-number">1</span>)=<span class="hljs-number">2</span><br>lfu.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);   <span class="hljs-regexp">//</span> 去除键 <span class="hljs-number">1</span> ，<span class="hljs-number">1</span> 和 <span class="hljs-number">3</span> 的 cnt 相同，但 <span class="hljs-number">1</span> 最久未使用<br>                 <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], cnt(<span class="hljs-number">4</span>)=<span class="hljs-number">1</span>, cnt(<span class="hljs-number">3</span>)=<span class="hljs-number">2</span><br>lfu.get(<span class="hljs-number">1</span>);      <span class="hljs-regexp">//</span> 返回 -<span class="hljs-number">1</span>（未找到）<br>lfu.get(<span class="hljs-number">3</span>);      <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">3</span><br>                 <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], cnt(<span class="hljs-number">4</span>)=<span class="hljs-number">1</span>, cnt(<span class="hljs-number">3</span>)=<span class="hljs-number">3</span><br>lfu.get(<span class="hljs-number">4</span>);      <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">4</span><br>                 <span class="hljs-regexp">//</span> cache=[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], cnt(<span class="hljs-number">4</span>)=<span class="hljs-number">2</span>, cnt(<span class="hljs-number">3</span>)=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+linkedHashSet：通过三个结构来存储当前情况，<ol><li>key2Val 用来存放key对应的value</li><li>key2Freq 用来存放key出现的频率</li><li>freq2keys 用来存放频率对应的key的列表。因为在频率相同的情况下，需要抛弃最久未使用的，因此需要用有序的结构存储，而且需要O(1)的时间复杂度，因此LinkedHashSet最合适。</li></ol></li><li>整体思路不难，但很多细节，因为要操作很多数据表，CPU快给我干烧了</li></ol><blockquote><p>执行用时：69 ms, 在所有 Java 提交中击败了41.72%的用户</p><p>内存消耗：122.7 MB, 在所有 Java 提交中击败了45.30%的用户</p><p>通过测试用例：25 &#x2F; 25</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>    HashMap &lt;Integer,Integer&gt; key2Val=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    HashMap&lt;Integer,Integer&gt; key2Freq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    HashMap&lt;Integer,LinkedHashSet&lt;Integer&gt;&gt; freq2keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-type">int</span> minCap=Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> cap=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LFUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        cap=capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(key2Val.containsKey(key))&#123;<br>            increaseFreq(key);<br>            <span class="hljs-keyword">return</span> key2Val.get(key); <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 如果已有key元素，那么修改</span><br>        <span class="hljs-keyword">if</span>(key2Val.containsKey(key))&#123;<br>            key2Val.put(key,value);<br>            increaseFreq(key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">// 如果没有，那么增加</span><br>        <span class="hljs-comment">// 如果超出容量，需要去除lr的键</span><br>        <span class="hljs-keyword">if</span>(key2Val.size()&gt;=cap)&#123;<br>            removeMinFreq();<br>        &#125;<br>        <span class="hljs-comment">// 增加</span><br>        key2Val.put(key,value);<br>        key2Freq.put(key,<span class="hljs-number">1</span>);<br>        freq2keys.putIfAbsent(<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;Integer&gt;());<br>        freq2keys.get(<span class="hljs-number">1</span>).add(key);<br>        <span class="hljs-comment">// LinkedHashSet set=freq2keys.getOrDefault(1,new LinkedHashSet&lt;Integer&gt;());</span><br>        <span class="hljs-comment">// set.add(key);</span><br>        <span class="hljs-comment">// freq2keys.put(1,set);</span><br>        minCap=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeMinFreq</span><span class="hljs-params">()</span>&#123;<br>        LinkedHashSet&lt;Integer&gt; set= freq2keys.get(minCap);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deletedKey</span> <span class="hljs-operator">=</span> set.iterator().next();<br>        set.remove(deletedKey);<br>        <span class="hljs-keyword">if</span>(set.isEmpty())&#123;<br>            freq2keys.remove(minCap);<br>        &#125;<br><br>        key2Val.remove(deletedKey);<br>        key2Freq.remove(deletedKey);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increaseFreq</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> freq=key2Freq.get(key);<br><br>        LinkedHashSet set=freq2keys.get(freq);<br>        <span class="hljs-comment">// 从set中移除掉当前freq中的队列中的key</span><br>        set.remove(key);<br>        <span class="hljs-keyword">if</span>(set.isEmpty())&#123;<br>            freq2keys.remove(freq);<br>        &#125;<br>        <span class="hljs-comment">// 将key加入到freq+1的队列中去</span><br>        freq2keys.putIfAbsent(freq+<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;Integer&gt;());<br>        freq2keys.get(freq+<span class="hljs-number">1</span>).add(key);<br>        <span class="hljs-comment">// 更新key2Freq</span><br>        key2Freq.put(key,freq+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(minCap==freq)&#123;<br>            <span class="hljs-keyword">if</span>(set.isEmpty())&#123;<br>                minCap++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LFUCache obj = new LFUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在CentOS上用docker部署NextCloud，实现多设备文件协同</title>
    <link href="/posts/28348.html"/>
    <url>/posts/28348.html</url>
    
    <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>最近上一个服务器到期了，上面部署着以前的NextCloud，又新租了一个服务器，准备重新配置，顺便记录下</p><h2 id="NextCloud介绍"><a href="#NextCloud介绍" class="headerlink" title="NextCloud介绍"></a>NextCloud介绍</h2><p>NextCloud是我以前在寻找OneDrive的平替版找到的一块软件，我平时在实验室、宿舍以及笔记本上要看论文或者写一些文档，当时的文件同步给我造成了很大的困扰，在寻找解决方案时找到了这款软件，用起来比较舒服，传输速度取决于你的服务器带宽，一般来说是够用的，维基百科中对他的介绍是这样的：</p><blockquote><p><strong>Nextcloud</strong>是一套用于创建<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E7%A1%AC%E7%9B%98">网络硬盘</a>的<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BE%9E%E5%BC%8F%E6%9E%B6%E6%A7%8B">客户端－服务器软件</a>。其功能与<a href="https://zh.wikipedia.org/wiki/Dropbox">Dropbox</a>相近，但Nextcloud是<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%8A%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6">自由及开放源代码软件</a>，每个人都可以在私人服务器上安装并执行它。</p><p>与Dropbox等专有服务相比，Nextcloud的开放架构让用户可以利用应用程序的方式在服务器上新增额外的功能，并让用户可以完全掌控自己的资料。</p><p><a href="https://zh.wikipedia.org/zh-cn/Nextcloud">Nextcloud - 维基百科，自由的百科全书 (wikipedia.org)</a></p></blockquote><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>本文是在CentOS7.6，docker版本是23.0.1</p><ol><li><p>安装docker，具体的细节参照菜鸟教程：<a href="https://www.runoob.com/docker/centos-docker-install.html">CentOS Docker 安装 | 菜鸟教程 (runoob.com)</a></p></li><li><p>获取最新版NextCloud镜像</p><ol><li><p>docker search一下现有与NextCloud相关的内容，docker search nextcloud，发现第一个就是，而且是官方高星的</p><ol><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230313164208285.png" alt="image-20230313164208285" style="zoom: 50%;" /></li></ol></li><li><p>docker pull nextcloud 获取最新版本</p></li><li><p>创建容器</p><ol><li><pre><code class="hljs">docker run -d -p 8080:80 -v /home/nextcloud:/var/www/html --name nextcloud nextcloud</code></pre></li><li><p>-d #容器后台运行</p><p>–name nextcloud #容器名</p><p>-v &#x2F;data&#x2F;nextcloud:&#x2F;var&#x2F;www&#x2F;html #将宿主机的目录&#x2F;data&#x2F;nextcloud挂载到容器的&#x2F;var&#x2F;www&#x2F;html</p><p>-p 18000:80 #将宿主机的端口（此处以18000为例）映射到容器的80端口</p></li></ol></li></ol></li><li><p>web 登录</p><ol><li>第一次使用nextcloud要通过Web端进行配置，记得开启云服务器上对应的端口，这里是18000端口，按照自己的需求配置<ol><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230313164518805.png" alt="image-20230313164518805" style="zoom: 50%;" /></li></ol></li><li>访问ip:18000<ol><li>此处需要设置密码和选择相应的数据库，我这里是个人使用，所以就直接用了SQLLite，如果是多人协作，官方推荐使用mysql等数据库（我这里忘记截图了，就偷个懒）</li></ol></li></ol></li><li><p>客户端下载</p><ol><li>访问官方<a href="https://nextcloud.com/install/">Install - Nextcloud</a>下载对应版本资源，安装然后配置链接即可</li><li>Windows上安装好之后是这个样子，登录到你的账号，注意这里填了地址之后会默认按照https方式链接，我这里会报错，改成http即可</li><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230313164953262.png" alt="image-20230313164953262" style="zoom:50%;" /></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NextCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 146</title>
    <link href="/posts/16234.html"/>
    <url>/posts/16234.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h4><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>LinkedHashMap实现</li></ol><blockquote><p>执行用时：52 ms, 在所有 Java 提交中击败了30.61%的用户</p><p>内存消耗：117.7 MB, 在所有 Java 提交中击败了10.73%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(1)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    LinkedHashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>();<br>    <span class="hljs-type">int</span> cap;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cap=capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">int</span> ans=map.getOrDefault(key,-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(ans !=-<span class="hljs-number">1</span>)&#123;<br>            makeRecently(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;<br>            map.remove(key);<br>            map.put(key,value); <br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(map.size()&gt;=cap)&#123;<br>            <span class="hljs-type">int</span> firstKey=map.keySet().iterator().next();<br>            map.remove(firstKey);<br>        &#125;<br>        map.put(key,value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeRecently</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> val=map.get(key);<br>        map.remove(key);<br>        map.put(key,val);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ol start="2"><li>自实现双向链表+哈希表：费了老鼻子劲，主要是那几个抽出来操作map和list的函数，需要想清楚他们使用的场景</li></ol><blockquote><p>执行用时：48 ms, 在所有 Java 提交中击败了43.19%的用户</p><p>内存消耗：116.2 MB, 在所有 Java 提交中击败了17.51%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(1)</p><p>空间 O(N)</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Node&#123;<br>    <span class="hljs-built_in">int</span> key,<span class="hljs-keyword">val</span>;<br>    Node prev,next;<br>    public <span class="hljs-constructor">Node(<span class="hljs-params">int</span> <span class="hljs-params">key</span>,<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>&#123;<br>        this.key=key;<br>        this.<span class="hljs-keyword">val</span>=<span class="hljs-keyword">val</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> DoubleList&#123;<br>    Node head,tail;<br>    <span class="hljs-built_in">int</span> size;<br>    public <span class="hljs-constructor">DoubleList()</span>&#123;<br>        head =<span class="hljs-keyword">new</span> <span class="hljs-constructor">Node(0,0)</span>;<br>        tail =<span class="hljs-keyword">new</span> <span class="hljs-constructor">Node(0,0)</span>;<br>        head.next=tail;<br>        tail.prev=head;<br>        size=<span class="hljs-number">0</span>;<br>    &#125;<br>    public void add<span class="hljs-constructor">Node(Node <span class="hljs-params">node</span>)</span>&#123;<br>        node.prev=tail.prev;<br>        node.next=tail;<br><br>        tail.prev.next=node;<br>        tail.prev=node;<br><br>        size++;<br>    &#125;<br>    public void remove<span class="hljs-constructor">Node(Node <span class="hljs-params">node</span>)</span>&#123;<br>        node.prev.next=node.next;<br>        node.next.prev=node.prev;<br>        size--;<br>    &#125;<br>    public Node remove<span class="hljs-constructor">FirstNode()</span>&#123;<br>        <span class="hljs-keyword">if</span>(head.next==tail)&#123;<br>            return null;<br>        &#125;<br>        Node first =head.next;<br>        this.remove<span class="hljs-constructor">Node(<span class="hljs-params">first</span>)</span>;<br>        return first;<br>    &#125;<br>    public <span class="hljs-built_in">int</span> size<span class="hljs-literal">()</span>&#123;<br>        return size;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> LRUCache &#123;<br>    <span class="hljs-built_in">int</span> cap;<br>    DoubleList <span class="hljs-built_in">list</span>=<span class="hljs-keyword">new</span> <span class="hljs-constructor">DoubleList()</span>;<br>    HashMap&lt;Integer,Node&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-constructor">HashMap()</span>;<br>    public <span class="hljs-constructor">LRUCache(<span class="hljs-params">int</span> <span class="hljs-params">capacity</span>)</span> &#123;<br>        this.cap=capacity;<br>    &#125;<br>    <br>    public <span class="hljs-built_in">int</span> get(<span class="hljs-built_in">int</span> key) &#123;<br>        <span class="hljs-keyword">if</span>(!map.contains<span class="hljs-constructor">Key(<span class="hljs-params">key</span>)</span>)&#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        make<span class="hljs-constructor">Recently(<span class="hljs-params">key</span>)</span>;<br>        return map.get(key).<span class="hljs-keyword">val</span>;<br>    &#125;<br>    <br>    public void put(<span class="hljs-built_in">int</span> key, <span class="hljs-built_in">int</span> value) &#123;<br>        <span class="hljs-keyword">if</span>(map.contains<span class="hljs-constructor">Key(<span class="hljs-params">key</span>)</span>)&#123;<br>            delete<span class="hljs-constructor">Key(<span class="hljs-params">key</span>)</span>;<br>            add<span class="hljs-constructor">Recently(<span class="hljs-params">key</span>,<span class="hljs-params">value</span>)</span>;<br>            return;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>.size<span class="hljs-literal">()</span>&gt;=cap)&#123;<br>            remove<span class="hljs-constructor">LeastRecently()</span>;<br>        &#125;<br>        add<span class="hljs-constructor">Recently(<span class="hljs-params">key</span>,<span class="hljs-params">value</span>)</span>;<br>    &#125;<br>    public void make<span class="hljs-constructor">Recently(<span class="hljs-params">int</span> <span class="hljs-params">key</span>)</span>&#123;<br>        <br>        Node node=map.get(key);<br>        <span class="hljs-built_in">list</span>.remove<span class="hljs-constructor">Node(<span class="hljs-params">node</span>)</span>;<br>        <span class="hljs-built_in">list</span>.add<span class="hljs-constructor">Node(<span class="hljs-params">node</span>)</span>;<br>    &#125;<br>    public void delete<span class="hljs-constructor">Key(<span class="hljs-params">int</span> <span class="hljs-params">key</span>)</span>&#123;<br>        Node node=map.get(key);<br>        <span class="hljs-built_in">list</span>.remove<span class="hljs-constructor">Node(<span class="hljs-params">node</span>)</span>;<br>        map.remove(key);<br><br>    &#125;<br>    public void remove<span class="hljs-constructor">LeastRecently()</span>&#123;<br>        Node node=<span class="hljs-built_in">list</span>.remove<span class="hljs-constructor">FirstNode()</span>;<br>        map.remove(node.key);<br><br>    &#125;<br>    <span class="hljs-comment">// put的处理，将普通元素提到最近使用</span><br>    public void add<span class="hljs-constructor">Recently(<span class="hljs-params">int</span> <span class="hljs-params">key</span>,<span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>&#123;<br>        Node node =<span class="hljs-keyword">new</span> <span class="hljs-constructor">Node(<span class="hljs-params">key</span>,<span class="hljs-params">value</span>)</span>;<br>        <span class="hljs-built_in">list</span>.add<span class="hljs-constructor">Node(<span class="hljs-params">node</span>)</span>;<br>        map.put(key,node);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DragonOS 多核负载均衡</title>
    <link href="/posts/46077.html"/>
    <url>/posts/46077.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>操作系统中CPU有多个核，（为了方便介绍，后续称为多个CPU），为了减少每个CPU之间的干扰，每个CPU上都有对应的运行队列。整个操作系统运行的过程中，可能存在有的CPU非常忙，有的CPU非常闲，因此需要有负载均衡来平衡各个CPU之间的负载。</p><p>将pcb从负载较重的CPU上转移到负载相对较轻的CPU上执行，这个过程就是负载均衡</p><h2 id="常见负载均衡方法"><a href="#常见负载均衡方法" class="headerlink" title="常见负载均衡方法"></a>常见负载均衡方法</h2><p>负载均衡的发展历程如下：</p><ol><li>根据运行队列的长度作为当前的负载</li><li>计算过去一段时间的运行的队列数量，加权作为负载</li></ol><h2 id="本文使用方法"><a href="#本文使用方法" class="headerlink" title="本文使用方法"></a>本文使用方法</h2><p>根据过去一段时间的运行队列的活跃程度，以及对应进程的权重作为负载的主要参数</p><ol><li>设置一个load_list用来存放当前核上的pcb加入队列的时钟数</li><li>计算每个核的过去一段时间的运行队列数量<ol><li>在进行入队操作时，通过rdtsc()获取当前的时钟，并将当前时钟加入load_list</li><li>将队首元素中与当前时钟差距大于一个临界值的全部出队列</li></ol></li><li>获取CPU的的负载时，只需要获取对应的load_list的长度即可</li></ol><blockquote><ol><li>关于临界值的判断</li></ol><p>假设load_list队首元素的值为a，当前时钟数为b，当前系统的CPU频率为2.5GHZ，那么(a-b)&#x2F;2.5×10^9^即为两次入队操作经过的时间，假设我们的临界值为t，t的意义为统计过去t秒的CPU的负载情况，那么需要 (a-b)&#x2F;2.5×10^9^&gt;t 是临界情况。</p><p>由于操作系统内核不能做浮点运算，将其调整为 (a-b)&gt;t×2.5×10^9^ 作为临界情况</p><ol start="2"><li>关于时钟数面临被重置导致b&lt;a，经查阅发现rdtsc() 获取的时钟数占据了64位，假设在2.5GHZ的CPU上跑，需要跑两百多年才会归零，因此可以忽略此问题。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230311174759773.png" alt="image-20230311174759773"></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/0c519fc6248b">使用rdtsc测量函数的执行时间 - 简书 (jianshu.com)</a></p><p><a href="http://www.wangkaixuan.tech/?p=901">细说RDTSC的坑 – Dreamer Thinker Doer (wangkaixuan.tech)</a></p>]]></content>
    
    
    <categories>
      
      <category>DragonOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 167</title>
    <link href="/posts/40874.html"/>
    <url>/posts/40874.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：numbers = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[1,2]</span><br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 <span class="hljs-comment">[1, 2]</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+双指针</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了36.44%的用户</p><p>内存消耗：44.3 MB, 在所有 Java 提交中击败了50.61%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(nlongn)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        Arrays.sort(numbers);<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=numbers.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> sum=numbers[left]+numbers[right];<br>            <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []&#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 学习资料</title>
    <link href="/posts/50986.html"/>
    <url>/posts/50986.html</url>
    
    <content type="html"><![CDATA[<h2 id="Java复习资料"><a href="#Java复习资料" class="headerlink" title="Java复习资料"></a>Java复习资料</h2><blockquote><p>分享一些在准备Java面试过程中的常用资料，大多是别人整理的笔记</p></blockquote><ul><li>Java基础-尚硅谷康师傅课程笔记<ul><li><a href="https://blog.csdn.net/PorkBird/article/details/113666542">JavaSE目录_程序员卖剩鸭的博客-CSDN博客</a></li></ul></li><li>ssm+SpringBoot 全家桶-黑马程序员<ul><li><a href="https://www.yuque.com/kkuping/yuqzh2/nxtocy#CjngY">SpringMVC · 语雀 (yuque.com)</a></li></ul></li><li>Java常用面试题集合及路线规划<ul><li><a href="https://javaguide.cn/home.html">JavaGuide（Java学习&amp;&amp;面试指南） | JavaGuide(Java面试+学习指南)</a></li><li><a href="https://tobebetterjavaer.com/home.html">Java程序员进阶之路x沉默王二 | Java程序员进阶之路 (tobebetterjavaer.com)</a></li></ul></li><li>LeetCode模板<ul><li><a href="https://labuladong.github.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄</a></li></ul></li></ul><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 76</title>
    <link href="/posts/52193.html"/>
    <url>/posts/52193.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br>解释：最小覆盖子串 <span class="hljs-string">&quot;BANC&quot;</span> 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口：</li></ol><blockquote><p>注意：Java 的 Integer，String 等类型判定相等不能使用&#x3D;&#x3D;，而要使用equals，这是包装类的一个细节</p></blockquote><blockquote><p>执行用时：14 ms, 在所有 Java 提交中击败了63.87%的用户</p><p>内存消耗：42.2 MB, 在所有 Java 提交中击败了38.80%的用户</p><p>通过测试用例：267 &#x2F; 267</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length()&lt;t.length())<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        HashMap&lt;Character,Integer&gt; map_s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        HashMap&lt;Character,Integer&gt; map_t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=t.charAt(i);<br>            map_t.put(c,map_t.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans=Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;s.length())&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(right);<br>            map_s.put(c,map_s.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span>(map_t.containsKey(c))&#123;<br>                <span class="hljs-keyword">if</span>(map_s.get(c).equals(map_t.get(c)))&#123;<br>                    num++;<br>                &#125;<br>            &#125;<br>            right++;<br><br>            <span class="hljs-keyword">while</span>(num==map_t.size())&#123;<br>                <span class="hljs-keyword">if</span>(ans&gt;right-left)&#123;<br>                    l=left;<br>                    r=right;<br>                    ans=right-left;<br>                &#125;<br>                <span class="hljs-type">char</span> c2=s.charAt(left);<br>                <span class="hljs-keyword">if</span>(map_t.containsKey(c2))&#123;<br>                    <span class="hljs-keyword">if</span>(map_s.get(c2).equals(map_t.get(c2)))&#123;<br>                        num--;<br>                    &#125;<br>                    map_s.put(c2,map_s.get(c2)-<span class="hljs-number">1</span>);<br>                &#125;<br>                left++;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(l,r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 34</title>
    <link href="/posts/51810.html"/>
    <url>/posts/51810.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>两个二分，分别找左边界和右边界</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：44.2 MB, 在所有 Java 提交中击败了98.88%的用户</p><p>通过测试用例：88 &#x2F; 88</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> []ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==target)&#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left==nums.length)ans[<span class="hljs-number">0</span>]=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans[<span class="hljs-number">0</span>]=nums[left]==target?left:-<span class="hljs-number">1</span>;<br>        &#125;<br>        left=<span class="hljs-number">0</span>;<br>        right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==target)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&lt;<span class="hljs-number">1</span>)ans[<span class="hljs-number">1</span>]=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans[<span class="hljs-number">1</span>]=nums[left-<span class="hljs-number">1</span>]==target?left-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 704</title>
    <link href="/posts/16137.html"/>
    <url>/posts/16137.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>二分</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：42.1 MB, 在所有 Java 提交中击败了50.35%的用户</p><p>通过测试用例：47 &#x2F; 47</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span>left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 752</title>
    <link href="/posts/28042.html"/>
    <url>/posts/28042.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></h4><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为 <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：deadends = [<span class="hljs-string">&quot;0201&quot;</span>,<span class="hljs-string">&quot;0101&quot;</span>,<span class="hljs-string">&quot;0102&quot;</span>,<span class="hljs-string">&quot;1212&quot;</span>,<span class="hljs-string">&quot;2002&quot;</span>], target = <span class="hljs-string">&quot;0202&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<br>可能的移动序列为 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;1000&quot;</span> -&gt; <span class="hljs-string">&quot;1100&quot;</span> -&gt; <span class="hljs-string">&quot;1200&quot;</span> -&gt; <span class="hljs-string">&quot;1201&quot;</span> -&gt; <span class="hljs-string">&quot;1202&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span>。<br>注意 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;0001&quot;</span> -&gt; <span class="hljs-string">&quot;0002&quot;</span> -&gt; <span class="hljs-string">&quot;0102&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span> 这样的序列是不能解锁的，<br>因为当拨动到 <span class="hljs-string">&quot;0102&quot;</span> 时这个锁就会被锁定。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>BFS</li></ol><blockquote><p>执行用时：86 ms, 在所有 Java 提交中击败了31.88%的用户</p><p>内存消耗：46.8 MB, 在所有 Java 提交中击败了58.50%的用户</p><p>通过测试用例：48 &#x2F; 48</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">up</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">char</span> []charArray=s.toCharArray();<br>        <span class="hljs-keyword">if</span>(charArray[i]==<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            charArray[i]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            charArray[i]+=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">down</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">char</span> []charArray=s.toCharArray();<br>        <span class="hljs-keyword">if</span>(charArray[i]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            charArray[i]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            charArray[i]-=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br><br>    &#125;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> &#123;<br>        Queue&lt;String&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        Set&lt;String&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        Set&lt;String&gt; visited=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-comment">// for(String s:deadends)set.add(s);</span><br>        Collections.addAll(set,deadends);<br>        queue.offer(<span class="hljs-string">&quot;0000&quot;</span>);<br>        visited.add(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> len=queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                String val=queue.poll();<br>                <span class="hljs-keyword">if</span>(set.contains(val))<span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(val.equals(target))&#123;<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br>                    String up=up(val,j);<br>                    String down=down(val,j);<br>                    <span class="hljs-keyword">if</span>(!visited.contains(up))&#123;<br>                        queue.offer(up);<br>                        visited.add(up);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(!visited.contains(down))&#123;<br>                        queue.offer(down);<br>                        visited.add(down);<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 111</title>
    <link href="/posts/44328.html"/>
    <url>/posts/44328.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/ex_depth.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>BFS</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了93.80%的用户</p><p>内存消耗：60.4 MB, 在所有 Java 提交中击败了86.65%的用户</p><p>通过测试用例：52 &#x2F; 52</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        queue.offer(root);<br>        <span class="hljs-type">int</span> deepth=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> len=queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                TreeNode node=queue.poll();<br>                <span class="hljs-keyword">if</span>(node.left==<span class="hljs-literal">null</span>&amp;&amp;node.right==<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> deepth;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(node.right);<br>                &#125;<br><br>            &#125;<br>            deepth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deepth;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github 首页个人信息展示</title>
    <link href="/posts/18448.html"/>
    <url>/posts/18448.html</url>
    
    <content type="html"><![CDATA[<h2 id="github首页配置"><a href="#github首页配置" class="headerlink" title="github首页配置"></a>github首页配置</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>美化github首页，成果如下，欢迎访问</p><p><a href="https://github.com/kkkkkong">kkkkkong (kong) (github.com)</a></p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li>创建github同名仓库</li><li>填写README.md</li><li>配置README.md</li></ol><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>问题描述</p><blockquote><p>Error: Pushing to <a href="https://github.com/kkkkkong/kkkkkong">https://github.com/kkkkkong/kkkkkong</a> remote: Permission to kkkkkong&#x2F;kkkkkong.git denied to github-actions[bot]. fatal: unable to access ‘<a href="https://github.com/kkkkkong/kkkkkong/&#39;">https://github.com/kkkkkong/kkkkkong/&#39;</a>: The requested URL returned error: 403</p></blockquote><p>这个错误意味着你尝试将代码推送到GitHub上的一个仓库，但是你没有足够的权限来进行这个操作。具体地说，这个错误信息显示了github-actions[bot]被拒绝了权限，因此无法推送代码到这个仓库。</p><p>我尝试了以下操作</p><ol><li>首先可能是因为github action没有权限，因此创建访问令牌或者使用ssh秘钥，然后配置文件被我修改成这样<ol><li>首先，在你的GitHub账户中生成一个新的访问令牌。你可以按照以下步骤来生成一个GitHub访问令牌：<ol><li>首先，登录到你的GitHub帐户中。</li><li>点击右上角的你的头像，然后选择”Settings”。</li><li>在左侧菜单中，选择”Developer settings”，然后选择”Personal access tokens”。</li><li>点击”Generate new token”按钮。</li><li>在”Note”字段中，为你的访问令牌添加一个描述性的名称。</li><li>选择所需的权限。根据你的需求，你可以选择只授予必要的权限，以便最大程度地减少安全风险。如果你不确定要选择哪些权限，请参考<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">GitHub官方文档</a>。</li><li>点击”Generate token”按钮。</li><li>复制生成的访问令牌。请注意，此令牌仅在此时显示，你必须复制它以后才能使用。</li><li>将该访问令牌安全地保存在一个安全的位置，以便以后使用。</li></ol></li><li>将生成的访问令牌添加到你的GitHub存储库的<code>Secrets</code>中。在你的存储库中，点击<code>Settings</code>，然后点击<code>Secrets</code>，再点击<code>New repository secret</code>按钮来添加一个新的秘密。你需要将秘密的名称设置为<code>ACCESS_TOKEN</code>，并将生成的访问令牌作为值输入。</li><li>在你的workflow文件中，使用<code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code>来引用你的访问令牌。</li></ol></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># GitHub Action for generating a contribution graph with a snake eating your contributions.</span><br><br><span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">Snake</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 * * *&quot;</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2.3.4</span><br>      <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">Snake</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">Platane/snk@master</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">snake-gif</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_user_name:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.repository_owner</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">gif_out_path:</span> <span class="hljs-string">./assets/github-contribution-grid-snake.gif</span><br>          <span class="hljs-attr">svg_out_path:</span> <span class="hljs-string">./assets/github-contribution-grid-snake.svg</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Push</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">EndBug/add-and-commit@v7.2.1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br>          <span class="hljs-attr">message:</span> <span class="hljs-string">&#x27;Generate Contribution Snake&#x27;</span><br>          <span class="hljs-attr">author_name:</span> <span class="hljs-string">Your</span> <span class="hljs-string">Name</span><br>          <span class="hljs-attr">author_email:</span> <span class="hljs-string">yourname@example.com</span><br>          <span class="hljs-attr">force:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>我的仍然不起作用，后来发现仓库默认情况下，新存储库没有适当的工作流权限。修改后可以运行了<ol><li>转到存储库<strong>Setting</strong></li><li>选择<strong>Actions</strong>&gt;&gt;&gt;<strong>General</strong></li><li>在”工作流权限(Workflow permissions)”中，选择<code>Read and write permissions</code></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/9513280ff5fd4ac8867c6ba44346a290.png" alt="img"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/454597068">Github 首页美化教程（一）：打造个性化的GitHub首页 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_42282187/article/details/124766382?spm=1001.2014.3001.5501">【Git】workflows 部署 vuepress 错误“The process ‘&#x2F;usr&#x2F;bin&#x2F;git‘ failed with exit code 128“_the process ‘&#x2F;usr&#x2F;bin&#x2F;git’ failed with exit code 1_菜鸟点滴的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 47</title>
    <link href="/posts/64288.html"/>
    <url>/posts/64288.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素重复的不可重复选的排列问题</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了41.88%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了89.25%的用户</p><p>通过测试用例：33 &#x2F; 33</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">boolean</span> []used=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backTrack(nums,used);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">boolean</span> []used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.size()==nums.length)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(nums[i])||used[i]==<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            set.add(nums[i]);<br>            list.add(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            backTrack(nums,used);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>            used[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 40</title>
    <link href="/posts/14689.html"/>
    <url>/posts/14689.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h4><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素可重复的不可重复选的组合问题。如果不进行第二段剪枝的话会超时</li></ol><blockquote><p>执行用时：4 ms, 在所有 Java 提交中击败了43.75%的用户</p><p>内存消耗：41.7 MB, 在所有 Java 提交中击败了65.39%的用户</p><p>通过测试用例：176 &#x2F; 176</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backTrack(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> []candidates,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;candidates.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;start&amp;&amp;candidates[i]==candidates[i-<span class="hljs-number">1</span>])<span class="hljs-keyword">continue</span>;<br>            list.add(candidates[i]);<br>            backTrack(candidates,target,i+<span class="hljs-number">1</span>,sum+candidates[i]);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 90</title>
    <link href="/posts/43365.html"/>
    <url>/posts/43365.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素重复不可复选问题，需要提前排序</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了99.17%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了76.27%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backTrace(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrace</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> begin)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>((i&gt;begin)&amp;&amp;(nums[i]==nums[i-<span class="hljs-number">1</span>]))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            list.add(nums[i]);<br>            backTrace(nums,i+<span class="hljs-number">1</span>);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 77</title>
    <link href="/posts/2848.html"/>
    <url>/posts/2848.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素无重复不可复选问题</li></ol><blockquote><p>执行用时：18 ms, 在所有 Java 提交中击败了25.06%的用户</p><p>内存消耗：42.9 MB, 在所有 Java 提交中击败了37.61%的用户</p><p>通过测试用例：27 &#x2F; 27</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backTrace(n,<span class="hljs-number">1</span>,k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrace</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.size()==k)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(;begin&lt;=n;begin++)&#123;<br>            list.add(begin);<br>            backTrace(n,begin+<span class="hljs-number">1</span>,k);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 78</title>
    <link href="/posts/3936.html"/>
    <url>/posts/3936.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+组合：元素无重复不可重复选问题</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了6.15%的用户</p><p>通过测试用例：10 &#x2F; 10</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        getSets(nums,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSets</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> begin,List&lt;Integer&gt; list)</span>&#123;<br>        <span class="hljs-keyword">for</span>(;begin&lt;nums.length;begin++)&#123;<br>            list.add(nums[begin]);<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>            getSets(nums,begin+<span class="hljs-number">1</span>,list);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>稍微修改一下</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了10.75%的用户</p><p>通过测试用例：10 &#x2F; 10</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        getSets(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSets</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> begin)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>        <span class="hljs-keyword">for</span>(;begin&lt;nums.length;begin++)&#123;<br>            list.add(nums[begin]);<br>            getSets(nums,begin+<span class="hljs-number">1</span>);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一台电脑连接多个github账户如何配置秘钥</title>
    <link href="/posts/37835.html"/>
    <url>/posts/37835.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室多个人使用同一台服务器，使用git时配置秘钥分别连接自己的github账户，此时会出现总是匹配一个固定的秘钥的情况</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-生成秘钥"><a href="#1-生成秘钥" class="headerlink" title="1. 生成秘钥"></a>1. 生成秘钥</h3><p>此处具体细节和网上的一样，假设生成两个秘钥，名字分别为id_rsa和id_rsa_bak，对应的公钥为后缀多了.pub</p><h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="2. 编辑配置文件"></a>2. 编辑配置文件</h3><p>编辑<code>.ssh/config</code>文件，内容为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"># 第一个<br>Host github_one<br>Hostname github.com<br>IdentityFile ~/.ssh/id_rsa<br><br># 第二个<br>Host github_two<br>Hostname github.com<br>IdentityFile ~/.ssh/id_rsa_bak<br></code></pre></td></tr></table></figure><blockquote><p>网上的大部分教程都是避其锋芒，配置里大多是不同的网站，比如github和gitee，明显不符合我们的需求</p></blockquote><p>把公钥放在对应的github账户上，然后执行下面的命令即可</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">ssh -T git@github_one<br>ssh -T git@github_two<br></code></pre></td></tr></table></figure><h3 id="3-关联仓库"><a href="#3-关联仓库" class="headerlink" title="3. 关联仓库"></a>3. 关联仓库</h3><p>在以后关联仓库的时候，把@后面的内容要修改为对应的host</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote add origin git@github_one:xxx/example.git # public user<br>git remote add origin git@github_two:xxx/example.git # priavate user<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/107341502">一台电脑双GitHub账户配置 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 51</title>
    <link href="/posts/27041.html"/>
    <url>/posts/27041.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h4><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/queens.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+哈希：做前序状态记录比较麻烦，导致效率不高</li></ol><blockquote><p>执行用时：9 ms, 在所有 Java 提交中击败了10.60%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了34.87%的用户</p><p>通过测试用例：9 &#x2F; 9</p><p>时间 O(NLogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        backTrack(n,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer,Integer&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n,List&lt;String&gt; list,HashMap&lt;Integer,Integer&gt; used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.size()==n)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(used.containsValue(i))<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> x=used.getOrDefault(used.size()-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(x!=-<span class="hljs-number">1</span>&amp;&amp;!isTrue(used,i,n))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">char</span> []c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>            Arrays.fill(c,<span class="hljs-string">&#x27;.&#x27;</span>);<br>            c[i]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>            used.put(used.size(),i);<br>            list.add(String.valueOf(c));<br>            backTrack(n,list,used);<br>            list.remove(list.size()-<span class="hljs-number">1</span>);<br>            used.remove(used.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTrue</span><span class="hljs-params">(HashMap&lt;Integer,Integer&gt; used,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> j=used.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;j;t++)&#123;<br>            <span class="hljs-keyword">if</span>(used.getOrDefault(t,-<span class="hljs-number">1</span>)==i)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;t+i&lt;n&amp;&amp;j-t&gt;=<span class="hljs-number">0</span>;t++)&#123;<br>            <span class="hljs-keyword">if</span>(used.getOrDefault(j-t,-<span class="hljs-number">1</span>)==i+t)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;t&lt;=j&amp;&amp;t&lt;=i;t++)&#123;<br>            <span class="hljs-keyword">if</span>(used.getOrDefault(j-t,-<span class="hljs-number">1</span>)==i-t)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 46</title>
    <link href="/posts/15329.html"/>
    <url>/posts/15329.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+回溯：引入了额外的哈希表，但浪费时间，可能是在数组与list的转换上，需要用到stream来装箱</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了8.40%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了28.32%的用户</p><p>通过测试用例：26 &#x2F; 26</p><p>时间 O(N!)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; tmpNums=Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        backTrack(tmpNums,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(List&lt;Integer&gt; nums,List&lt;Integer&gt; tmp)</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">1</span>)&#123;<br>            tmp.add(nums.get(<span class="hljs-number">0</span>));<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(tmp));<br>            tmp.remove(tmp.size()-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=nums.size()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> num=nums.get(i);<br>            tmp.add(num);<br>            nums.remove(i);<br>            backTrack(nums,tmp);<br>            nums.add(i,num);<br>            tmp.remove(tmp.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>回溯：使用额外的数组来标记是否使用了某元素</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了44.06%的用户</p><p>通过测试用例：26 &#x2F; 26</p><p>时间 O(N!)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">boolean</span> []used=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span> [nums.length];<br>        backTrack(nums,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(),used);<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums,List&lt;Integer&gt; tmp,<span class="hljs-type">boolean</span> []used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tmp.size()==nums.length)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">true</span>)<span class="hljs-keyword">continue</span>;<br>            tmp.add(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            backTrack(nums,tmp,used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            tmp.remove(tmp.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 322</title>
    <link href="/posts/40137.html"/>
    <url>/posts/40137.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h4><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解 超时</li><li>加备忘录</li></ol><blockquote><p>执行用时：142 ms, 在所有 Java 提交中击败了5.00%的用户</p><p>内存消耗：43.3 MB, 在所有 Java 提交中击败了5.08%的用户</p><p>通过测试用例：189 &#x2F; 189</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">return</span> getChange(coins,amount);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span>&#123;<br>        <span class="hljs-keyword">if</span>(amount&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(amount==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(map.containsKey(amount))<span class="hljs-keyword">return</span> map.get(amount);<br>        <span class="hljs-type">int</span> ans=Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:coins)&#123;<br>            <span class="hljs-type">int</span> tmp=getChange(coins,amount-i);<br>            <span class="hljs-keyword">if</span>(tmp==-<span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br>            ans=Math.min(ans,tmp+<span class="hljs-number">1</span>);<br>        &#125;<br>        ans = ans==Integer.MAX_VALUE?-<span class="hljs-number">1</span>:ans;<br>        map.put(amount,ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>自底向上，dp数组迭代，来自题解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span><br>    Arrays.fill(dp, amount + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 外层 for 循环在遍历所有状态的所有取值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>        <span class="hljs-comment">// 内层 for 循环在求所有选择的最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>            <span class="hljs-comment">// 子问题无解，跳过</span><br>            <span class="hljs-keyword">if</span> (i - coin &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[i] = Math.min(dp[i], <span class="hljs-number">1</span> + dp[i - coin]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (dp[amount] == amount + <span class="hljs-number">1</span>) ? -<span class="hljs-number">1</span> : dp[amount];<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 344</title>
    <link href="/posts/15946.html"/>
    <url>/posts/15946.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]<br>输出：[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>双指针，简单题我重拳出击</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：47.8 MB, 在所有 Java 提交中击败了94.56%的用户</p><p>通过测试用例：477 &#x2F; 477</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,n=s.length,right=n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">char</span> tmp=s[left];<br>            s[left]=s[right];<br>            s[right]=tmp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 83</title>
    <link href="/posts/14372.html"/>
    <url>/posts/14372.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/list1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>双指针</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.9 MB, 在所有 Java 提交中击败了69.93%的用户</p><p>通过测试用例：166 &#x2F; 166</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> head;<br>        ListNode low=head,fast=head.next;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast.val==low.val)&#123;<br>                low.next=fast.next;<br>                fast=low.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                fast=fast.next;<br>                low=low.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 26</title>
    <link href="/posts/39906.html"/>
    <url>/posts/39906.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。</p><p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p><p>不要使用额外的空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int[] nums <span class="hljs-operator">=</span> [...]<span class="hljs-comment">; // 输入数组</span><br>int[] expectedNums <span class="hljs-operator">=</span> [...]<span class="hljs-comment">; // 长度正确的期望答案</span><br><br>int k <span class="hljs-operator">=</span> removeDuplicates(nums)<span class="hljs-comment">; // 调用</span><br><br>assert k <span class="hljs-operator">=</span><span class="hljs-operator">=</span> expectedNums.length<span class="hljs-comment">;</span><br>for (int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; k; i++) &#123;</span><br>    assert nums[i] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> expectedNums[i]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>快慢指针</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：43.3 MB, 在所有 Java 提交中击败了29.47%的用户</p><p>通过测试用例：361 &#x2F; 361</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> low=<span class="hljs-number">1</span>,fast=<span class="hljs-number">1</span>,n=nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=nums[i-<span class="hljs-number">1</span>])&#123;<br>                nums[low]=nums[i];<br>                low++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 86</title>
    <link href="/posts/15332.html"/>
    <url>/posts/15332.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h4><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/partition.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>注意要断开原指针的链接</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.1 MB, 在所有 Java 提交中击败了40.53%的用户</p><p>通过测试用例：168 &#x2F; 168</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>        ListNode ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>),p=ans;<br>        ListNode tail=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>),p2=tail;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val&lt;x)&#123;<br>                p.next=head;<br>                p=p.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                p2.next=head;<br>                p2=p2.next;<br>            &#125;<br>            <span class="hljs-comment">// 断开原链表中的每个节点的 next 指针</span><br>            ListNode tmp=head.next;<br>            head.next=<span class="hljs-literal">null</span>;<br>            head=tmp;<br>        &#125;<br>        p.next=tail.next;<br>        <span class="hljs-keyword">return</span> ans.next;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 904</title>
    <link href="/posts/64616.html"/>
    <url>/posts/64616.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h4><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口+哈希表</li></ol><blockquote><p>执行用时：42 ms, 在所有 Java 提交中击败了64.08%的用户</p><p>内存消耗：50.6 MB, 在所有 Java 提交中击败了52.45%的用户</p><p>通过测试用例：91 &#x2F; 91</p><p>时间 O(N)</p><p>空间 O(1),最多只用3个空间的map，可以看做是常数空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,n=fruits.length,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            map.put(fruits[right],map.getOrDefault(fruits[right],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            right++;<br>            <span class="hljs-keyword">while</span>(map.size()&gt;<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">int</span> value=map.get(fruits[left]);<br>                <span class="hljs-keyword">if</span>(value&gt;<span class="hljs-number">1</span>)&#123;<br>                    map.put(fruits[left],value-<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    map.remove(fruits[left]);<br>                &#125;<br>                left++;<br>            &#125;<br>            ans=Math.max(ans,right-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 395</title>
    <link href="/posts/28303.html"/>
    <url>/posts/28303.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h4><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;aaabb&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：最长子串为 <span class="hljs-string">&quot;aaa&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">3</span> 次。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>分治：递归返回条件：s.length()&lt;k或找到符合条件的s</li></ol><blockquote><p>执行用时：4 ms, 在所有 Java 提交中击败了60.30%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了34.40%的用户</p><p>通过测试用例：37 &#x2F; 37</p><p>时间 O(N<em>26</em>26)</p><p>空间 O(26*26）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-keyword">if</span>(n&lt;k)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Map&lt;Character,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(i);<br>            map.put(c,map.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(c)&lt;k)&#123;<br>                <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(String str:s.split(String.valueOf(c)))&#123;<br>                    res=Math.max(res,longestSubstring(str,k));<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 978</title>
    <link href="/posts/51562.html"/>
    <url>/posts/51562.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h4><p>给定一个整数数组 <code>arr</code> ，返回 <code>arr</code> 的 <em>最大湍流子数组的<strong>长度</strong></em> 。</p><p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 <strong>湍流子数组</strong> 。</p><p>更正式地来说，当 <code>arr</code> 的子数组 <code>A[i], A[i+1], ..., A[j]</code> 满足仅满足下列条件时，我们称其为<em>湍流子数组</em>：</p><ul><li><p>若 </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">i &lt;<span class="hljs-operator">=</span> k &lt; j<br></code></pre></td></tr></table></figure><p> ：</p><ul><li>当 <code>k</code> 为奇数时， <code>A[k] &gt; A[k+1]</code>，且</li><li>当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li></ul></li><li><p>或 </p><p>若 </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">i &lt;<span class="hljs-operator">=</span> k &lt; j<br></code></pre></td></tr></table></figure><p> ：</p><ul><li>当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code> ，且</li><li>当 <code>k</code> 为奇数时， <code>A[k] &lt; A[k+1]</code>。</li></ul></li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[9,4,2,10,7,8,8,1,9]</span><br>输出：5<br>解释：arr<span class="hljs-comment">[1]</span> &gt; arr<span class="hljs-comment">[2]</span> &lt; arr<span class="hljs-comment">[3]</span> &gt; arr<span class="hljs-comment">[4]</span> &lt; arr<span class="hljs-comment">[5]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑窗，使用一个boolean类型变量记录情况，</li></ol><p>面向测试用例编程</p><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了43.97%的用户</p><p>内存消耗：45.5 MB, 在所有 Java 提交中击败了70.82%的用户</p><p>通过测试用例：91 &#x2F; 91</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,n=arr.length;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">boolean</span> judge=arr[<span class="hljs-number">0</span>]&gt;arr[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(right&lt;n-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 如果符合条件</span><br>            <span class="hljs-keyword">if</span>((arr[right]&gt;arr[right+<span class="hljs-number">1</span>])==judge&amp;&amp;arr[right]!=arr[right+<span class="hljs-number">1</span>])&#123;<br>                right++;<br>                judge=!judge;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(arr[right]==arr[right+<span class="hljs-number">1</span>])right++;<br>                left=right;<br>                <span class="hljs-keyword">if</span>(right&lt;n-<span class="hljs-number">1</span>)&#123;<br>                    judge=arr[right]&gt;arr[right+<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>            ans=Math.max(ans,right-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 567</title>
    <link href="/posts/24299.html"/>
    <url>/posts/24299.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h4><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑窗：滑窗更新字符出现的次数，两数组相等时为true，但每次判断是否相等需要O(N)，因此使用一个变量来保存二者之间的距离</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了79.71%的用户</p><p>内存消耗：41.5 MB, 在所有 Java 提交中击败了46.65%的用户</p><p>通过测试用例：108 &#x2F; 108</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-comment">// 数组存放字母出现的次数</span><br>        <span class="hljs-type">int</span> []s1Count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> []s2Count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// 滑窗更新字符出现的次数，两数组相等时为true，但每次判断是否相等需要O(N)，因此使用一个变量来保存二者之间的距离</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,s1Len=s1.length(),s2Len=s2.length();<br>        <span class="hljs-type">int</span> diff=s1Len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1Len;i++)&#123;<br>            s1Count[s1.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right&lt;s2Len)&#123;<br>            <span class="hljs-type">char</span> c=s2.charAt(right);<br>            <span class="hljs-keyword">if</span>(s2Count[c-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;s1Count[c-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                diff--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                diff++;<br>            &#125;<br>            s2Count[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            right++;<br>            <span class="hljs-keyword">if</span>(right-left&gt;s1Len)&#123;<br>                <span class="hljs-type">char</span> c2=s2.charAt(left);<br>                <span class="hljs-keyword">if</span>(s2Count[c2-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;=s1Count[c2-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                    diff++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    diff--;<br>                &#125;<br>                s2Count[c2-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(diff==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 学习</title>
    <link href="/posts/34491.html"/>
    <url>/posts/34491.html</url>
    
    <content type="html"><![CDATA[<h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ol><li>介绍下 Java 内存区域（运行时数据区）<ol><li>（方法区、堆）线程共享，不安全</li><li>（栈、本地方法区、程序计数器）线程独享，安全</li></ol></li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）<br>1. </li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）<ol><li></li></ol></li></ol><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ol><li>如何判断对象是否死亡（两种方法）。<ol><li>引用计数法<ol><li>给对象中添加一个引用计数器<ol><li>每当有一个地方引用它，计数器加一</li><li>当引用失效时，计数器减一</li><li>任何时候计数器为0都说明对象不可能再被使用了</li></ol></li><li>此方法简单，效率高。但目前主流的虚拟机并没有使用该方法，因为无法解决循环引用问题</li></ol></li><li>可达性分析算法<ol><li>基本思想是通过一些列“GC root” 的对象作为起点，从这些节点向下搜索，节点走过的路径称为引用链，当一个对象到GC root没有任何引用链的时候，则证明该对象是不可用的，需要回收。</li></ol></li></ol></li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。<ol><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ol></li><li>如何判断一个常量是废弃常量<ol><li>没有被任何String对象引用的常量就是废弃常量</li></ol></li><li>如何判断一个类是无用的类<ol><li>三点<ol><li>加载该类的Classloader被回收</li><li>类对应的实例都被回收</li><li>该类对应的java.lang.class对象没有在任何地方被引用，也无法通过反射机制访问该类的方法</li></ol></li></ol></li><li>垃圾收集有哪些算法，各自的特点？<ol><li>标记清除-容易产生碎片</li><li>标记复制-占用空间比较大</li><li>标记整理-</li><li>分代回收- 将java堆中的对象分为新生代、老年代和永久代</li></ol></li><li>HotSpot 为什么要分为新生代和老年代？<ol><li>方便垃圾回收，新生代每次回收都会有大量对象死去，因此选用标记清除算法，每次只需要少量的对象复制空间即可完成回收；而老年代多是存活纪律较高的对象，而且没有额外的空间去怼他进行分配担保，所以选用标记清除或标记整理进行回收</li></ol></li><li>常见的垃圾回收器有哪些？<ol><li>serial收集器</li><li>parNew</li><li>Parallel Scavenge</li><li>Serial Old</li><li>Parallel Old</li><li>CMS<ol><li>以获取最短回收时间为目标的收集器，第一个真正的并发收集器</li></ol></li><li>G1</li><li>ZGC</li></ol></li><li>介绍一下 CMS,G1 收集器。<br>1. </li><li>Minor Gc 和 Full GC 有什么不同呢？<ol><li>Minor GC 回收年轻代</li><li>Full GC： 负责从整个内存区回收</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 438</title>
    <link href="/posts/51961.html"/>
    <url>/posts/51961.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>数组差+滑窗，用两个数组分别表示字符串p中字母出现的次数以及滑窗中字母出现的次数，方便统计，采用变量diff表示两个数组的不同字母数。diff为0时，将left指针加入结果集中</li></ol><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了67.39%的用户</p><p>内存消耗：42.7 MB, 在所有 Java 提交中击败了38.45%的用户</p><p>通过测试用例：64 &#x2F; 64</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> []ptmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> []stmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,n=s.length();<br>        <span class="hljs-type">int</span> plen=p.length();<br>        <span class="hljs-type">int</span> diff=plen;<br>        List&lt;Integer&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;plen;i++)&#123;<br>            ptmp[p.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&gt;plen)&#123;<br>                <span class="hljs-keyword">if</span>(stmp[s.charAt(left)-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;=ptmp[s.charAt(left)-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                    diff++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    diff--;<br>                &#125;<br>                stmp[s.charAt(left)-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(stmp[s.charAt(right)-<span class="hljs-string">&#x27;a&#x27;</span>]&gt;=ptmp[s.charAt(right)-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                    diff++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    diff--;<br>                &#125;<br>                stmp[s.charAt(right)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(diff==<span class="hljs-number">0</span>)&#123;<br>                ans.add(left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1004</title>
    <link href="/posts/39420.html"/>
    <url>/posts/39420.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h4><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], K = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">6</span><br>解释：[<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0,1,1,1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>粗体数字从 <span class="hljs-number">0</span> 翻转到 <span class="hljs-number">1</span>，最长的子数组长度为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑窗，数组中只有1和0，可以用做和的形式来表示，左指针移动的条件为right-left+1&gt;sum+k</li></ol><blockquote><p>执行用时：4 ms, 在所有 Java 提交中击败了17.57%的用户</p><p>内存消耗：43.2 MB, 在所有 Java 提交中击败了20.81%的用户</p><p>通过测试用例：52 &#x2F; 52</p><p>时间 O(N)</p><p>空间O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            sum+=nums[right];<br>            <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&lt;=sum+k)&#123;<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                sum-=nums[left];<br>                left++;<br>            &#125;<br>            ans=Math.max(ans,right-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>精简一下，因为在一次左指针移动后，下次循环必定不会再进if，所以默认每次right++，减少循环次数</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了69.83%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了91.21%的用户</p><p>通过测试用例：52 &#x2F; 52</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            sum+=nums[right];<br>            <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&gt;sum+k)&#123;<br>                sum-=nums[left];<br>                left++;<br>            &#125;<br>            right++;<br>            ans=Math.max(ans,right-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 424</title>
    <link href="/posts/24568.html"/>
    <url>/posts/24568.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p><p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ABAB&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>数组+滑窗：两个关键条件，一个是maxcount，表示当前窗口内的单个单词的最大数目；另一个是left向前移动的条件，right-left&gt;max+k，巧妙的进行了控制</li></ol><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了29.40%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了53.10%的用户</p><p>通过测试用例：37 &#x2F; 37</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-type">int</span> maxCount=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            tmp[s.charAt(right)-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            maxCount=Math.max(maxCount,tmp[s.charAt(right)-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>            right++;<br><br>            <span class="hljs-keyword">if</span>(right-left&gt;maxCount+k)&#123;<br>                tmp[s.charAt(left)-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            ans=Math.max(ans,right-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 219</title>
    <link href="/posts/27609.html"/>
    <url>/posts/27609.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+滑动窗口</li></ol><blockquote><p>执行用时：16 ms, 在所有 Java 提交中击败了84.97%的用户</p><p>内存消耗：51.8 MB, 在所有 Java 提交中击败了34.72%的用户</p><p>通过测试用例：54 &#x2F; 54</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(right-left&lt;=k)&#123;<br>                <span class="hljs-keyword">if</span>(set.contains(nums[right]))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                set.add(nums[right]);<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                set.remove(nums[left]);<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 3</title>
    <link href="/posts/41773.html"/>
    <url>/posts/41773.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口+哈希表：右指针前进条件，set中不包含right指向元素，否则左指针前进，并移除掉当前左指针指向元素。</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了58.48%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了91.46%的用户</p><p>通过测试用例：987 &#x2F; 987</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(right);<br>            <span class="hljs-keyword">if</span>(!set.contains(c))&#123;<br>                len++;<br>                right++;<br>                set.add(c);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                len--;<br>                set.remove(s.charAt(left));<br>                left++;<br>            &#125;<br>            ans=Math.max(ans,len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>滑动窗口+数组：优化1，使用数组存放，ASCII编码，使用128大小的数组存放</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了92.81%的用户</p><p>内存消耗：41.2 MB, 在所有 Java 提交中击败了96.93%的用户</p><p>通过测试用例：987 &#x2F; 987</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(right);<br>            <span class="hljs-keyword">if</span>(tmp[c]==<span class="hljs-number">0</span>)&#123;<br>                len++;<br>                right++;<br>                tmp[c]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                len--;<br>                tmp[s.charAt(left)]=<span class="hljs-number">0</span>;<br>                left++;<br>            &#125;<br>            ans=Math.max(ans,len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 523</title>
    <link href="/posts/24040.html"/>
    <url>/posts/24040.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p><ul><li>子数组大小 <strong>至少为 2</strong> ，且</li><li>子数组元素总和为 <code>k</code> 的倍数。</li></ul><p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[23,2,4,6,7]</span>, k = 6<br>输出：true<br>解释：<span class="hljs-comment">[2,4]</span> 是一个大小为 2 的子数组，并且和为 6 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+同余定理+前缀和</li></ol><blockquote><p>执行用时：25 ms, 在所有 Java 提交中击败了9.51%的用户</p><p>内存消耗：56.9 MB, 在所有 Java 提交中击败了59.05%的用户</p><p>通过测试用例：98 &#x2F; 98</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,n=nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum+=nums[i];<br>            <span class="hljs-type">int</span> mod=sum%k;<br>            <span class="hljs-type">int</span> value=map.getOrDefault(mod,-<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(value!=-<span class="hljs-number">2</span>&amp;&amp;i-value&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            map.put(mod,map.getOrDefault(mod,i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 974</title>
    <link href="/posts/52330.html"/>
    <url>/posts/52330.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a></h4><p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p><p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [4,5,0,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,1], k = 5<br>输出：7<br>解释：<br>有 7 个子数组满足其元素之和可被 k = 5 整除：<br>[4, 5, 0, <span class="hljs-string">-2</span>, <span class="hljs-string">-3</span>, 1], [5], [5, 0], [5, 0, <span class="hljs-string">-2</span>, <span class="hljs-string">-3</span>], [0], [0, <span class="hljs-string">-2</span>, <span class="hljs-string">-3</span>], [<span class="hljs-string">-2</span>, <span class="hljs-string">-3</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+同余定理+哈希表，a和b对k的余数相同，那么(a-b)对k取余为0</li></ol><blockquote><p>执行用时：16 ms, 在所有 Java 提交中击败了81.95%的用户</p><p>内存消耗：47.6 MB, 在所有 Java 提交中击败了5.25%的用户</p><p>通过测试用例：73 &#x2F; 73</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysDivByK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>,n=nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum+=nums[i];<br>            <span class="hljs-type">int</span> mod=(sum%k+k)%k;<br>            <span class="hljs-type">int</span> value=map.getOrDefault(mod,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(value!=<span class="hljs-number">0</span>)&#123;<br>                ans+=value;<br>            &#125;<br>            map.put(mod,value+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 930</title>
    <link href="/posts/53097.html"/>
    <url>/posts/53097.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930. 和相同的二元子数组"></a><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></h4><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,0,1,0,1]</span>, goal = 2<br>输出：4<br>解释：<br>有 4 个满足题目要求的子数组：<span class="hljs-comment">[1,0,1]</span>、<span class="hljs-comment">[1,0,1,0]</span>、<span class="hljs-comment">[0,1,0,1]</span>、<span class="hljs-comment">[1,0,1]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：hashmap存放sum出现的次数</li></ol><blockquote><p>执行用时：20 ms, 在所有 Java 提交中击败了59.25%的用户</p><p>内存消耗：46.1 MB, 在所有 Java 提交中击败了35.95%的用户</p><p>通过测试用例：60 &#x2F; 60</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarraysWithSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> goal)</span> &#123;<br>        <span class="hljs-comment">// hashmap存放sum出现的次数</span><br>        Map &lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum+=nums[i];<br>            <span class="hljs-type">int</span> value=map.getOrDefault(sum-goal,-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(value!=-<span class="hljs-number">1</span>)&#123;<br>                ans+=value;<br>            &#125;<br>            map.put(sum,map.getOrDefault(sum,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>滑动窗口，重点打开思路，因为数组中只有0和1，需要使用两个左指针来表示right固定的情况下，有多少种情况满足</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了78.77%的用户</p><p>内存消耗：45.2 MB, 在所有 Java 提交中击败了60.27%的用户</p><p>通过测试用例：60 &#x2F; 60</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarraysWithSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> goal)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> left1=<span class="hljs-number">0</span>,left2=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>,sum1=<span class="hljs-number">0</span>,sum2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            sum1+=nums[right];<br>            <span class="hljs-keyword">while</span>(left1&lt;=right&amp;&amp;sum1&gt;goal)&#123;<br>                sum1-=nums[left1];<br>                left1++;<br>            &#125;<br>            sum2+=nums[right];<br>            <span class="hljs-keyword">while</span>(left2&lt;=right&amp;&amp;sum2&gt;=goal)&#123;<br>                sum2-=nums[left2];<br>                left2++;<br>            &#125;<br>            ans+=left2-left1;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 724</title>
    <link href="/posts/24328.html"/>
    <url>/posts/24328.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/">724. 寻找数组的中心下标</a></h4><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心下标是<span class="hljs-number"> 3 </span>。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 11 </span>，<br>右侧数之和 sum = nums[4] + nums[5] =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 11 </span>，二者相等。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了73.45%的用户</p><p>内存消耗：42.4 MB, 在所有 Java 提交中击败了32.02%的用户</p><p>通过测试用例：746 &#x2F; 746</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> []sum=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            sum[i]=sum[i-<span class="hljs-number">1</span>]+nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(sum[i]==sum[n]-sum[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>前缀和优化，不需要使用数组存储，只需要用一个变量记录当前的数组和是多少即可</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了36.89%的用户</p><p>内存消耗：42 MB, 在所有 Java 提交中击败了75.86%的用户</p><p>通过测试用例：746 &#x2F; 746</p><p>时间 O(N)</p><p>空间 O(1)</p><p>一样的代码，运行两次，也不知道是为何两次差距这么大</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了10.93%的用户</p><p>通过测试用例：746 &#x2F; 746</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum+=nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(pre==sum-pre-nums[i])&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            pre+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 560</title>
    <link href="/posts/40106.html"/>
    <url>/posts/40106.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：查找tmp[i]-k出现的次数</li></ol><blockquote><p>执行用时：17 ms, 在所有 Java 提交中击败了98.66%的用户</p><p>内存消耗：45.6 MB, 在所有 Java 提交中击败了39.34%的用户</p><p>通过测试用例：93 &#x2F; 93</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map &lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        tmp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            tmp[i]=tmp[i-<span class="hljs-number">1</span>]+nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 查找tmp[i]-k出现的次数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> q=tmp[i]-k;<br>            <span class="hljs-keyword">if</span>(q==<span class="hljs-number">0</span>)&#123;<br>                ans++;<br>            &#125;<br>            <span class="hljs-type">int</span> value=map.getOrDefault(q,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(value!=<span class="hljs-number">0</span>)&#123;<br>                ans+=value;<br>            &#125;<br>            map.put(tmp[i],map.getOrDefault(tmp[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>方法一的优化，笑死，优化完，时间翻倍了</li></ol><blockquote><p>执行用时：29 ms, 在所有 Java 提交中击败了40.76%的用户</p><p>内存消耗：44.9 MB, 在所有 Java 提交中击败了63.23%的用户</p><p>通过测试用例：93 &#x2F; 93</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map &lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            sum+=nums[i];<br>            <span class="hljs-type">int</span> q=sum-k;<br>            <span class="hljs-type">int</span> value=map.getOrDefault(q,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(value!=<span class="hljs-number">0</span>)&#123;<br>                ans+=value;<br>            &#125;<br>            map.put(sum,map.getOrDefault(sum,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 528</title>
    <link href="/posts/39593.html"/>
    <url>/posts/39593.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a><a href="https://leetcode.cn/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4><p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p><p>请你实现一个函数 <code>pickIndex</code> ，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code> 的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p><ul><li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，<code>75%</code>）。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;Solution&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>]<br>[[[<span class="hljs-number">1</span>]],[]]<br>输出：<br>[null,<span class="hljs-number">0</span>]<br>解释：<br><span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([<span class="hljs-number">1</span>]);<br>solution.pickIndex(); // 返回 <span class="hljs-number">0</span>，因为数组中只有一个元素，所以唯一的选择是返回下标 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+二分查找，重点是将权重数组以前缀和的形式表示出来，假设总权重和为sum，那么在[1,sum]上随机取数字，落在权重大的区间上的概率更大。二分查找只是更快的查到<strong>下标最大的小于x的区间</strong>在哪</li></ol><p>int x&#x3D;(int)(Math.random()*sum)+1;的取值很重要，random返回的是[0,1)的数字，不加1永远取不到sum的右边界</p><blockquote><p>执行用时：25 ms, 在所有 Java 提交中击败了45.06%的用户</p><p>内存消耗：45.8 MB, 在所有 Java 提交中击败了80.66%的用户</p><p>通过测试用例：57 &#x2F; 57</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []pre;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w)</span> &#123;<br>        pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[w.length];<br>        pre[<span class="hljs-number">0</span>]=w[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;w.length;i++)&#123;<br>            pre[i]=pre[i-<span class="hljs-number">1</span>]+w[i];<br>        &#125;<br>        sum=Arrays.stream(w).sum();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pickIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)(Math.random()*sum)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> binarySearch(pre,x);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> []pre,<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=pre.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> mid=(left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(pre[mid]&lt;x)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution obj = new Solution(w);</span><br><span class="hljs-comment"> * int param_1 = obj.pickIndex();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 525</title>
    <link href="/posts/24424.html"/>
    <url>/posts/24424.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a href="https://leetcode.cn/problems/contiguous-array/">525. 连续数组</a></h4><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [0,1]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这里的变0为-1真的是神来之笔</p></blockquote><ol><li>前缀和+变0为-1，将0变为-1后，主要统计前缀和，将第一次出现的元素保存到map中。特殊的，和为0的表示天然符合题目要求</li></ol><blockquote><p>执行用时：13 ms, 在所有 Java 提交中击败了97.19%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了95.36%的用户</p><p>通过测试用例：564 &#x2F; 564</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)nums[i]=-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 存放第一个和为k的元素位置</span><br>        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum+=nums[i];<br>            <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)&#123;<br>                ans=Math.max(ans,i+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> tmp=map.getOrDefault(sum,-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(tmp==-<span class="hljs-number">1</span>)&#123;<br>                map.put(sum,i);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans=Math.max(ans,i-tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 209</title>
    <link href="/posts/64472.html"/>
    <url>/posts/64472.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+二分查找 时空 O(NLogN) O(1)</li><li>前缀和作差+滑动窗口，这里的额外数组使用n+1长度更舒服，tmp[i]表示前i个元素的和</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了15.24%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了7.48%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-comment">// 数组计数，tmp[i]表示前i个元素的和</span><br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        tmp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            tmp[i]=tmp[i-<span class="hljs-number">1</span>]+nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp[n-<span class="hljs-number">1</span>]&lt;target)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(tmp[<span class="hljs-number">0</span>]&gt;=target)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,ans=Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span>(j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[j]&gt;=target)&#123;<br>                ans=Math.min(ans,j+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp[j]-tmp[i]&lt;target)&#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(tmp[j]-tmp[i]&gt;=target)&#123;<br>                    ans=Math.min(ans,j-i);<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>前缀和+滑动窗口，改进版</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：49.2 MB, 在所有 Java 提交中击败了14.99%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> ans=Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(end&lt;n)&#123;<br>            sum+=nums[end++];<br>            <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>                ans=Math.min(ans,end-start);<br>                sum-=nums[start++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==Integer.MAX_VALUE?<span class="hljs-number">0</span>:ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2341</title>
    <link href="/posts/7886.html"/>
    <url>/posts/7886.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2341-数组能形成多少数对"><a href="#2341-数组能形成多少数对" class="headerlink" title="2341. 数组能形成多少数对"></a><a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/">2341. 数组能形成多少数对</a></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p><ul><li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li><li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li></ul><p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p><p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中 <code>answer[0]</code> 是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,2,1,3,2,2]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> 和 nums<span class="hljs-comment">[3]</span> 形成一个数对，并从 nums 中移除，nums = <span class="hljs-comment">[3,2,3,2,2]</span> 。<br>nums<span class="hljs-comment">[0]</span> 和 nums<span class="hljs-comment">[2]</span> 形成一个数对，并从 nums 中移除，nums = <span class="hljs-comment">[2,2,2]</span> 。<br>nums<span class="hljs-comment">[0]</span> 和 nums<span class="hljs-comment">[1]</span> 形成一个数对，并从 nums 中移除，nums = <span class="hljs-comment">[2]</span> 。<br>无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+枚举：排序后遍历数组，如果一个数和他后面的数相等，那么说明这两个数需要移除，否则继续向后移动</li></ol><blockquote><p>时间 O(NLogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] numberOfPairs(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> []ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []&#123;<span class="hljs-number">0</span>,n&#125;;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[i+<span class="hljs-number">1</span>])&#123;<br>                i++;<br>                ans[<span class="hljs-number">0</span>]++;<br>                ans[<span class="hljs-number">1</span>]-=<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>哈希+枚举</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了54.00%的用户</p><p>内存消耗：40.3 MB, 在所有 Java 提交中击败了40.80%的用户</p><p>通过测试用例：128 &#x2F; 128</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] numberOfPairs(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        Map&lt;Integer,Boolean&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums)&#123;<br>            map.put(i,!map.getOrDefault(i,<span class="hljs-literal">true</span>));<br>            <span class="hljs-keyword">if</span>(map.get(i))&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;ans,n-ans*<span class="hljs-number">2</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 647</title>
    <link href="/posts/15898.html"/>
    <url>/posts/15898.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>找规律+中心扩展法：参考题解，非常巧妙的应用了回文串的规律，将回文串的长度分为奇偶两种情况，<strong>枚举每一个回文中心，并用两个指针向左右两边扩展，两个指针指向相同的时候，就扩展，否则就返回</strong></li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了84.78%的用户</p><p>通过测试用例：130 &#x2F; 130</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            count(s,i,i);<br>            count(s,i,i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">count</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))&#123;<br>            num++;<br>            start--;<br>            end++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>马拉车算法，还没吃透</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了75.45%的用户</p><p>通过测试用例：130 &#x2F; 130</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> n=s.length();<br>        StringBuffer t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;$#&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            t.append(s.charAt(i));<br>            t.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        n=t.length();<br>        t.append(<span class="hljs-string">&#x27;!&#x27;</span>);<br>        <span class="hljs-type">int</span> []f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> iMax=<span class="hljs-number">0</span>,rMax=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            f[i]=i&lt;=rMax?Math.min(rMax-i+<span class="hljs-number">1</span>,f[<span class="hljs-number">2</span>*iMax-i]):<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t.charAt(i+f[i])==t.charAt(i-f[i]))&#123;<br>                ++f[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i+f[i]-<span class="hljs-number">1</span>&gt;rMax)&#123;<br>                iMax=i;<br>                rMax=i+f[i]-<span class="hljs-number">1</span>;<br>            &#125;<br>            ans+=f[i]/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1124</title>
    <link href="/posts/14764.html"/>
    <url>/posts/14764.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a><a href="https://leetcode.cn/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a></h4><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：hours = <span class="hljs-comment">[9,9,6,0,6,6,9]</span><br>输出：3<br>解释：最长的表现良好时间段是 <span class="hljs-comment">[9,9,6]</span>。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：将原问题转化为和大于0的最小子数组的问题，通过前缀和求解。</li></ol><p>如果hours[i]&gt;8，则arr[i]为1，否则为-1，然后再用arr[i]表示前i个元素的和，要寻找i和j，使得在i&lt;j时，arr[i]-arr[j]&gt;0（也就意味着i到j之间的和大于0，也即问题的求解）</p><p>对于arr[i]，有两种情况</p><ul><li>arr[i]&gt;0，表示前i+1个元素的和是表现良好的时间段</li><li>arr[i]&lt;&#x3D;0，则需要找到一个j，满足j&lt;i，arr[i]-arr[j]&gt;0，对于arr[j]来说，存在两种情况<ul><li>j&lt;i时，不存在arr[i]-arr[j]&gt;0，</li><li>j&lt;i时，存在arr[i]-arr[j]&gt;0，那么此时也一定存在arr[i]-arr[j]&#x3D;1，也即arr[j]&#x3D;arr[i]-1，使用哈希表存储第一次出现的arr[j]即可</li></ul></li></ul><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了70.25%的用户</p><p>内存消耗：42.1 MB, 在所有 Java 提交中击败了44.50%的用户</p><p>通过测试用例：98 &#x2F; 98</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestWPI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] hours)</span> &#123;<br>        <span class="hljs-type">int</span> n=hours.length;<br>        <span class="hljs-type">int</span> [] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        arr[<span class="hljs-number">0</span>]=hours[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">8</span>?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            arr[i]=arr[i-<span class="hljs-number">1</span>]+(hours[i]&gt;<span class="hljs-number">8</span>?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                ans=Math.max(ans,i+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> tmp=map.getOrDefault(arr[i]-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(tmp!=-<span class="hljs-number">1</span>)&#123;<br>                    ans=Math.max(ans,i-tmp);<br>                &#125;<br>                map.putIfAbsent(arr[i],i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1234</title>
    <link href="/posts/43357.html"/>
    <url>/posts/43357.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a></h4><p>有一个只含有 <code>&#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39;</code> 四种字符，且长度为 <code>n</code> 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 <code>n/4</code> 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 <code>s</code>，请通过「替换一个子串」的方式，使原字符串 <code>s</code> 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 <strong>任何</strong> 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QWER&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：s 已经是平衡的了。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>暴力解法，超时了</p></li><li><p>滑动窗口，重要的是窗口左右移动的时机</p></li></ol><blockquote><p>执行用时：10 ms, 在所有 Java 提交中击败了22.95%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了43.44%的用户</p><p>通过测试用例：40 &#x2F; 40</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">balancedString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> []cnt=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        String t=<span class="hljs-string">&quot;QWER&quot;</span>;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            cnt[t.indexOf(s.charAt(i))]++;<br>        &#125;<br>        <span class="hljs-type">int</span> m=n/<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">0</span>]==m&amp;&amp;cnt[<span class="hljs-number">1</span>]==m&amp;&amp;cnt[<span class="hljs-number">2</span>]==m&amp;&amp;cnt[<span class="hljs-number">3</span>]==m)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            cnt[t.indexOf(s.charAt(j))]--;<br>            <span class="hljs-keyword">while</span>(i&lt;=j&amp;&amp;cnt[<span class="hljs-number">0</span>]&lt;=m&amp;&amp;cnt[<span class="hljs-number">1</span>]&lt;=m&amp;&amp;cnt[<span class="hljs-number">2</span>]&lt;=m&amp;&amp;cnt[<span class="hljs-number">3</span>]&lt;=m)&#123;<br>                ans=Math.min(ans,j-i+<span class="hljs-number">1</span>);<br>                cnt[t.indexOf(s.charAt(i++))]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU架构</title>
    <link href="/posts/27701.html"/>
    <url>/posts/27701.html</url>
    
    <content type="html"><![CDATA[<h2 id="主流CPU指令集"><a href="#主流CPU指令集" class="headerlink" title="主流CPU指令集"></a>主流CPU指令集</h2><table><thead><tr><th align="center">架构</th><th align="center">指令集位数</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">x86</td><td align="center">32</td><td align="center">Intel开发，CPU架构习惯以86结尾，所以之后被称之为x86</td></tr><tr><td align="center">AMD64</td><td align="center">64</td><td align="center">32位向64位演进时，AMD更早的开发除了兼容x86(32位)指令集的处理器</td></tr><tr><td align="center">x86_64</td><td align="center">64</td><td align="center">Intel为了迈向64位，设计了IA-64（不兼容x86），但反响不好，因此采用了AMD64，并在此基础进行扩充，改名为x86_64，两种差别不大（现在用的intel&#x2F;amd的桌面级CPU基本上都是x86_64）</td></tr><tr><td align="center">ARM</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ARM-V8</td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>x86是一种CISC的指令集</p><p>非x86，一般是RISC指令集</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 39</title>
    <link href="/posts/4003.html"/>
    <url>/posts/4003.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+深度优先搜索+递归</li></ol><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230213102600206.png" alt="image-20230213102600206" style="zoom: 33%;" /><p>图片来源：题解</p><p>使用一个数字，target做减法，不断减少直到target&lt;&#x3D;0，但这样做会出现重复路径，因此需要去重</p><p>去重方法为：同一层的节点，已经使用过的数字不在考虑，也即</p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230213102848235.png" alt="image-20230213102848235" style="zoom:33%;" /><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了75.79%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了82.05%的用户</p><p>通过测试用例：160 &#x2F; 160</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">int</span> len=candidates.length;<br><br>        ArrayDeque&lt;Integer&gt; path=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        dfs(candidates,<span class="hljs-number">0</span>,len,path,target,ans);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> [] candidates,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> len,ArrayDeque&lt;Integer&gt; path,<span class="hljs-type">int</span> target,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;<br>        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;len;i++)&#123;<br>            path.addLast(candidates[i]);<br>            dfs(candidates,i,len,path,target-candidates[i],ans);<br><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 剪枝之后</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">int</span> len=candidates.length;<br>        Arrays.sort(candidates);<br><br>        ArrayDeque&lt;Integer&gt; path=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        dfs(candidates,<span class="hljs-number">0</span>,len,path,target,ans);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> [] candidates,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> len,ArrayDeque&lt;Integer&gt; path,<span class="hljs-type">int</span> target,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(target-candidates[i]&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            path.addLast(candidates[i]);<br>            dfs(candidates,i,len,path,target-candidates[i],ans);<br><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>回溯：元素无重复的可重复选的组合问题。重点在于start的位置</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了75.99%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了98.76%的用户</p><p>通过测试用例：160 &#x2F; 160</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-constructor">ArrayList()</span>;<br>    List&lt;Integer&gt; <span class="hljs-built_in">list</span>=<span class="hljs-keyword">new</span> <span class="hljs-constructor">ArrayList()</span>;<br>    public List&lt;List&lt;Integer&gt;&gt; combination<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">candidates</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;<br>        back<span class="hljs-constructor">Track(<span class="hljs-params">candidates</span>,<span class="hljs-params">target</span>,0)</span>;<br>        return ans;<br>    &#125;<br>    public void back<span class="hljs-constructor">Track(<span class="hljs-params">int</span> []<span class="hljs-params">candidates</span>,<span class="hljs-params">int</span> <span class="hljs-params">target</span>,<span class="hljs-params">int</span> <span class="hljs-params">start</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">ArrayList(<span class="hljs-params">list</span>)</span>);<br>            return ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)return ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=start;i&lt;candidates.length;i++)&#123;<br>            <span class="hljs-built_in">list</span>.add(candidates<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>            back<span class="hljs-constructor">Track(<span class="hljs-params">candidates</span>,<span class="hljs-params">target</span>-<span class="hljs-params">candidates</span>[<span class="hljs-params">i</span>],<span class="hljs-params">i</span>)</span>;<br>            <span class="hljs-built_in">list</span>.remove(<span class="hljs-built_in">list</span>.size<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DragonOS 实时调度器相关API</title>
    <link href="/posts/56746.html"/>
    <url>/posts/56746.html</url>
    
    <content type="html"><![CDATA[<h1 id="实时进程调度器相关的api"><a href="#实时进程调度器相关的api" class="headerlink" title="实时进程调度器相关的api"></a>实时进程调度器相关的api</h1><p>&amp;emsp;&amp;emsp; RT（realtime scheduler），实时调度器。实时调度是为了完成实时处理任务而分配CPU的调度方法。</p><p>&amp;emsp;&amp;emsp;DragonOS的进程分为“实时进程”和“普通进程”两类；实时进程的优先级高于普通进程，如果当前的系统的执行队列中有“实时进程”，RT调度器会优先选择实时进程；如果队列中会有多个实时进程，调度器会选择优先级最高的实时进程来执行；</p><h2 id="1-RTQueue-介绍"><a href="#1-RTQueue-介绍" class="headerlink" title="1. RTQueue 介绍"></a>1. RTQueue 介绍</h2><p>&amp;emsp;&amp;emsp; RTQueue是用来存放state为running的实时进程的调度队列，每个CPU维护一个RTQueue，主要使用Vec作为主要存储结构来实现。</p><h3 id="1-1-主要函数"><a href="#1-1-主要函数" class="headerlink" title="1.1 主要函数"></a>1.1 主要函数</h3><ol><li><p><strong>enqueue():</strong> 将pcb入队列</p></li><li><p><strong>dequeue():</strong> 将pcb出队列</p></li></ol><h2 id="2-SchedulerRT-介绍"><a href="#2-SchedulerRT-介绍" class="headerlink" title="2. SchedulerRT 介绍"></a>2. SchedulerRT 介绍</h2><p>&amp;emsp;&amp;emsp; RT调度器类，主要实现了RT调度器类的初始化以及调度功能函数。</p><h3 id="2-1-主要函数"><a href="#2-1-主要函数" class="headerlink" title="2.1 主要函数"></a>2.1 主要函数</h3><ol><li><p><strong>pick_next_task_rt():</strong> 获取当前CPU中的第一个需要执行的RT pcb</p></li><li><p><strong>sched():</strong> 是对于Scheduler trait的sched()实现，是实时进程进行调度时的逻辑处理，该函数会返回接下来要执行的pcb，若没有符合要求的pcb，返回None</p></li><li><p><strong>enqueue():</strong> 同样是对于Scheduler trait的sched()实现，将一个pcb加入调度器的调度队列</p></li></ol><h3 id="2-2-内核调度策略"><a href="#2-2-内核调度策略" class="headerlink" title="2.2 内核调度策略"></a>2.2 内核调度策略</h3><p>目前在DragonOS中，主要的调度策略有SCHED_NORMAL 策略 | SCHED_FIFO 策略 | SCHED_RT 策略，具体的调度策略为：</p><ol><li><p><strong>SCHED_NORMAL 策略</strong>：SCHED_NORMAL 是“绝对公平调度策略”，该策略的进程使用CFS进行调度。</p></li><li><p><strong>SCHED_FIFO 策略</strong>：SCHED_FIFO是“实时进程调度策略”，这是一种先进先出的调度策略，该策略不涉及到CPU时间片机制，在没有更高优先级进程的前提下，只能等待其他进程主动释放CPU资源；在SCHED_FIFO策略中，被调度器调度运行的进程，其运行时长不受限制，可以运行任意长的时间。</p></li><li><p><strong>SCHED_RR 策略</strong>：SCHED_RR是“实时进程调度策略”，使用的是时间片轮转机制，对应进程的time_slice会在运行时减少，进程使用完CPU时间片后，会加入该CPU的与该进程优先级相同的执行队列中。同时，释放CPU资源，CPU的使用权会被分配给下一个执行的进程</p></li></ol><h2 id="3-Q-amp-A"><a href="#3-Q-amp-A" class="headerlink" title="3. Q&amp;A"></a>3. Q&amp;A</h2><ol><li><p>如何创建实时进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process_control_block</span> *<span class="hljs-title">pcb_name</span> =</span> kthread_run_rt(&amp;fn_name, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;test create rt pcb&quot;</span>);<br></code></pre></td></tr></table></figure><p>  其中kthread_run_rt，是创建内核实时线程的宏</p></li><li><p>pcb中涉及到实时进程的字段含义</p><ol><li><p><strong>policy：</strong>实时进程的策略，目前有：SCHED_FIFO与SCHED_RR</p></li><li><p><strong>priority:</strong> 实时进程的优先级，范围为0-99，数字越大，表示优先级越高</p></li><li><p><strong>rt_time_slice:</strong> 调度策略为 “RR” 的实时进程的时间片，默认为100，随着CPU运行而减少，在rt_time_slice为0时，将时间片赋初值并将该进程加入执行队列。</p></li></ol></li><li><p>如何实时进程存储队列</p><ul><li>目前是使用 Vec 来保存，因为具体实现的逻辑原因，目前的入队列和出队列都是对队尾的操作，因此会有如下现象：系统中有<strong>多个优先级相同的实时进程</strong>等待运行时，会出现<strong>饥饿现象</strong>，也即上一个因为时间片耗尽的进程会在下一个执行，造成同优先级等待的进程饥饿。</li></ul></li><li><p>TODO</p><ol><li><p>将存储实时进程的队列改为使用双向链表存储（或者其他办法解决上述的饥饿问题）</p></li><li><p>多核CPU的实时调度</p><ul><li>目前的实时调度是针对单核CPU的，需要实现多核CPU的实时调度</li></ul></li><li><p>RT进程带宽比</p><ul><li><p>由于实时任务的优先级高于普通任务，因而为了防止cpu消耗型的实时任务一直占用cpu引发其他任务”饥饿”的情况发生，linux内核采用了带宽限制手段来抑制实时任务的运行时间</p></li><li><p><strong>带宽限制：</strong>在任务调度中带宽限制就是指一定周期内一个队列上任务可运行的最大时间</p></li></ul></li><li><p>多个CPU之间实现<strong>负载均衡</strong></p><ul><li>最开始linux采用跟踪每个CPU的运行队列的负载情况来进行负载计算和决策</li><li>之后linux引入PELT <code>PELT, Per-entity load tracking </code>，通过跟踪每个调度实体的负载贡献来计算CPU负载，来进行调度决策</li></ul></li><li><p>更远：组调度</p><ul><li><strong>要解决的问题：</strong>A和B两个用户使用同一台机器，A用户16个进程，B用户2个进程，如果按照进程的个数来分配CPU资源，显然A用户会占据大量的CPU时间，这对于B用户是不公平的。组调度就可以解决这个问题，分别将A、B用户进程划分成组，并将两组的权重设置成占比50%即可。（调度时不再以进程为单位，而是以进程组作为调度实体）</li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>DragonOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>实时调度器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 148</title>
    <link href="/posts/64491.html"/>
    <url>/posts/64491.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h4><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/sort_list_1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>]<br>输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+链表：将链表存储在ArrayList中，使用库函数sort，然后在写入链表中，返回。自己没有写sort</li></ol><blockquote><p>执行用时：18 ms, 在所有 Java 提交中击败了14.19%的用户</p><p>内存消耗：52.4 MB, 在所有 Java 提交中击败了7.16%的用户</p><p>通过测试用例：30 &#x2F; 30</p><p>时间 O(NLogN)</p><p>空间O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        ListNode ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode res=ans;<br>        ListNode tmp=head;<br>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(head.val);<br>            head=head.next;<br>        &#125;<br>        list.sort(Comparator.naturalOrder());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>            ans.next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list.get(i));<br>            ans=ans.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>递归+归并排序：首先将链表找到链表的中间节点一分为二进行排序，将排序后的两个链表合并，参考《两个有序链表的合并》，此方法由于使用了递归，所以空间复杂度为O(logN)，尚未达到常数级</li></ol><blockquote><p>执行用时：11 ms, 在所有 Java 提交中击败了55.92%的用户</p><p>内存消耗：49.8 MB, 在所有 Java 提交中击败了48.05%的用户</p><p>通过测试用例：30 &#x2F; 30</p><p>时间 O(NLogN)</p><p>空间 O(logN)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sortList(head,<span class="hljs-literal">null</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head,ListNode tail)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(head.next==tail)&#123;<br>            head.next=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode low=head,fast=head;<br>        ListNode tmp=head;<br>        <span class="hljs-keyword">while</span>(fast!=tail)&#123;<br>            low=low.next;<br>            fast=fast.next;<br>            <span class="hljs-keyword">if</span>(fast!=tail)&#123;<br>                fast=fast.next;<br>            &#125;<br>        &#125;<br>        ListNode mid=low;<br>        ListNode left=sortList(tmp,mid);<br>        ListNode right=sortList(mid,tail);<br>        <span class="hljs-keyword">return</span> merge(left,right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode node1,ListNode node2)</span>&#123;<br>        ListNode ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode tmp=ans;<br>        <span class="hljs-keyword">while</span>(node1!=<span class="hljs-literal">null</span>&amp;&amp;node2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1.val&lt;=node2.val)&#123;<br>                ans.next=node1;<br>                node1=node1.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans.next=node2;<br>                node2=node2.next;<br>            &#125;<br>            ans=ans.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1!=<span class="hljs-literal">null</span>)&#123;<br>            ans.next=node1;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans.next=node2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>遍历，重度参考了官方题解</li></ol><blockquote><p>执行用时：15 ms, 在所有 Java 提交中击败了30.16%的用户</p><p>内存消耗：49.4 MB, 在所有 Java 提交中击败了64.19%的用户</p><p>通过测试用例：30 &#x2F; 30</p><p>时间 O(NLogN)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 归并排序</span><br>        <span class="hljs-comment">// 首先获取链表长度</span><br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        ListNode tmp=head;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">null</span>)&#123;<br>            tmp=tmp.next;<br>            length++;<br>        &#125;<br>        ListNode ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        <span class="hljs-comment">// 将链表分成slenth长的段，初始为1，合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> slen=<span class="hljs-number">1</span>;slen&lt;length;slen&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>            ListNode curr=ans.next,prev=ans;<br>            <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">// 需要排序的第一个元素</span><br>                ListNode head1=curr;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;slen&amp;&amp;curr.next!=<span class="hljs-literal">null</span>;i++)&#123;<br>                    curr=curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 需要排序的第二个元素</span><br>                ListNode head2=curr.next;<br>                curr.next=<span class="hljs-literal">null</span>;<br>                curr=head2;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;slen&amp;&amp;curr!=<span class="hljs-literal">null</span>&amp;&amp;curr.next!=<span class="hljs-literal">null</span>;i++)&#123;<br>                    curr=curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 保存后续未排序元素的头节点，并将排序的部分切分</span><br>                <span class="hljs-comment">// 这句话会导致超时</span><br>                <span class="hljs-comment">// ListNode next=new ListNode();</span><br>                ListNode next=<span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>                    next=curr.next;<br>                    curr.next=<span class="hljs-literal">null</span>;<br>                &#125;<br><br>                ListNode merged=merge(head1,head2);<br>                prev.next=merged;<br>                <span class="hljs-keyword">while</span>(prev.next!=<span class="hljs-literal">null</span>)&#123;<br>                    prev=prev.next;<br>                &#125;<br>                curr=next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.next;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode node1,ListNode node2)</span>&#123;<br>        ListNode ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode tmp=ans;<br>        <span class="hljs-keyword">while</span>(node1!=<span class="hljs-literal">null</span>&amp;&amp;node2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1.val&lt;=node2.val)&#123;<br>                ans.next=node1;<br>                node1=node1.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans.next=node2;<br>                node2=node2.next;<br>            &#125;<br>            ans=ans.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1!=<span class="hljs-literal">null</span>)&#123;<br>            ans.next=node1;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans.next=node2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1797</title>
    <link href="/posts/2315.html"/>
    <url>/posts/2315.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1797-设计一个验证系统"><a href="#1797-设计一个验证系统" class="headerlink" title="1797. 设计一个验证系统"></a><a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></h4><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code> 类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li></ul><p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/copy-of-pc68_q2.png" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：<br>[<span class="hljs-string">&quot;AuthenticationManager&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">6</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>]]<br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, null, null, null, <span class="hljs-number">0</span>]<br><br>解释：<br>AuthenticationManager authenticationManager = new AuthenticationManager(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 构造 AuthenticationManager ，设置 timeToLive = <span class="hljs-number">5</span> 秒。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">1</span> 时，没有验证码的 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> ，没有验证码被更新。<br>authenticationManager.generate(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">2</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的新验证码。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">6</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">6</span> 时，只有 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码未过期，所以返回 <span class="hljs-number">1</span> 。<br>authenticationManager.generate(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">7</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的新验证码。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，且 <span class="hljs-number">8</span> &gt;= <span class="hljs-number">7</span> ，所以时刻 <span class="hljs-number">8</span> 的renew 操作被忽略，没有验证码被更新。<br>authenticationManager.renew(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">10</span> 没有过期，所以 renew 操作会执行，该 token 将在时刻 <span class="hljs-number">15</span> 过期。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">15</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">15</span> 过期，tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，所有验证码均已过期，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>按部就班，主要就是看过期时间和当前时间的关系，没啥意思</li></ol><blockquote><p>执行用时：51 ms, 在所有 Java 提交中击败了68.23%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了85.88%的用户</p><p>通过测试用例：90 &#x2F; 90</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationManager</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> myTimeToLive;<br>    <span class="hljs-keyword">public</span> Map&lt;String,Integer&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AuthenticationManager</span><span class="hljs-params">(<span class="hljs-type">int</span> timeToLive)</span> &#123;<br>        myTimeToLive=timeToLive;<br>        map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">(String tokenId, <span class="hljs-type">int</span> currentTime)</span> &#123;<br>        map.put(tokenId,currentTime+myTimeToLive);<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renew</span><span class="hljs-params">(String tokenId, <span class="hljs-type">int</span> currentTime)</span> &#123;<br>        <span class="hljs-type">int</span> endTime=map.getOrDefault(tokenId,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(endTime&gt;currentTime)&#123;<br>            map.put(tokenId,currentTime+myTimeToLive);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUnexpiredTokens</span><span class="hljs-params">(<span class="hljs-type">int</span> currentTime)</span> &#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> value:map.values())&#123;<br>            <span class="hljs-keyword">if</span>(value&gt;currentTime)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your AuthenticationManager object will be instantiated and called as such:</span><br><span class="hljs-comment"> * AuthenticationManager obj = new AuthenticationManager(timeToLive);</span><br><span class="hljs-comment"> * obj.generate(tokenId,currentTime);</span><br><span class="hljs-comment"> * obj.renew(tokenId,currentTime);</span><br><span class="hljs-comment"> * int param_3 = obj.countUnexpiredTokens(currentTime);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 105</title>
    <link href="/posts/65064.html"/>
    <url>/posts/65064.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/tree.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: preorder = <span class="hljs-string">[3,9,20,15,7]</span>, inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>输出: <span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归，根据前序和中序的特性，前序数组的第一个元素一定为根节点，那么在中序数组中找到该节点，在中序数组中，该节点左侧的都是left上的节点，对应数量在前序数组的root节点之后，以此将其分开</li></ol><blockquote><p>执行用时：9 ms, 在所有 Java 提交中击败了8.56%的用户</p><p>内存消耗：86.4 MB, 在所有 Java 提交中击败了5.00%的用户</p><p>通过测试用例：203 &#x2F; 203</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">if</span>(preorder.length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        TreeNode root=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> tmp=preorder[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(inorder[i]!=tmp)&#123;<br>            i++;<br>        &#125;<br>        root.left=buildTree(Arrays.copyOfRange(preorder,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>),Arrays.copyOfRange(inorder,<span class="hljs-number">0</span>,i));<br>        root.right=buildTree(Arrays.copyOfRange(preorder,i+<span class="hljs-number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="hljs-number">1</span>,inorder.length));<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>递归但不使用 Arrays.copyOfRange，</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了42.85%的用户</p><p>内存消耗：40.9 MB, 在所有 Java 提交中击败了97.12%的用户</p><p>通过测试用例：203 &#x2F; 203</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder,<span class="hljs-type">int</span> preI,<span class="hljs-type">int</span> preJ, <span class="hljs-type">int</span>[] inorder,<span class="hljs-type">int</span> inI,<span class="hljs-type">int</span> inJ)</span>&#123;<br>        <span class="hljs-keyword">if</span>(preJ&lt;preI)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        TreeNode root=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preI]);<br>        <span class="hljs-type">int</span> i=inI;<br>        <span class="hljs-keyword">while</span>(inorder[i]!=preorder[preI])&#123;<br>            i++;<br>        &#125;<br>        root.left=myBuildTree(preorder,preI+<span class="hljs-number">1</span>,preI+i-inI,inorder,inI,i-<span class="hljs-number">1</span>);<br>        root.right=myBuildTree(preorder,preI+<span class="hljs-number">1</span>+i-inI,preJ,inorder,i+<span class="hljs-number">1</span>,inJ );<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1233</title>
    <link href="/posts/27420.html"/>
    <url>/posts/27420.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h4><p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的 <strong>子文件夹</strong> 。</p><p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。</p><ul><li>例如，<code>&quot;/leetcode&quot;</code> 和 <code>&quot;/leetcode/problems&quot;</code> 都是有效的路径，而空字符串和 <code>&quot;/&quot;</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/d/e&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>解释：<span class="hljs-string">&quot;/a/b/&quot;</span> 是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹，而 <span class="hljs-string">&quot;/c/d/e&quot;</span> 是 <span class="hljs-string">&quot;/c/d&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力求解</li></ol><blockquote><p>超时</p><p>时间 O(N*N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> &#123;<br>        List&lt;String&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;folder.length;i++)&#123;<br>            <span class="hljs-type">boolean</span> isChild=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;folder.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i!=j)&#123;<br>                    <span class="hljs-keyword">if</span>(isChildFolder(folder[i],folder[j]))&#123;<br>                        isChild=<span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!isChild)&#123;<br>                ans.add(folder[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 判断a是否是b的子文件夹</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isChildFolder</span><span class="hljs-params">(String a,String b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a.length()&lt;=b.length())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> a.startsWith(b)&amp;&amp;a.charAt(b.length())==<span class="hljs-string">&#x27;/&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>排序+规律，核心的规律为：在将字符串数组按照字典序排序之后，父子文件夹是相邻的，并且父在前，子在后。</li></ol><blockquote><p>执行用时：43 ms, 在所有 Java 提交中击败了82.84%的用户</p><p>内存消耗：51.5 MB, 在所有 Java 提交中击败了30.77%的用户</p><p>通过测试用例：32 &#x2F; 32</p><p>时间 O(NLogN)，排序算法复杂度</p><p>空间 O(N)，排序算法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> &#123;<br>        List&lt;String&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Arrays.sort(folder);<br>        String tmp=folder[<span class="hljs-number">0</span>];<br>        ans.add(tmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;folder.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!isChildFolder(folder[i],tmp))&#123;<br>                tmp=folder[i];<br>                ans.add(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 判断a是否是b的子文件夹</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isChildFolder</span><span class="hljs-params">(String a,String b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a.length()&lt;=b.length())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> a.startsWith(b)&amp;&amp;a.charAt(b.length())==<span class="hljs-string">&#x27;/&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 287</title>
    <link href="/posts/65374.html"/>
    <url>/posts/65374.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,3,4,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因题目要求不修改数组且空间复杂度为O(1)，因此有些思路不可用，如</p><ol><li><p>排序+遍历</p><ol><li><blockquote><p>时间 O(NlogN)、空间 O(N)</p></blockquote></li></ol></li><li><p>哈希表</p><ol><li>时间 O(N)、空间 O(N)</li></ol></li></ol><p>符合题目要求的思路</p><ol><li>两层for，暴力求解</li></ol><blockquote><p>超时</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><ol start="2"><li>参考题解，二进制法。核心思想：考虑数字的第 i 位，nums数组中的数字，第 i 位为1的数字个数为x；[1,n]中的数字，第 i 位为1的数字个数为y，x&gt;y是 &lt;&#x3D;&gt; 重复的数字第 i 位为1。</li></ol><blockquote><p>执行用时：48 ms, 在所有 Java 提交中击败了5.05%的用户</p><p>内存消耗：58.4 MB, 在所有 Java 提交中击败了84.90%的用户</p><p>通过测试用例：58 &#x2F; 58</p><p>时间 O(NlogN)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-comment">// 记录n的最大位数</span><br>        <span class="hljs-type">int</span> bitMax=<span class="hljs-number">31</span>;<br>        <span class="hljs-comment">// 找到n-1的有效位数</span><br>        <span class="hljs-keyword">while</span>((n-<span class="hljs-number">1</span>)&gt;&gt;bitMax==<span class="hljs-number">0</span>)&#123;<br>            bitMax--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> bit=<span class="hljs-number">0</span>;bit&lt;=bitMax;bit++)&#123;<br>            <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span>((nums[i]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit))!=<span class="hljs-number">0</span>)&#123;<br>                    x++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>&amp;&amp; (i&amp;(<span class="hljs-number">1</span>&lt;&lt;bit))!=<span class="hljs-number">0</span>)&#123;<br>                    y++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>                res|=<span class="hljs-number">1</span>&lt;&lt;bit;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>双指针，将数组问题转换为环形链表问题</li></ol><blockquote><p>如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，<br>其映射关系 n-&gt;f(n) 为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>4-&gt;2<br>同样的，我们从下标为 0 出发，根据<br>f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。<br>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;……</p></blockquote><blockquote><p>评论区大神：（<strong>这应该是142题的解法证明，关键在于理解在找到环以后，为什么fast和从0开始向前移动，会同时到达环形开始点</strong>） low &#x3D; fast 时，快慢指针相遇，low 走过的距离是初始点（0）到环状开始的点 （x） 加上 环状开始的点（x） 到相遇点（y） 这段距离，而fast走过的距离是 初始点（0）到环状开始的点（x），点（x） 到点（y），点（y）到点（x），点（x）到点（y）。又因为fast走过的距离是low的两倍，设0到x长度为a，x到y长度为b,则有2*（a+b） &#x3D; a+ b+ (y到x的距离) + b，则y到x的距离就等于0到x的距离。所以当新的两个指针 一个从0出发，一个从相遇点y出发时，他们走到的相同的值就是环状开始的点，即x点。</p><p>执行用时：4 ms, 在所有 Java 提交中击败了93.31%的用户</p><p>内存消耗：59 MB, 在所有 Java 提交中击败了29.98%的用户</p><p>通过测试用例：58 &#x2F; 58</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> slow=nums[<span class="hljs-number">0</span>],fast=nums[nums[<span class="hljs-number">0</span>]];<br>        <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>            slow=nums[slow];<br>            fast=nums[nums[fast]];<br>        &#125;<br>        <span class="hljs-type">int</span> pre1=<span class="hljs-number">0</span>,pre2=fast;<br>        <span class="hljs-keyword">while</span>(pre1!=pre2)&#123;<br>            pre1=nums[pre1];<br>            pre2=nums[pre2];<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 102</title>
    <link href="/posts/15465.html"/>
    <url>/posts/15465.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/tree1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用list按顺序存储节点，由于返回值 List&lt;List<Integer>&gt;，因此需要记录每层的节点数，获取一个节点，上层节点数减一，没添加一个节点，下层节点数加一；获取的节点值加入list，上层节点数为0时，将list加入结果队列并置空。</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了60.14%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了26.37%的用户</p><p>通过测试用例：34 &#x2F; 34</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 使用list存储子节点，从list头部访问一个节点时，将其子节点将入队尾</span><br>        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        List&lt;TreeNode&gt; tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 使用num存储当前层和下一层的节点数</span><br>        <span class="hljs-type">int</span> numUp=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> numLow=<span class="hljs-number">0</span>;<br>        tmp.add(root);<br>        List&lt;Integer&gt; value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">while</span>(!tmp.isEmpty())&#123;<br>            TreeNode node=tmp.get(<span class="hljs-number">0</span>);<br>            tmp.remove(<span class="hljs-number">0</span>);<br>            value.add(node.val);<br>            numUp--;<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                tmp.add(node.left);<br>                numLow++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                tmp.add(node.right);<br>                numLow++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(numUp==<span class="hljs-number">0</span>)&#123;<br>                res.add(value);<br>                value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>                numUp=numLow;<br>                numLow=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>根据官方题解，使用ArrayDeque试了一下，效果差不多</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了60.14%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了83.45%的用户</p><p>通过测试用例：34 &#x2F; 34</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 使用list存储子节点，从list头部访问一个节点时，将其子节点将入队尾</span><br>        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br><br>        <span class="hljs-comment">// 使用num存储当前层和下一层的节点数</span><br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>            <span class="hljs-type">int</span> n=queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span>queue.poll();<br>                value.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 49</title>
    <link href="/posts/16289.html"/>
    <url>/posts/16289.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+排序，首先将字符串按字母顺序排列，然后使用哈希表存储，添加原字符串到返回结果中</li></ol><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了80.00%的用户</p><p>内存消耗：44.7 MB, 在所有 Java 提交中击败了37.70%的用户</p><p>通过测试用例：118 &#x2F; 118</p><p>时间 O(NlogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        List&lt;List&lt;String&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Map&lt;String,List&lt;String&gt;&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.length;i++)&#123;<br>            <span class="hljs-comment">// 将字符串按字母顺序排列</span><br>            <span class="hljs-type">char</span>[] strToChar=strs[i].toCharArray();<br>            Arrays.sort(strToChar);<br>            String tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(strToChar);<br>            <span class="hljs-comment">// 使用哈希表存储，添加原字符串到返回结果中</span><br>            List&lt;String&gt; value=map.getOrDefault(tmp,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>            value.add(strs[i]);<br>            map.put(tmp,value);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(List&lt;String&gt; value:map.values())&#123;<br>            res.add(value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>评论区：在美版leetcode上看到大神的思路，用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。（这个用质数表示真的很骚啊！！!）</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1604</title>
    <link href="/posts/38940.html"/>
    <url>/posts/38940.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1604-警告一小时内使用相同员工卡大于等于三次的人"><a href="#1604-警告一小时内使用相同员工卡大于等于三次的人" class="headerlink" title="1604. 警告一小时内使用相同员工卡大于等于三次的人"></a><a href="https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/">1604. 警告一小时内使用相同员工卡大于等于三次的人</a></h4><p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 <strong>警告</strong> 。</p><p>给你字符串数组 <code>keyName</code> 和 <code>keyTime</code> ，其中 <code>[keyName[i], keyTime[i]]</code> 对应一个人的名字和他在 <strong>某一天</strong> 内使用员工卡的时间。</p><p>使用时间的格式是 <strong>24小时制</strong> ，形如 <strong>“HH:MM”</strong> ，比方说 <code>&quot;23:51&quot;</code> 和 <code>&quot;09:49&quot;</code> 。</p><p>请你返回去重后的收到系统警告的员工名字，将它们按 <strong>字典序****升序</strong> 排序后返回。</p><p>请注意 <code>&quot;10:00&quot;</code> - <code>&quot;11:00&quot;</code> 视为一个小时时间范围内，而 <code>&quot;23:51&quot;</code> - <code>&quot;00:10&quot;</code> 不被视为一小时内，因为系统记录的是某一天内的使用情况。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：keyName = [<span class="hljs-string">&quot;daniel&quot;</span>,<span class="hljs-string">&quot;daniel&quot;</span>,<span class="hljs-string">&quot;daniel&quot;</span>,<span class="hljs-string">&quot;luis&quot;</span>,<span class="hljs-string">&quot;luis&quot;</span>,<span class="hljs-string">&quot;luis&quot;</span>,<span class="hljs-string">&quot;luis&quot;</span>], keyTime = [<span class="hljs-string">&quot;10:00&quot;</span>,<span class="hljs-string">&quot;10:40&quot;</span>,<span class="hljs-string">&quot;11:00&quot;</span>,<span class="hljs-string">&quot;09:00&quot;</span>,<span class="hljs-string">&quot;11:00&quot;</span>,<span class="hljs-string">&quot;13:00&quot;</span>,<span class="hljs-string">&quot;15:00&quot;</span>]<br>输出：[<span class="hljs-string">&quot;daniel&quot;</span>]<br>解释：<span class="hljs-string">&quot;daniel&quot;</span> 在一小时内使用了 <span class="hljs-number">3</span> 次员工卡（<span class="hljs-string">&quot;10:00&quot;</span>，<span class="hljs-string">&quot;10:40&quot;</span>，<span class="hljs-string">&quot;11:00&quot;</span>）。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这个题题目示例给人的误导性很强，以为是时间是天然有序的，结果不然</p></blockquote><ol><li>哈希表+排序。按部就班，首先使用哈希表存储keyname和对应的set，然后遍历哈希表，找出一个小时内打卡次数&gt;&#x3D;3的人名，最后将人名按照字典序排序输出（这里的打卡时间是随机的，并非升序，因此需要排序后使用）</li></ol><blockquote><p>执行用时：65 ms, 在所有 Java 提交中击败了72.50%的用户</p><p>内存消耗：61.1 MB, 在所有 Java 提交中击败了67.50%的用户</p><p>通过测试用例：77 &#x2F; 77</p><p>时间 O(NlogN) 根据主要是排序时间</p><p>空间 O(N)，哈希表占用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">alertNames</span><span class="hljs-params">(String[] keyName, String[] keyTime)</span> &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        List&lt;String&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">int</span> n=keyName.length;<br>        <span class="hljs-comment">// 将数组使用哈希表存储</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            List&lt;String&gt; tmp=map.getOrDefault(keyName[i],<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>            tmp.add(keyTime[i]);<br>            map.put(keyName[i],tmp);<br>        &#125;<br>        <span class="hljs-comment">// 遍历哈希表，找出一个小时内打卡次数&gt;=3的人名</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String,List&lt;String&gt;&gt; keyEntry:map.entrySet())&#123;<br>            String key=keyEntry.getKey();<br>            List&lt;String&gt; value=keyEntry.getValue();<br>            <span class="hljs-comment">// value 需要经过排序</span><br>            Collections.sort(value);<br>            <span class="hljs-keyword">if</span>(isMore3(value))&#123;<br>                res.add(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 对结果进行字典序排序</span><br>        Collections.sort(res);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMore3</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.size()&lt;<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;list.size()-<span class="hljs-number">2</span>;k++)&#123;<br>            String l=list.get(k);<br>            String r=list.get(k+<span class="hljs-number">2</span>);<br>            String []lArray=l.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            String []rArray=r.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-type">int</span> i=Integer.parseInt(lArray[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> j=Integer.parseInt(rArray[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">if</span>(i==j)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j-i==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> ir=Integer.parseInt(lArray[<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> jr=Integer.parseInt(rArray[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span>(jr&lt;=ir)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在进行时间的比较时，可以将时间换算为分钟，这样可以减小比较逻辑，对于跨天问题天然有优势</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 739</title>
    <link href="/posts/2760.html"/>
    <url>/posts/2760.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h4><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]<br>输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力求解，两层for，超时</li></ol><blockquote><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-comment">// 两层for，向后遍历</span><br>        <span class="hljs-type">int</span> n=temperatures.length;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(temperatures[j]&gt;temperatures[i])&#123;<br>                    res[i]=j-i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>找规律，根据题意，从后向前推会比较方便，分为几种情况，用t[i]表示第i天的气温<ul><li>t[i]&lt;t[i+1]<ul><li>res[i]为1</li></ul></li><li>t[i]&gt;&#x3D;t[i+1]<ul><li>if t[i+1]&#x3D;&#x3D;0，那么t[i]&#x3D;0</li><li>否则比较t[i]与t[i+res[i+1]]的大小</li></ul></li></ul></li></ol><p>将+1抽象为+j，那么有循环寻找下一个大值</p><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了99.06%的用户</p><p>内存消耗：51.4 MB, 在所有 Java 提交中击败了96.45%的用户</p><p>通过测试用例：48 &#x2F; 48</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> n=temperatures.length;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n];<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n-<span class="hljs-number">1</span>-i;j+=res[i+j])&#123;<br>                <span class="hljs-keyword">if</span>(temperatures[i]&lt;temperatures[i+j])&#123;<br>                    res[i]=j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[i+j]==<span class="hljs-number">0</span>)&#123;<br>                    res[i]=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2331</title>
    <link href="/posts/11980.html"/>
    <url>/posts/11980.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2331-计算布尔二叉树的值"><a href="#2331-计算布尔二叉树的值" class="headerlink" title="2331. 计算布尔二叉树的值"></a><a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree/">2331. 计算布尔二叉树的值</a></h4><p>给你一棵 <strong>完整二叉树</strong> 的根，这棵树有以下特征：</p><ul><li><strong>叶子节点</strong> 要么值为 <code>0</code> 要么值为 <code>1</code> ，其中 <code>0</code> 表示 <code>False</code> ，<code>1</code> 表示 <code>True</code> 。</li><li><strong>非叶子节点</strong> 要么值为 <code>2</code> 要么值为 <code>3</code> ，其中 <code>2</code> 表示逻辑或 <code>OR</code> ，<code>3</code> 表示逻辑与 <code>AND</code> 。</li></ul><p><strong>计算</strong> 一个节点的值方式如下：</p><ul><li>如果节点是个叶子节点，那么节点的 <strong>值</strong> 为它本身，即 <code>True</code> 或者 <code>False</code> 。</li><li>否则，<strong>计算</strong> 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong>运算</strong> 。</li></ul><p>返回根节点 <code>root</code> 的布尔运算值。</p><p><strong>完整二叉树</strong> 是每个节点有 <code>0</code> 个或者 <code>2</code> 个孩子的二叉树。</p><p><strong>叶子节点</strong> 是没有孩子的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/example1drawio1.png" alt="img"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：上图展示了计算过程。<br>AND 与运算节点的值为 <span class="hljs-literal">False</span> AND <span class="hljs-literal">True</span> = <span class="hljs-literal">False</span> 。<br>OR 运算节点的值为 <span class="hljs-literal">True</span> OR <span class="hljs-literal">False</span> = <span class="hljs-literal">True</span> 。<br>根节点的值为 <span class="hljs-literal">True</span> ，所以我们返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归，简单题我重拳出击</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了70.42%的用户</p><p>通过测试用例：75 &#x2F; 75</p><p>时间 O(N)</p><p>空间 O(N)，到不了N，取决于二叉树层数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">evaluateTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root.val&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> root.val==<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> root.val==<span class="hljs-number">2</span>?evaluateTree(root.left)||evaluateTree(root.right):evaluateTree(root.left)&amp;&amp;evaluateTree(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 538</title>
    <link href="/posts/2728.html"/>
    <url>/posts/2728.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/tree.png" alt="img"></strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br>输出：[<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">21</span>,<span class="hljs-number">36</span>,<span class="hljs-number">35</span>,<span class="hljs-number">26</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">33</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这个题代码写起来简单，但是想了半天才想明白这个反向的中序遍历该怎么用，以及num的累计值的使用方式</p></blockquote><ol><li>中序遍历，递归，不难发现，题目要求结果的二叉树，如果按照中序遍历，返回的结果中，节点的val是严格递减的，因此采用中序遍历的方法，依次将val累加到节点中</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了28.56%的用户</p><p>通过测试用例：215 &#x2F; 215</p><p>时间 O(N)，二叉树节点数</p><p>空间 O(N)，二叉搜索树的深度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        root.right=convertBST(root.right);<br>        root.val+= num;<br>        num=root.val;<br>        root.left=convertBST(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 114</title>
    <link href="/posts/44776.html"/>
    <url>/posts/44776.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/flaten.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.6 MB, 在所有 Java 提交中击败了99.52%的用户</p><p>通过测试用例：225 &#x2F; 225</p><p>时间 O(N)</p><p>空间 O(N) 树的深度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        root=getDeep(root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getDeep</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <br>        TreeNode res=root,tmp=root.right;<br>        <span class="hljs-comment">// 将树的左子树展开后赋给右子树</span><br>        root.right=getDeep(root.left);<br>        <span class="hljs-comment">// 左子树置空</span><br>        root.left=<span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 将右子树遍历到叶子节点</span><br>        <span class="hljs-keyword">while</span>(root.right!=<span class="hljs-literal">null</span>)&#123;<br>            root=root.right;<br>        &#125;<br>        <span class="hljs-comment">// 将原来的右子树展开</span><br>        root.right=getDeep(tmp);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 238</title>
    <link href="/posts/51993.html"/>
    <url>/posts/51993.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请<strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">24,12,8,6</span>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用除法，但空间不额外申请空间。使用变量保存当前的前缀积与后缀积，向后遍历，前缀积使用乘法扩大，后缀积使用除法缩小。如果遇到当前元素为0，需要重新计算后缀积。</li></ol><blockquote><p>时间 O(N*N)，为0的时候特殊情况，会导致时间复杂度到平方级</p><p>空间 O(1)</p><p>超时</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n];<br>        <span class="hljs-comment">// 获取整个数组的乘积</span><br>        <span class="hljs-type">int</span> left_mut=<span class="hljs-number">1</span>,right_mut=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 第一个元素特殊处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            right_mut*=nums[i];<br>        &#125;<br>        res[<span class="hljs-number">0</span>]=left_mut*right_mut;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            left_mut*=nums[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 非0时，后缀积除元素</span><br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>                right_mut/=nums[i];<br>            &#125;<br>            <span class="hljs-comment">// 0时，需要重新计算后缀积</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                right_mut=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i=<span class="hljs-number">1</span>;k&lt;n;k++)&#123;<br>                    right_mut*=nums[k];<br>                &#125;<br>            &#125;<br>            res[i]=left_mut*right_mut;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>辅助数组，使用两个数组分别保存前缀乘积和后缀乘积，然后某个数字的左右相乘。这里辅助数组的意义是left_mut[i]表示包含i的前缀积，如果表示不包含i的前缀积，那么代码量会更少。</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了28.31%的用户</p><p>内存消耗：49.4 MB, 在所有 Java 提交中击败了70.80%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(N)</p><p>空间 O(N) 使用了辅助数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-comment">// 使用两个数组分别保存前缀和后缀的乘积</span><br>        <span class="hljs-type">int</span> []left_mut=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> []right_mut=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">// 前缀积</span><br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)left_mut[i]=nums[i];<br>            <span class="hljs-keyword">else</span>&#123;<br>                left_mut[i]=left_mut[i-<span class="hljs-number">1</span>]*nums[i];<br>            &#125;<br>            <span class="hljs-comment">// 后缀积</span><br>            <span class="hljs-type">int</span> j=n-<span class="hljs-number">1</span>-i;<br>            <span class="hljs-keyword">if</span>(j==n-<span class="hljs-number">1</span>)right_mut[j]=nums[j];<br>            <span class="hljs-keyword">else</span>&#123;<br>                right_mut[j]=right_mut[j+<span class="hljs-number">1</span>]*nums[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)res[i]=right_mut[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==n-<span class="hljs-number">1</span>)res[i]=left_mut[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span>&#123;<br>                res[i]=left_mut[i-<span class="hljs-number">1</span>]*right_mut[i+<span class="hljs-number">1</span>];<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用返回数组代替后缀积，暂用返回数组暂时存储后缀积</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：49.2 MB, 在所有 Java 提交中击败了89.30%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(N)</p><p>空间 O(1)，因为返回数组不算空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-comment">// 是返回数组，也是后缀积数组</span><br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(i==n-<span class="hljs-number">1</span>)res[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 后缀积不计算当前元素</span><br>                res[i]=res[i+<span class="hljs-number">1</span>]*nums[i+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> left_mut=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算res</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res[i]=left_mut*res[i];<br>            left_mut*=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 48</title>
    <link href="/posts/65376.html"/>
    <url>/posts/65376.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用辅助矩阵：空间O(N)</li><li>原地旋转：找交换位置的规律，矩阵位置是对称的，因此每次交换的位置是有规律的，以最外圈的n个元素为例，前n-1个元素都会交换到对应的位置。将n-1个元素交换完，最外层也就结束了，接下来进入下一层交换元素。</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40 MB, 在所有 Java 提交中击败了93.91%的用户</p><p>通过测试用例：21 &#x2F; 21</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> len=matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// n表示不重复的圈数</span><br>        <span class="hljs-type">int</span> n=len/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// i 表示层数-1</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>            <span class="hljs-comment">// 矩阵中每次交换的元素的横纵坐标</span><br>            <span class="hljs-type">int</span> rui=<span class="hljs-number">0</span>+i,ruj=len-<span class="hljs-number">1</span>-i,rli=len-<span class="hljs-number">1</span>-i,rlj=len-<span class="hljs-number">1</span>-i,lli=len-<span class="hljs-number">1</span>-i,llj=<span class="hljs-number">0</span>+i,lui=<span class="hljs-number">0</span>+i,luj=<span class="hljs-number">0</span>+i;<br>            <span class="hljs-comment">// j 为单边的第几个元素</span><br>            <span class="hljs-type">int</span> j=i;<br>            <span class="hljs-comment">// 小于当前圈的边长 len/(lu+1)</span><br>            <span class="hljs-keyword">while</span>(j&lt;len-<span class="hljs-number">1</span>-i)&#123;<br>                <span class="hljs-comment">// 交换元素</span><br>                <span class="hljs-type">int</span> tmp=matrix[lui][luj];<br>                matrix[lui][luj]=matrix[lli][llj];<br>                matrix[lli][llj]=matrix[rli][rlj];<br>                matrix[rli][rlj]=matrix[rui][ruj];<br>                matrix[rui][ruj]=tmp;<br>                <span class="hljs-comment">// 向后移动，移动j</span><br>                luj+=<span class="hljs-number">1</span>;<br>                rui+=<span class="hljs-number">1</span>;<br>                rlj-=<span class="hljs-number">1</span>;<br>                lli-=<span class="hljs-number">1</span>;<br>                j++;<br>            &#125;<br>            i++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1798</title>
    <link href="/posts/3403.html"/>
    <url>/posts/3403.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1798-你能构造出连续值的最大数目"><a href="#1798-你能构造出连续值的最大数目" class="headerlink" title="1798. 你能构造出连续值的最大数目"></a><a href="https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/">1798. 你能构造出连续值的最大数目</a></h4><p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的 <code>n</code> 个硬币。第 <code>i</code> 个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 <code>x</code> ，那么称，你可以 <strong>构造</strong> 出 <code>x</code> 。</p><p>请返回从 <code>0</code> 开始（<strong>包括</strong> <code>0</code> ），你最多能 <strong>构造</strong> 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：coins = <span class="hljs-comment">[1,3]</span><br>输出：2<br>解释：你可以得到以下这些值：<br>- 0：什么都不取 <span class="hljs-comment">[]</span><br>- 1：取 <span class="hljs-comment">[1]</span><br>从 0 开始，你可以构造出 2 个连续整数。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>贪心，排序后，假设当前的表述范围为[0,n]，数组尾部每多一个数字v，其表示的范围为[0,n]&amp;[0+v,n+v]，那么需要考虑n与v的大小关系，如果v&lt;&#x3D;n+1，则两个范围可以连续上，否则返回结果（看了评论的想法）</li></ol><blockquote><p>执行用时：17 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：48.7 MB, 在所有 Java 提交中击败了92.31%的用户</p><p>通过测试用例：72 &#x2F; 72</p><p>时间 O(n*logn)，主要在排序的时间开销</p><p>空间 O(logn)，排序需要的栈空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaximumConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins)</span> &#123;<br>        Arrays.sort(coins);<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:coins)&#123;<br>            <span class="hljs-comment">// +1的目的是刚好i作为reshb的值</span><br>            <span class="hljs-keyword">if</span>(i&lt;=res+<span class="hljs-number">1</span>)&#123;<br>                res=res+i;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2325</title>
    <link href="/posts/32204.html"/>
    <url>/posts/32204.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2325-解密消息"><a href="#2325-解密消息" class="headerlink" title="2325. 解密消息"></a><a href="https://leetcode.cn/problems/decode-the-message/">2325. 解密消息</a></h4><p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p><ol><li>使用 <code>key</code> 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 <strong>顺序</strong> 。</li><li>将替换表与普通英文字母表对齐，形成对照表。</li><li>按照对照表 <strong>替换</strong> <code>message</code> 中的每个字母。</li><li>空格 <code>&#39; &#39;</code> 保持不变。</li></ol><ul><li>例如，<code>key = &quot;***hap***p***y*** ***bo***y&quot;</code>（实际的加密密钥会包含字母表中每个字母 <strong>至少一次</strong>），据此，可以得到部分对照表（<code>&#39;h&#39; -&gt; &#39;a&#39;</code>、<code>&#39;a&#39; -&gt; &#39;b&#39;</code>、<code>&#39;p&#39; -&gt; &#39;c&#39;</code>、<code>&#39;y&#39; -&gt; &#39;d&#39;</code>、<code>&#39;b&#39; -&gt; &#39;e&#39;</code>、<code>&#39;o&#39; -&gt; &#39;f&#39;</code>）。</li></ul><p>返回解密后的消息。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/ex1new4.jpg" alt="img"></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：key = <span class="hljs-comment">&quot;the quick brown fox jumps over the lazy dog&quot;</span>, message = <span class="hljs-comment">&quot;vkbs bs t suepuv&quot;</span><br>输出：<span class="hljs-comment">&quot;this is a secret&quot;</span><br>解释：对照表如上图所示。<br>提取 <span class="hljs-comment">&quot;the quick brown fox jumps over the lazy dog&quot;</span> 中每个字母的首次出现可以得到替换表。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表</li></ol><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了50.73%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了62.04%的用户</p><p>通过测试用例：69 &#x2F; 69</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeMessage</span><span class="hljs-params">(String key, String message)</span> &#123;<br>        <span class="hljs-comment">// 使用HashMap存储密码的对应值</span><br>        Map&lt;Character,Character&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;key.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=key.charAt(i);<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!map.containsKey(c))&#123;<br>                map.put(c,(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span>+num));<br>                num++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 遍历message翻译</span><br>        <span class="hljs-type">char</span>[] res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[message.length()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;message.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=message.charAt(i);<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                res[i]=<span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res[i]=map.get(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用数组代替哈希表，<em>对于以字母作为索引的操作，能用定长数组就不要用哈希，因为映射本身需要资源，而且无论分配空间还是寻址，堆区都不如栈区</em></li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了77.37%的用户</p><p>内存消耗：40.2 MB, 在所有 Java 提交中击败了95.62%的用户</p><p>通过测试用例：69 &#x2F; 69</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeMessage</span><span class="hljs-params">(String key, String message)</span> &#123;<br>        <span class="hljs-comment">// 使用数组存储字典值</span><br>        <span class="hljs-type">char</span>[] map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历key，存储密码值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;key.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=key.charAt(i);<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">if</span>(!Character.isLowerCase(map[c-<span class="hljs-string">&#x27;a&#x27;</span>]))&#123;<br>                map[c-<span class="hljs-string">&#x27;a&#x27;</span>]=(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span>+num);<br>                num++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 翻译</span><br>        <span class="hljs-type">char</span>[] res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[message.length()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;message.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=message.charAt(i);<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                res[i]=<span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res[i]=map[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode  1669</title>
    <link href="/posts/52549.html"/>
    <url>/posts/52549.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1669-合并两个链表"><a href="#1669-合并两个链表" class="headerlink" title="1669. 合并两个链表"></a><a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></h4><p>给你两个链表 <code>list1</code> 和 <code>list2</code> ，它们包含的元素分别为 <code>n</code> 个和 <code>m</code> 个。</p><p>请你将 <code>list1</code> 中下标从 <code>a</code> 到 <code>b</code> 的全部节点都删除，并将<code>list2</code> 接在被删除节点的位置。</p><p>下图中蓝色边和节点展示了操作后的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/fig1.png" alt="img"></p><p>请你返回结果链表的头指针。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/merge_linked_list_ex1.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：list1 = [<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>, list2 = [<span class="hljs-number">1000000</span>,<span class="hljs-number">1000001</span>,<span class="hljs-number">1000002</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2,1000000</span>,<span class="hljs-number">1000001</span>,<span class="hljs-number">1000002,5</span>]<br>解释：我们删除 list1 中下标为 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，按流程办事</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：45.1 MB, 在所有 Java 提交中击败了15.14%的用户</p><p>通过测试用例：61 &#x2F; 61</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeInBetween</span><span class="hljs-params">(ListNode list1, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ListNode list2)</span> &#123;<br>        ListNode res=list1;<br>        <span class="hljs-comment">// 找到a节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a-<span class="hljs-number">1</span>;i++)&#123;<br>            list1=list1.next;<br>        &#125;<br>        <span class="hljs-comment">// 将a以后的暂存在tmp</span><br>        ListNode tmp=list1.next;<br>        <span class="hljs-comment">// 将list2的拼接上</span><br>        list1.next=list2;<br>        <span class="hljs-comment">// 访问到list2的末尾</span><br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">null</span>&amp;&amp;list1.next!=<span class="hljs-literal">null</span>)&#123;<br>            list1=list1.next;<br>        &#125;<br>        <span class="hljs-comment">// 移除a到b的中间元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;b-a;i++)&#123;<br>            tmp=tmp.next;<br>        &#125;<br>        list1.next=tmp.next;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2315</title>
    <link href="/posts/36300.html"/>
    <url>/posts/36300.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2315-统计星号"><a href="#2315-统计星号" class="headerlink" title="2315. 统计星号"></a><a href="https://leetcode.cn/problems/count-asterisks/">2315. 统计星号</a></h4><p>给你一个字符串 <code>s</code> ，每 <strong>两个</strong> 连续竖线 <code>&#39;|&#39;</code> 为 <strong>一对</strong> 。换言之，第一个和第二个 <code>&#39;|&#39;</code> 为一对，第三个和第四个 <code>&#39;|&#39;</code> 为一对，以此类推。</p><p>请你返回 <strong>不在</strong> 竖线对之间，<code>s</code> 中 <code>&#39;*&#39;</code> 的数目。</p><p><strong>注意</strong>，每个竖线 <code>&#39;|&#39;</code> 都会 <strong>恰好</strong> 属于一个对。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;l|*e*et|c**o|*de|&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：不在竖线对之间的字符加粗加斜体后，得到字符串：<span class="hljs-string">&quot;l|*e*et|c**o|*de|&quot;</span> 。<br>第一和第二条竖线 &#x27;|&#x27; 之间的字符不计入答案。<br>同时，第三条和第四条竖线 &#x27;|&#x27; 之间的字符也不计入答案。<br>不在竖线对之间总共有 <span class="hljs-number">2</span> 个星号，所以我们返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>遍历模拟：使用一个bool位作为是否为竖线中间的标记，如果不在竖线中间并且为*时，进行统计，如果遇到|，则将标记位取反</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了53.58%的用户</p><p>通过测试用例：69 &#x2F; 69</p><p>时间 O(n)</p><p>空间O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAsterisks</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-type">boolean</span> isEven=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(i);<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;*&#x27;</span>&amp;&amp;isEven)&#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;|&#x27;</span>)&#123;<br>                isEven=!isEven;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1664</title>
    <link href="/posts/14367.html"/>
    <url>/posts/14367.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1664-生成平衡数组的方案数"><a href="#1664-生成平衡数组的方案数" class="headerlink" title="1664. 生成平衡数组的方案数"></a><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/">1664. 生成平衡数组的方案数</a></h4><p>给你一个整数数组 <code>nums</code> 。你需要选择 <strong>恰好</strong> 一个下标（下标从 <strong>0</strong> 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p><p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p><ul><li>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。</li><li>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。</li><li>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。</li></ul><p>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 <strong>平衡数组</strong> 。</p><p>请你返回删除操作后，剩下的数组 <code>nums</code> 是 <strong>平衡数组</strong> 的 <strong>方案数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,1,6,4]<br>输出：1<br>解释：<br>删除下标<span class="hljs-number"> 0 </span>：[1,6,4] -&gt; 偶数元素下标为：1 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 5 </span>。奇数元素下标为：6 。不平衡。<br>删除下标<span class="hljs-number"> 1 </span>：[2,6,4] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 6 </span>。奇数元素下标为：6 。平衡。<br>删除下标<span class="hljs-number"> 2 </span>：[2,1,4] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 6 </span>。奇数元素下标为：1 。不平衡。<br>删除下标<span class="hljs-number"> 3 </span>：[2,1,6] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 8 </span>。奇数元素下标为：1 。不平衡。<br>只有一种让剩余数组成为平衡数组的方案。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>奇偶前缀和：四个变量模拟计算结果，从后往前依次移除元素，因为题目设定每次只移除一个元素，因此在从后向前移动的过程中，right元素的奇偶性是变换的</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了85.71%的用户</p><p>内存消耗：51.9 MB, 在所有 Java 提交中击败了21.80%的用户</p><p>通过测试用例：105 &#x2F; 105</p><p>时间 O(n)</p><p>空间 O(1)</p><p>竟然和官方题解是一样的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">waysToMakeFair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 分别新建变量表示奇数和与偶数和，并将其分为左右两部分表示</span><br>        <span class="hljs-type">int</span> odd_sum_left=<span class="hljs-number">0</span>,odd_sum_right=<span class="hljs-number">0</span>,even_sum_left=<span class="hljs-number">0</span>,even_sum_right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>((i&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>) odd_sum_left+=nums[i];<br>            <span class="hljs-keyword">else</span> even_sum_left+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>((i&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)&#123;<br>                odd_sum_left-=nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                even_sum_left-=nums[i];<br>            &#125;<br>            <span class="hljs-comment">// 将两个right交换相加到left中</span><br>            <span class="hljs-keyword">if</span>(odd_sum_left+even_sum_right==even_sum_left+odd_sum_right)&#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>((i&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)&#123;<br>                odd_sum_right+=nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                even_sum_right+=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2309</title>
    <link href="/posts/6349.html"/>
    <url>/posts/6349.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2309-兼具大小写的最好英文字母"><a href="#2309-兼具大小写的最好英文字母" class="headerlink" title="2309. 兼具大小写的最好英文字母"></a><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/">2309. 兼具大小写的最好英文字母</a></h4><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p><p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p><p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> <strong>更好</strong> 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 <strong>后</strong> 出现。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;lEeTcOdE&quot;</span><br>输出：<span class="hljs-string">&quot;E&quot;</span><br>解释：<br>字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>通过数组存储状态，遍历访问数组，获取状态，并存取最大值</li></ol><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了36.94%的用户</p><p>内存消耗：40.1 MB, 在所有 Java 提交中击败了75.37%的用户</p><p>通过测试用例：113 &#x2F; 113</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">greatestLetter</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> max=-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 数组值为1，表示有小写字母；数组值为2，表示有大写字母</span><br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(i);<br>            <span class="hljs-keyword">if</span>(Character.isUpperCase(c))&#123;<br>                <span class="hljs-keyword">if</span>(tmp[c-<span class="hljs-string">&#x27;A&#x27;</span>]==<span class="hljs-number">1</span>)&#123;<br>                    max=Math.max(max,c-<span class="hljs-string">&#x27;A&#x27;</span>);<br>                &#125;<br>                tmp[c-<span class="hljs-string">&#x27;A&#x27;</span>]=<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Character.isLowerCase(c))&#123;<br>                <span class="hljs-keyword">if</span>(tmp[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">2</span>)&#123;<br>                    max=Math.max(max,c-<span class="hljs-string">&#x27;a&#x27;</span>);<br>                &#125;<br>                tmp[c-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max==-<span class="hljs-number">1</span>?<span class="hljs-string">&quot;&quot;</span>:String.valueOf((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span>+max));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1663</title>
    <link href="/posts/64094.html"/>
    <url>/posts/64094.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1663-具有给定数值的最小字符串"><a href="#1663-具有给定数值的最小字符串" class="headerlink" title="1663. 具有给定数值的最小字符串"></a><a href="https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/">1663. 具有给定数值的最小字符串</a></h4><p><strong>小写字符</strong> 的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。</p><p>字符串由若干小写字符组成，<strong>字符串的数值</strong> 为各字符的数值之和。例如，字符串 <code>&quot;abe&quot;</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。</p><p>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。</p><p>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p><ul><li><code>x</code> 是 <code>y</code> 的一个前缀；</li><li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3, k = 27<br>输出：&quot;aay&quot;<br>解释：字符串的数值为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 25 </span>= 27，它是数值满足要求且长度等于<span class="hljs-number"> 3 </span>字典序最小的字符串。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代模拟，根据题目描述，要找的字符串是<strong>严格非递减</strong>的，我们默认字符串都是a组成；从后向前模拟，根据剩余值大小进行修改</li></ol><blockquote><p>执行用时：9 ms, 在所有 Java 提交中击败了86.29%的用户</p><p>内存消耗：41.5 MB, 在所有 Java 提交中击败了74.19%的用户</p><p>通过测试用例：94 &#x2F; 94</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSmallestString</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span> []res_char=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>        <span class="hljs-comment">// 全部赋初值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res_char[i]=<span class="hljs-string">&#x27;a&#x27;</span>;<br>        &#125;<br>        k-=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">25</span>)&#123;<br>                res_char[i]=<span class="hljs-string">&#x27;z&#x27;</span>;<br>                k-=<span class="hljs-number">25</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">25</span>)&#123;<br>                res_char[i]+=k;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(res_char);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1828</title>
    <link href="/posts/15996.html"/>
    <url>/posts/15996.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1828-统计一个圆中点的数目"><a href="#1828-统计一个圆中点的数目" class="headerlink" title="1828. 统计一个圆中点的数目"></a><a href="https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/">1828. 统计一个圆中点的数目</a></h4><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p><p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在 <code>(xj, yj)</code> 且半径为 <code>rj</code> 的圆。</p><p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/chrome_2021-03-25_22-34-16.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[3,3]</span>,<span class="hljs-comment">[5,3]</span>,<span class="hljs-comment">[2,2]</span>]</span>, queries = <span class="hljs-comment">[<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[4,3,1]</span>,<span class="hljs-comment">[1,1,2]</span>]</span><br>输出：<span class="hljs-comment">[3,2,2]</span><br>解释：所有的点和圆如上图所示。<br>queries<span class="hljs-comment">[0]</span> 是绿色的圆，queries<span class="hljs-comment">[1]</span> 是红色的圆，queries<span class="hljs-comment">[2]</span> 是蓝色的圆。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>两层遍历，枚举</li></ol><blockquote><p>执行用时：35 ms, 在所有 Java 提交中击败了51.59%的用户</p><p>内存消耗：42.2 MB, 在所有 Java 提交中击败了37.70%的用户</p><p>通过测试用例：66 &#x2F; 66</p><p>时间 O(n*m)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countPoints(<span class="hljs-type">int</span>[][] points, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;queries.length;i++)&#123;<br>            <span class="hljs-type">int</span> []query=queries[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> []point:points)&#123;<br>                <span class="hljs-type">int</span> query_x=query[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> query_y=query[<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> r=query[<span class="hljs-number">2</span>];<br>                <span class="hljs-type">int</span> point_x=point[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> point_y=point[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 判断是否在圆内，点到圆心距离是否小于等于半径 x*x+y*y&lt;=r*r</span><br>                <span class="hljs-keyword">if</span>((Math.pow((query_x-point_x),<span class="hljs-number">2</span>)+Math.pow((query_y-point_y),<span class="hljs-number">2</span>))&lt;=(r*r))&#123;<br>                    res[i]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2303</title>
    <link href="/posts/8013.html"/>
    <url>/posts/8013.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2303-计算应缴税款总额"><a href="#2303-计算应缴税款总额" class="headerlink" title="2303. 计算应缴税款总额"></a><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">2303. 计算应缴税款总额</a></h4><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10-5</code> 的结果将被视作正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：brackets = [[<span class="hljs-number">3</span>,<span class="hljs-number">50</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">25</span>]], income = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">2.65000</span><br>解释：<br>前 $3 的税率为 <span class="hljs-number">50</span>% 。需要支付税款 $3 * <span class="hljs-number">50</span>% = $1<span class="hljs-number">.50</span> 。<br>接下来 $7 - $3 = $4 的税率为 <span class="hljs-number">10</span>% 。需要支付税款 $4 * <span class="hljs-number">10</span>% = $0<span class="hljs-number">.40</span> 。<br>最后 $10 - $7 = $3 的税率为 <span class="hljs-number">25</span>% 。需要支付税款 $3 * <span class="hljs-number">25</span>% = $0<span class="hljs-number">.75</span> 。<br>需要支付的税款总计 $1<span class="hljs-number">.50</span> + $0<span class="hljs-number">.40</span> + $0<span class="hljs-number">.75</span> = $2<span class="hljs-number">.65</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，从前到后遍历数组，如果income大于upper，计算upper以前的税收；否则，income小于等于upper，计算income以前的税收，遍历终止</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了22.05%的用户</p><p>通过测试用例：227 &#x2F; 227</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTax</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] brackets, <span class="hljs-type">int</span> income)</span> &#123;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> []get:brackets)&#123;<br>            <span class="hljs-keyword">if</span>(income&gt;get[<span class="hljs-number">0</span>])&#123;<br>                res+=((get[<span class="hljs-number">0</span>]-pre)*get[<span class="hljs-number">1</span>])/<span class="hljs-number">100.0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res+=((income-pre)*get[<span class="hljs-number">1</span>])/<span class="hljs-number">100.0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pre=get[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1817</title>
    <link href="/posts/51772.html"/>
    <url>/posts/51772.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1817-查找用户活跃分钟数"><a href="#1817-查找用户活跃分钟数" class="headerlink" title="1817. 查找用户活跃分钟数"></a><a href="https://leetcode.cn/problems/finding-the-users-active-minutes/">1817. 查找用户活跃分钟数</a></h4><p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 <code>IDi</code> 的用户在 <code>timei</code> 分钟时执行了某个操作。</p><p><strong>多个用户</strong> 可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p><p>指定用户的 <strong>用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p><p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 &lt;= j &lt;= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p><p>返回上面描述的答案数组 <code>answer</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：logs = <span class="hljs-comment">[<span class="hljs-comment">[0,5]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[0,5]</span>,<span class="hljs-comment">[1,3]</span>]</span>, k = 5<br>输出：<span class="hljs-comment">[0,2,0,0,0]</span><br>解释：<br>ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）<br>ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2<br>2 个用户的用户活跃分钟数都是 2 ，answer<span class="hljs-comment">[2]</span> 为 2 ，其余 answer<span class="hljs-comment">[j]</span> 的值都是 0<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表存储：使用<code>HashMap &lt;Integer,HashSet&lt;Integer&gt;&gt;</code>储存信息</li></ol><blockquote><p>执行用时：16 ms, 在所有 Java 提交中击败了86.21%的用户</p><p>内存消耗：52.4 MB, 在所有 Java 提交中击败了9.20%的用户</p><p>通过测试用例：38 &#x2F; 38</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findingUsersActiveMinutes(<span class="hljs-type">int</span>[][] logs, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [k];<br>        HashMap &lt;Integer,HashSet&lt;Integer&gt;&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;logs.length;i++)&#123;<br>            <span class="hljs-type">int</span> key=logs[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> value=logs[i][<span class="hljs-number">1</span>];<br>            HashSet set=map.getOrDefault(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>());<br>            set.add(value);<br>            map.put(key,set);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(HashSet set:map.values())&#123;<br>            res[set.size()-<span class="hljs-number">1</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2299</title>
    <link href="/posts/34970.html"/>
    <url>/posts/34970.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2299-强密码检验器-II"><a href="#2299-强密码检验器-II" class="headerlink" title="2299. 强密码检验器 II"></a><a href="https://leetcode.cn/problems/strong-password-checker-ii/">2299. 强密码检验器 II</a></h4><p>如果一个密码满足以下所有条件，我们称它是一个 <strong>强</strong> 密码：</p><ul><li>它有至少 <code>8</code> 个字符。</li><li>至少包含 <strong>一个小写英文</strong> 字母。</li><li>至少包含 <strong>一个大写英文</strong> 字母。</li><li>至少包含 <strong>一个数字</strong> 。</li><li>至少包含 <strong>一个特殊字符</strong> 。特殊字符为：<code>&quot;!@#$%^&amp;*()-+&quot;</code> 中的一个。</li><li>它 <strong>不</strong> 包含 <code>2</code> 个连续相同的字符（比方说 <code>&quot;aab&quot;</code> 不符合该条件，但是 <code>&quot;aba&quot;</code> 符合该条件）。</li></ul><p>给你一个字符串 <code>password</code> ，如果它是一个 <strong>强</strong> 密码，返回 <code>true</code>，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入：<span class="hljs-keyword">password</span> = &quot;IloveLe3tcode!&quot;<br>输出：<span class="hljs-keyword">true</span><br>解释：密码满足所有的要求，所以我们返回 <span class="hljs-keyword">true</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，这里的判断方法可以用Character里的现有方法替代</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了69.57%的用户</p><p>内存消耗：39.5 MB, 在所有 Java 提交中击败了53.26%的用户</p><p>通过测试用例：148 &#x2F; 148</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">strongPasswordCheckerII</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-type">int</span> n=password.length();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">8</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> have_big=<span class="hljs-literal">false</span>,have_small=<span class="hljs-literal">false</span>,have_num=<span class="hljs-literal">false</span>,have_sp=<span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span> pre=<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        String sp=<span class="hljs-string">&quot;!@#$%^&amp;*()-+&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">char</span> c=password.charAt(i);<br>            <span class="hljs-keyword">if</span>(c==pre)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            pre=c;<br>            <span class="hljs-keyword">if</span>(sp.contains(String.valueOf(c)))&#123;<br>                have_sp=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 大写字母</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c-<span class="hljs-string">&#x27;A&#x27;</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;c-<span class="hljs-string">&#x27;A&#x27;</span>&lt;<span class="hljs-number">26</span>)&#123;<br>                have_big=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c-<span class="hljs-string">&#x27;a&#x27;</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;c-<span class="hljs-string">&#x27;a&#x27;</span>&lt;<span class="hljs-number">26</span>)&#123;<br>                have_small=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;c-<span class="hljs-string">&#x27;0&#x27;</span>&lt;<span class="hljs-number">10</span>)&#123;<br>                have_num=<span class="hljs-literal">true</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> have_big&amp;&amp;have_num&amp;&amp;have_small&amp;&amp;have_sp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 461</title>
    <link href="/posts/39994.html"/>
    <url>/posts/39994.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode.cn/problems/hamming-distance/">461. 汉明距离</a></h4><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">1</span>   (<span class="hljs-number">0 0 0 1</span>)<br><span class="hljs-number">4</span>   (<span class="hljs-number">0 1 0 0</span>)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>位运算</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.6 MB, 在所有 Java 提交中击败了31.43%的用户</p><p>通过测试用例：149 &#x2F; 149</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>||y!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 如果末尾不同</span><br>            <span class="hljs-keyword">if</span>((x&amp;<span class="hljs-number">1</span>)!=(y&amp;<span class="hljs-number">1</span>))&#123;<br>                res++;<br>            &#125;<br>            x&gt;&gt;=<span class="hljs-number">1</span>;<br>            y&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 338</title>
    <link href="/posts/2888.html"/>
    <url>/posts/2888.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></h4><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，遍历每个元素，依次获取</li></ol><blockquote><p>执行用时：12 ms, 在所有 Java 提交中击败了6.33%的用户</p><p>内存消耗：45.1 MB, 在所有 Java 提交中击败了96.57%的用户</p><p>通过测试用例：15 &#x2F; 15</p><p>将除法和取余运算修改为位运算</p><p>执行用时：5 ms, 在所有 Java 提交中击败了18.58%的用户</p><p>内存消耗：45.6 MB, 在所有 Java 提交中击败了37.43%的用户</p><p>通过测试用例：15 &#x2F; 15</p><p>时间 O(n*logn)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> num=i;<br>            <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(num%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                    res[i]++;<br>                &#125;<br>                num/=<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// -------------------------------------------</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> num=i;<br>            <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>((num&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                    res[i]++;<br>                &#125;<br>                num=num&gt;&gt;<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>找规律：可以发现，把数字分为两种情况，奇数和偶数<ol><li>奇数：n中1的个数为n-1的个数+1</li><li>偶数：末尾一定为0，对应的1的个数为去掉末尾0的个数</li></ol></li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了99.98%的用户</p><p>内存消耗：45.5 MB, 在所有 Java 提交中击败了52.85%的用户</p><p>通过测试用例：15 &#x2F; 15</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> []res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">// 如果是偶数</span><br>            <span class="hljs-keyword">if</span>((i&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                res[i]=res[i&gt;&gt;<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res[i]=res[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1814</title>
    <link href="/posts/52092.html"/>
    <url>/posts/52092.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1814-统计一个数组中好对子的数目"><a href="#1814-统计一个数组中好对子的数目" class="headerlink" title="1814. 统计一个数组中好对子的数目"></a><a href="https://leetcode.cn/problems/count-nice-pairs-in-an-array/">1814. 统计一个数组中好对子的数目</a></h4><p>给你一个数组 <code>nums</code> ，数组中只包含非负整数。定义 <code>rev(x)</code> 的值为将整数 <code>x</code> 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code> 是 <strong>好的</strong> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; nums.length</code></li><li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li></ul><p>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [42,11,1,97]<br>输出：2<br>解释：两个坐标对为：<br> - (0,3)：42 + rev(97) =<span class="hljs-number"> 42 </span>+<span class="hljs-number"> 79 </span>= 121,<span class="hljs-number"> 97 </span>+ rev(42) =<span class="hljs-number"> 97 </span>+<span class="hljs-number"> 24 </span>=<span class="hljs-number"> 121 </span>。<br> - (1,2)：11 + rev(1) =<span class="hljs-number"> 11 </span>+<span class="hljs-number"> 1 </span>= 12,<span class="hljs-number"> 1 </span>+ rev(11) =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 11 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解法，两层for循环</li></ol><blockquote><p>超时</p><p>时间 O(n*n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNicePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(isGood(nums[i],nums[j]))&#123;<br>                    res++;<br>                    res=res%<span class="hljs-number">1000000007</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRevert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            res=res*<span class="hljs-number">10</span>+num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGood</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> iRevert=getRevert(i);<br>        <span class="hljs-type">int</span> jRevert=getRevert(j);<br>        <span class="hljs-keyword">if</span>(i+jRevert==j+iRevert)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>哈希表，将等式<code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code>转换为：<code>nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]) </code>，那么只需对<code>nums[i] - rev(nums[i])</code>做哈希表计数，然后进行统计，排列组合的结果输出；需要注意的是，计算排列组合结果时，乘法会超出int的范围，需要用long来转换</li></ol><blockquote><p>执行用时：34 ms, 在所有 Java 提交中击败了53.15%的用户</p><p>内存消耗：57.7 MB, 在所有 Java 提交中击败了26.13%的用户</p><p>通过测试用例：84 &#x2F; 84</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNicePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        System.out.println((<span class="hljs-type">long</span>)(<span class="hljs-number">100000</span>*<span class="hljs-number">99999</span>/<span class="hljs-number">2</span>));<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> key=nums[i]-getRevert(nums[i]);<br>            map.put(key,map.getOrDefault(key,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:map.values())&#123;<br>            <span class="hljs-type">long</span> tmp=((<span class="hljs-type">long</span>)num*((<span class="hljs-type">long</span>)num-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)%<span class="hljs-number">1000000007</span>;<br>            res+=(<span class="hljs-type">int</span>)tmp;<br>            res%=<span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRevert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            res=res*<span class="hljs-number">10</span>+num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 169</title>
    <link href="/posts/23339.html"/>
    <url>/posts/23339.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h4><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用HashMap存储，遍历</li></ol><blockquote><p>执行用时：21 ms, 在所有 Java 提交中击败了6.60%的用户</p><p>内存消耗：46.6 MB, 在所有 Java 提交中击败了16.36%的用户</p><p>通过测试用例：45 &#x2F; 45</p><p>时间 O(n)</p><p>空间 O(n) 使用了一个HashMap存储</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> key=nums[i];<br>            <span class="hljs-keyword">if</span>(map.getOrDefault(key,<span class="hljs-number">0</span>)==n/<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> nums[i];<br>            map.put(key,map.getOrDefault(key,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>时空 O(n) O(1)的还没看懂</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 121</title>
    <link href="/posts/23848.html"/>
    <url>/posts/23848.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>一次遍历，查找当前的最小元素与现在元素的差值，该差值与当前最大值比较，最后结果返回</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了54.61%的用户</p><p>内存消耗：57.9 MB, 在所有 Java 提交中击败了24.49%的用户</p><p>通过测试用例：211 &#x2F; 211</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre_min=prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.length;i++)&#123;<br>            res=Math.max(res,prices[i]-pre_min);<br>            pre_min=Math.min(pre_min,prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 104</title>
    <link href="/posts/16105.html"/>
    <url>/posts/16105.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归，深度优先搜索</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.1 MB, 在所有 Java 提交中击败了69.57%的用户</p><p>通过测试用例：39 &#x2F; 39</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left_len=maxDepth(root.left);<br>        <span class="hljs-type">int</span> right_len=maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(left_len,right_len)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 101</title>
    <link href="/posts/15657.html"/>
    <url>/posts/15657.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/symtree1.jpg" alt="img"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了92.19%的用户</p><p>通过测试用例：199 &#x2F; 199</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isTrue(root.left,root.right);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTrue</span><span class="hljs-params">(TreeNode left,TreeNode right)</span>&#123;<br>        <span class="hljs-comment">// 两个节点都为null，显然为true</span><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>&amp;&amp;right==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 两个节点都不为null，那么需要继续比较其子节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>&amp;&amp;right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(left.val!=right.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> isTrue(left.left,right.right)&amp;&amp;isTrue(left.right,right.left);<br>        &#125;<br>        <span class="hljs-comment">// 两个节点一个为null，另一个不为null，那么一定是false</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 70</title>
    <link href="/posts/51553.html"/>
    <url>/posts/51553.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>超时</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">return</span> climbStairs(n-<span class="hljs-number">1</span>)+climbStairs(n-<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>迭代，f(n)&#x3D;f(n-1)+f(n-2)</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.7 MB, 在所有 Java 提交中击败了5.07%的用户</p><p>通过测试用例：45 &#x2F; 45</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> tmp=a;<br>            a=b;<br>            b+=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>题解还有用到矩阵快速幂、通项公式，没看</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 21</title>
    <link href="/posts/22947.html"/>
    <url>/posts/22947.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/merge_ex1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，模拟同时访问两个链表的头，将较小的元素加入结果中</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41 MB, 在所有 Java 提交中击败了51.93%的用户</p><p>通过测试用例：208 &#x2F; 208</p><p>时间 O(n) 为两个链表长度</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        ListNode res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode tmp=res;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">null</span>&amp;&amp;list2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1.val&gt;list2.val)&#123;<br>                res.next=list2;<br>                list2=list2.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res.next=list1;<br>                list1=list1.next;<br>            &#125;<br>            res=res.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1!=<span class="hljs-literal">null</span>)&#123;<br>            res.next=list1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list2!=<span class="hljs-literal">null</span>)&#123;<br>            res.next=list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2293</title>
    <link href="/posts/36634.html"/>
    <url>/posts/36634.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2293-极大极小游戏"><a href="#2293-极大极小游戏" class="headerlink" title="2293. 极大极小游戏"></a><a href="https://leetcode.cn/problems/min-max-game/">2293. 极大极小游戏</a></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p><p>对 <code>nums</code> 执行下述算法：</p><ol><li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组 <code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>用 <code>newNums</code> 替换 <code>nums</code> 。</li><li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li></ol><p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/example1drawio-1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,2,4,8,2,2]</span><br>输出：1<br>解释：重复执行算法会得到下述数组。<br>第一轮：nums = <span class="hljs-comment">[1,5,4,2]</span><br>第二轮：nums = <span class="hljs-comment">[1,4]</span><br>第三轮：nums = <span class="hljs-comment">[1]</span><br>1 是最后剩下的那个数字，返回 1 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，除了个别行，和官方题解竟然一模一样，变量名都一样</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了71.01%的用户</p><p>内存消耗：40.8 MB, 在所有 Java 提交中击败了92.02%的用户</p><p>通过测试用例：96 &#x2F; 96</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMaxGame</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 迭代</span><br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> []newNums=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n/<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    newNums[i]=Math.min(nums[<span class="hljs-number">2</span>*i],nums[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    newNums[i]=Math.max(nums[<span class="hljs-number">2</span>*i],nums[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            n=newNums.length;<br>            nums=newNums;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>原地操作：在顺序遍历的情况下，newNums[i]的结果可以直接存在nums[i]中，因为，nums[i]的值在本次循环中不会再使用了，之前在计算nums[i&#x2F;2]的时候已经被使用过了。但不只为何，内存消耗不降反增。</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了71.01%的用户</p><p>内存消耗：41.1 MB, 在所有 Java 提交中击败了47.06%的用户</p><p>通过测试用例：96 &#x2F; 96</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMaxGame</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 原地操作</span><br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> m=n/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    nums[i]=Math.min(nums[<span class="hljs-number">2</span>*i],nums[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    nums[i]=Math.max(nums[<span class="hljs-number">2</span>*i],nums[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            n=m;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2</title>
    <link href="/posts/25580.html"/>
    <url>/posts/25580.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h4><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟：由于都是逆序存储，因此可以直接相加，大于10的情况进位，直到一个链表为null，那么只计算剩余链表和进位情况。都为空则停止。此外，如果最后的进位仍为1，那么结果尾部需要新加一个节点1。</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了23.99%的用户</p><p>通过测试用例：1568 &#x2F; 1568</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">// 统计链表长度，加和进位，返回结果</span><br>        ListNode res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode tmp=res;<br>        <span class="hljs-comment">// next 表示进位</span><br>        <span class="hljs-type">int</span> next=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">null</span>||l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">null</span>)&#123;<br>                sum = l2.val+next;<br>                l2=l2.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">null</span>)&#123;<br>                sum = l1.val+next;<br>                l1=l1.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                sum=l1.val+l2.val+next;<br>                l1=l1.next;<br>                l2=l2.next;<br>            &#125;<br>            next=sum&gt;<span class="hljs-number">9</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> num=sum&gt;<span class="hljs-number">9</span>?sum-<span class="hljs-number">10</span>:sum;<br>            tmp.next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(num);<br>            tmp=tmp.next;<br>        &#125;<br>        <span class="hljs-comment">// 进位不为0，则表示需要进位，末尾添加1</span><br>        <span class="hljs-keyword">if</span>(next!=<span class="hljs-number">0</span>)&#123;<br>            tmp.next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2283</title>
    <link href="/posts/7963.html"/>
    <url>/posts/7963.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2283-判断一个数的数字计数是否等于数位的值"><a href="#2283-判断一个数的数字计数是否等于数位的值" class="headerlink" title="2283. 判断一个数的数字计数是否等于数位的值"></a><a href="https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/">2283. 判断一个数的数字计数是否等于数位的值</a></h4><p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的字符串 <code>num</code> ，它只包含数字。</p><p>如果对于 <strong>每个</strong> <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，都满足数位 <code>i</code> 在 <code>num</code> 中出现了 <code>num[i]</code>次，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;1210&quot;</span><br>输出：<span class="hljs-keyword">true</span><br>解释：<br><span class="hljs-built_in">num</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span> 。数字 <span class="hljs-number">0</span> 在 <span class="hljs-built_in">num</span> 中出现了一次。<br><span class="hljs-built_in">num</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span> 。数字 <span class="hljs-number">1</span> 在 <span class="hljs-built_in">num</span> 中出现了两次。<br><span class="hljs-built_in">num</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;1&#x27;</span> 。数字 <span class="hljs-number">2</span> 在 <span class="hljs-built_in">num</span> 中出现了一次。<br><span class="hljs-built_in">num</span>[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;0&#x27;</span> 。数字 <span class="hljs-number">3</span> 在 <span class="hljs-built_in">num</span> 中出现了零次。<br><span class="hljs-string">&quot;1210&quot;</span> 满足题目要求条件，所以返回 <span class="hljs-keyword">true</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表计数</li></ol><blockquote><p><strong>433 &#x2F; 433</strong> 个通过测试用例</p><p>执行用时: <strong>1 ms</strong></p><p>内存消耗: <strong>40.1 MB</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">digitCount</span><span class="hljs-params">(String num)</span> &#123;<br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num.length();i++)&#123;<br>            <span class="hljs-type">int</span> k=num.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            map.put(k,map.getOrDefault(k,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num.length();i++)&#123;<br>            <span class="hljs-type">int</span> k=num.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(map.getOrDefault(i,<span class="hljs-number">0</span>)!=k)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用数组计数</li></ol><blockquote><p><strong>433 &#x2F; 433</strong> 个通过测试用例</p><p>执行用时: <strong>0 ms</strong></p><p>内存消耗: <strong>39.6 MB</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">digitCount</span><span class="hljs-params">(String num)</span> &#123;<br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num.length();i++)&#123;<br>            count[num.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i]!=num.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2287</title>
    <link href="/posts/56346.html"/>
    <url>/posts/56346.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2287-重排字符形成目标字符串"><a href="#2287-重排字符形成目标字符串" class="headerlink" title="2287. 重排字符形成目标字符串"></a><a href="https://leetcode.cn/problems/rearrange-characters-to-make-target-string/">2287. 重排字符形成目标字符串</a></h4><p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p><p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;ilovecodingonleetcode&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;code&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>对于 <span class="hljs-string">&quot;code&quot;</span> 的第 <span class="hljs-number">1</span> 个副本，选取下标为 <span class="hljs-number">4</span> 、<span class="hljs-number">5</span> 、<span class="hljs-number">6</span> 和 <span class="hljs-number">7</span> 的字符。<br>对于 <span class="hljs-string">&quot;code&quot;</span> 的第 <span class="hljs-number">2</span> 个副本，选取下标为 <span class="hljs-number">17</span> 、<span class="hljs-number">18</span> 、<span class="hljs-number">19</span> 和 <span class="hljs-number">20</span> 的字符。<br>形成的字符串分别是 <span class="hljs-string">&quot;ecod&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> ，都可以重排为 <span class="hljs-string">&quot;code&quot;</span> 。<br>可以形成最多 <span class="hljs-number">2</span> 个 <span class="hljs-string">&quot;code&quot;</span> 的副本，所以返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表计数，使用HashMap分别存储在两个字符串中出现的字符数量，然后做除法，求最小值</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了40.21%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了33.86%的用户</p><p>通过测试用例：115 &#x2F; 115</p><p>时间 O(n+m) 两个字符串长度</p><p>空间 O(m) target的长度为m，空间占用不超过m</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rearrangeCharacters</span><span class="hljs-params">(String s, String target)</span> &#123;<br>        Map &lt;Character,Integer&gt; targetMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map &lt;Character,Integer&gt; sMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span> res=Integer.MAX_VALUE;<br>        <span class="hljs-comment">// 将target字符串出现次数存储</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;target.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=target.charAt(i);<br>            targetMap.put(c,targetMap.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将s与target中重复出现的字符串统计个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">char</span> c=s.charAt(i);<br>            <span class="hljs-keyword">if</span>(targetMap.containsKey(c))&#123;<br>                sMap.put(c,sMap.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 遍历map查找最小倍数，此处需要遍历targetMap，因为存在着出现a，ab这种测试情况</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:targetMap.entrySet())&#123;<br>            <span class="hljs-type">char</span> key=entry.getKey();<br>            <span class="hljs-type">int</span> targetValue=entry.getValue();<br>            <span class="hljs-type">int</span> sValue=sMap.getOrDefault(key,<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 优化，某个字符串为0，直接返回0</span><br>            <span class="hljs-keyword">if</span>(sValue==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            res=Math.min(res,sValue/targetValue);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>不使用map存储，使用数组实现，与2283题类似</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 543</title>
    <link href="/posts/65003.html"/>
    <url>/posts/65003.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>     <br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>    <br></code></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>深度优先搜索，使用一个全局变量统计最大半径，递归时获取分别获取左右子树的高度，同时更新最大半径。递归返回的条件是root为null，需要理解清楚叶子结点作为长度为1的存在</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41 MB, 在所有 Java 提交中击败了70.54%的用户</p><p>通过测试用例：104 &#x2F; 104</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        getMaxDeep(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxDeep</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len_l=getMaxDeep(root.left);<br>        <span class="hljs-type">int</span> len_r=getMaxDeep(root.right);<br>        res=Math.max(res,len_l+len_r);<br>        <span class="hljs-keyword">return</span> Math.max(len_l,len_r)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 234</title>
    <link href="/posts/52761.html"/>
    <url>/posts/52761.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/pal1linked-list.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,2,1]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用栈遍历</li></ol><blockquote><p>执行用时：36 ms, 在所有 Java 提交中击败了5.73%的用户</p><p>内存消耗：58.2 MB, 在所有 Java 提交中击败了21.65%的用户</p><p>通过测试用例：88 &#x2F; 88</p><p>时间 O(2n)</p><p>空间 O(n) 使用了栈存储数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 使用stack存储val，第一次遍历入栈，二次遍历出栈对比</span><br>        Stack&lt;Integer&gt; s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>        ListNode tmp=head,tmp2=head;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">null</span>)&#123;<br>            s.push(tmp.val);<br>            tmp=tmp.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(tmp2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmp2.val!=s.pop())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            tmp2=tmp2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>要想使得空间为O(1)，就需要改变输入，主要步骤为<ol><li>找到前半部分链表的尾结点</li><li>翻转后半部分链表</li><li>双指针同时向后移动，比较，判断是否为回文</li><li>&#x2F;&#x2F; 恢复链表</li><li>返回结果</li></ol></li></ol><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了39.41%的用户</p><p>内存消耗：51.4 MB, 在所有 Java 提交中击败了96.77%的用户</p><p>通过测试用例：88 &#x2F; 88</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        ListNode tmp=head;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">null</span>)&#123;<br>            num++;<br>            tmp=tmp.next;<br>        &#125;<br>        tmp = head;<br>        <span class="hljs-comment">// 前半部分取较短的部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num/<span class="hljs-number">2</span>;i++)&#123;<br>            tmp=tmp.next;<br>        &#125;<br>        <span class="hljs-comment">// 这里有个问题，翻转后的链表，对原来的链表有影响，对于例子[1,2,3,2,1]左半部分的应该为[1,2]，右半部分为[3,2,1],翻转后为[1,2,1,2,3]</span><br>        ListNode right=reverseList(tmp);<br>        <span class="hljs-keyword">while</span> (right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val!=right.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            head=head.next;<br>            right=right.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        ListNode res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp=head.next;<br>            head.next=res.next;<br>            res.next=head;<br>            head=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 141</title>
    <link href="/posts/64811.html"/>
    <url>/posts/64811.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>快慢指针，使用两个指针遍历链表，快指针每次都向前，慢指针逢二向前。如果链表无环，那么快指针总是跑到null；如果链表有环，那么两个指针会相遇</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了23.59%的用户</p><p>内存消耗：43 MB, 在所有 Java 提交中击败了9.25%的用户</p><p>通过测试用例：23 &#x2F; 23</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode low=head,fast=head.next;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast==low)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            fast=fast.next;<br>            <span class="hljs-keyword">if</span>(num++%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                low=low.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>快慢指针，但是快指针每次向前2，慢指针每次向前1</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：42.5 MB, 在所有 Java 提交中击败了63.94%的用户</p><p>通过测试用例：23 &#x2F; 23</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode low=head,fast=head.next;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast==low)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(fast.next==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fast=fast.next.next;<br>            low=low.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>（官方题解）哈希表，使用哈希表存储访问过的节点，每次判断是否访问过</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        Set&lt;ListNode&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;ListNode&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!seen.add(head)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 94</title>
    <link href="/posts/27236.html"/>
    <url>/posts/27236.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/inorder_1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>中序遍历，递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了44.46%的用户</p><p>通过测试用例：70 &#x2F; 70</p><p>时间 O(n)</p><p>空间 O(h) h是树高</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> res;<br>        List&lt;Integer&gt; left=inorderTraversal(root.left);<br>        List&lt;Integer&gt; right=inorderTraversal(root.right);<br>        res.addAll(left);<br>        res.add(root.val);<br>        res.addAll(right);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 160</title>
    <link href="/posts/24043.html"/>
    <url>/posts/24043.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>难度简单1931收藏分享切换为英文接收动态反馈</p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，先遍历获取m n，较长的向后移动abs(m-n)，然后同时向后移动，记录最后一个不相等元素的next node</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了97.99%的用户</p><p>内存消耗：44.2 MB, 在所有 Java 提交中击败了70.32%的用户</p><p>通过测试用例：39 &#x2F; 39</p><p>时间 O(2m+2n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-comment">// 先遍历获取m n，较长的向后移动abs(m-n)，然后同时向后移动</span><br>        ListNode tmpA=headA,tmpB=headB;<br>        <span class="hljs-type">int</span> lenA=<span class="hljs-number">0</span>,lenB=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tmpA!=<span class="hljs-literal">null</span>)&#123;<br>            lenA++;<br>            tmpA=tmpA.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(tmpB!=<span class="hljs-literal">null</span>)&#123;<br>            lenB++;<br>            tmpB=tmpB.next;<br>        &#125;<br>        tmpA=headA;<br>        tmpB=headB;<br>        <span class="hljs-keyword">if</span>(lenA&gt;lenB)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lenA-lenB;i++)&#123;<br>                tmpA=tmpA.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lenB-lenA;i++)&#123;<br>                tmpB=tmpB.next;<br>            &#125;<br>        &#125;<br>        ListNode res=tmpA;<br>        <span class="hljs-keyword">while</span>(tmpA!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmpA!=tmpB)&#123;<br>                <span class="hljs-keyword">if</span>(tmpA.next!=<span class="hljs-literal">null</span>)&#123;<br>                    res=tmpA.next;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            tmpA=tmpA.next;<br>            tmpB=tmpB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>大神题解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>        pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 206</title>
    <link href="/posts/65432.html"/>
    <url>/posts/65432.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，原地翻转，将待翻转链表头部的node摘出来；遍历链表时，将当前head.next存储起来，然后将head插入res和res.next 之间</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了9.12%的用户</p><p>通过测试用例：28 &#x2F; 28</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        ListNode res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp=head.next;<br>            head.next=res.next;<br>            res.next=head;<br>            head=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>递归</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 226</title>
    <link href="/posts/40857.html"/>
    <url>/posts/40857.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>深度优先(递归)</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了8.65%的用户</p><p>通过测试用例：77 &#x2F; 77</p><p>时间 O(n)</p><p>空间 O(h)，h是树的高度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        TreeNode tmp=root.right;<br>        root.right=invertTree(root.left);<br>        root.left=invertTree(tmp);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>广度优先（迭代），懒得写</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2185</title>
    <link href="/posts/7531.html"/>
    <url>/posts/7531.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2185-统计包含给定前缀的字符串"><a href="#2185-统计包含给定前缀的字符串" class="headerlink" title="2185. 统计包含给定前缀的字符串"></a><a href="https://leetcode.cn/problems/counting-words-with-a-given-prefix/">2185. 统计包含给定前缀的字符串</a></h4><p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>pref</code> 。</p><p>返回 <code>words</code> 中以 <code>pref</code> 作为 <strong>前缀</strong> 的字符串的数目。</p><p>字符串 <code>s</code> 的 <strong>前缀</strong> 就是 <code>s</code> 的任一前导连续字符串。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>直接模拟，从前到后判断</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了20.10%的用户</p><p>通过测试用例：95 &#x2F; 95</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prefixCount</span><span class="hljs-params">(String[] words, String pref)</span> &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;words.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(isTrue(words[i],pref))&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTrue</span><span class="hljs-params">(String words, String pref)</span>&#123;<br>        <span class="hljs-keyword">if</span>(words.length()&lt;pref.length())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pref.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(pref.charAt(i)!=words.charAt(i))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1658</title>
    <link href="/posts/52511.html"/>
    <url>/posts/52511.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1658-将-x-减到-0-的最小操作数"><a href="#1658-将-x-减到-0-的最小操作数" class="headerlink" title="1658. 将 x 减到 0 的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p><p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口：前后指针分别表示前缀和和后缀和，后缀和从整个数组开始，前缀和从-1开始，<ol><li>如果lsum+rsum&#x3D;x，说明找到了一组答案</li><li>如果lsum+rsum&gt;x，说明过大，把right向右移动</li><li>如果lsum+rsum&lt;x，说明过小，把left向左移动</li></ol></li></ol><blockquote><p>执行用时：11 ms, 在所有 Java 提交中击败了27.04%的用户</p><p>内存消耗：50.3 MB, 在所有 Java 提交中击败了85.29%的用户</p><p>通过测试用例：94 &#x2F; 94</p><p>时间：O(n)</p><p>空间：O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> res=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lsum=<span class="hljs-number">0</span>,rsum=Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span>(rsum&lt;x)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=-<span class="hljs-number">1</span>;left&lt;n;left++)&#123;<br>            <span class="hljs-keyword">if</span>(left!=-<span class="hljs-number">1</span>)&#123;<br>                lsum+=nums[left];<br>            &#125;<br>            <span class="hljs-comment">// 和大于n时，r向右移动</span><br>            <span class="hljs-keyword">while</span>(lsum+rsum&gt;x&amp;&amp;right&lt;n)&#123;<br>                rsum-=nums[right];<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(lsum+rsum==x)&#123;<br>                res=Math.min(res,left+<span class="hljs-number">1</span>+n-right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res&gt;n?-<span class="hljs-number">1</span>:res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>逆向思维，考虑找到一个最长的子数组，使得子数组的和为sum-x</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 617</title>
    <link href="/posts/28185.html"/>
    <url>/posts/28185.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>深度优先搜索，从根节点开始，依次合并两个树的节点，将合并后的节点存在root1中，合并时有几种情况：<ol><li>两个节点都为null，那么返回null</li><li>两个节点有一个为null，返回非空节点</li><li>两个节点都不为空，合并两个节点，并将左右孩子节点递归调用合并</li></ol></li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了73.39%的用户</p><p>通过测试用例：182 &#x2F; 182</p><p>时间复杂度：O(min(m,n))，m n分别是两个二叉树的层数</p><p>空间复杂度：O(min(m,n))，m n分别是两个二叉树的层数，取决于递归层数，层数不会超过最矮的二叉树的高度；最差情况等于节点数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1!=<span class="hljs-literal">null</span>&amp;&amp;root2!=<span class="hljs-literal">null</span>)&#123;<br>            root1.val+=root2.val;<br>            root1.left=mergeTrees(root1.left,root2.left);<br>            root1.right=mergeTrees(root1.right,root2.right);<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root1!=<span class="hljs-literal">null</span>||root2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1==<span class="hljs-literal">null</span>?root2:root1;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官方题解更优雅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">merged</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(t1.val + t2.val);<br>        merged.left = mergeTrees(t1.left, t2.left);<br>        merged.right = mergeTrees(t1.right, t2.right);<br>        <span class="hljs-keyword">return</span> merged;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2180</title>
    <link href="/posts/7851.html"/>
    <url>/posts/7851.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2180-统计各位数字之和为偶数的整数个数"><a href="#2180-统计各位数字之和为偶数的整数个数" class="headerlink" title="2180. 统计各位数字之和为偶数的整数个数"></a><a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/">2180. 统计各位数字之和为偶数的整数个数</a></h4><p>给你一个正整数 <code>num</code> ，请你统计并返回 <strong>小于或等于</strong> <code>num</code> 且各位数字之和为 <strong>偶数</strong> 的正整数的数目。</p><p>正整数的 <strong>各位数字之和</strong> 是其所有位上的对应数字相加的结果。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力求解，依次判断每个数字是否符合要求</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了83.26%的用户</p><p>内存消耗：38.4 MB, 在所有 Java 提交中击败了45.61%的用户</p><p>通过测试用例：71 &#x2F; 71</p><p>时间 O(n*logn)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countEven</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=num;i++)&#123;<br>            <span class="hljs-keyword">if</span>(isTrue(i))&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTrue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            tmp=num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>            res+=tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(res%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>数学推导方法<ol><li>将num分成10×y+x的表达形式，分成两个区间[0,10×y) 和[10×y+0,10×y+x]<ol><li>在区间[10×y+0,10×y+x]区间内，符合条件的个数为（上下取整这里最开始理解错了，改了半天） ：<ol><li>如果y是偶数，那么个数为 x&#x2F;2(向下取整)+1</li><li>如果y是奇数，那么个数为 x&#x2F;2 (向上取整)</li></ol></li><li>在区间[0,10×y+0) 内，符合条件的个数为5×y<ol><li>因为从0开始，每个个位数都是0-9，对应的奇偶都是5个，因此无论<strong>非个位</strong>数字的是奇是偶，总体都是5个</li></ol></li></ol></li><li>最后由于计算时包含了0，因此返回结果将其 -1</li></ol></li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.5 MB, 在所有 Java 提交中击败了29.29%的用户</p><p>通过测试用例：71 &#x2F; 71</p><p>时间 O(logn)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countEven</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> y=num/<span class="hljs-number">10</span>,x=num%<span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> res=y*<span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span>(isTrue(y))&#123;<br>            <span class="hljs-comment">// 查找有多少个偶数。包含0</span><br>            res+=x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 查找有多少个奇数</span><br>            <span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                res+=x/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res+=x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res-<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTrue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            tmp=num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>            res+=tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(res%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 448</title>
    <link href="/posts/64251.html"/>
    <url>/posts/64251.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h4><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先想到使用一个数组下标记录数组中出现的数字，tmp[i]&#x3D;1表示在nums中出现了i，否则表示没出现</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了99.62%的用户</p><p>内存消耗：49.1 MB, 在所有 Java 提交中击败了87.39%的用户</p><p>通过测试用例：33 &#x2F; 33</p><p>时间复杂度 O(n)</p><p>空间复杂度O(n)使用了一个数组来记录</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            tmp[num-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tmp.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[i]!=<span class="hljs-number">1</span>)&#123;<br>                res.add(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>考虑不使用额外的空间存储，在原数组的基础上修改（莫名其妙，内存消耗不降反增）</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了99.62%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了29.89%的用户</p><p>通过测试用例：33 &#x2F; 33</p><p>时间复杂度 O(n)</p><p>空间复杂度O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            nums[(num-<span class="hljs-number">1</span>)%n]+=n;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]-<span class="hljs-number">1</span>&lt;n)&#123;<br>                res.add(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 283</title>
    <link href="/posts/15455.html"/>
    <url>/posts/15455.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p> <a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解法，既然要求原地操作，那么我直接两层for循环</li></ol><blockquote><p>执行用时：565 ms, 在所有 Java 提交中击败了5.03%的用户</p><p>内存消耗：43.1 MB, 在所有 Java 提交中击败了20.29%的用户</p><p>通过测试用例：74 &#x2F; 74</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.length-<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]==<span class="hljs-number">0</span>)&#123;<br>                    swap(nums,j,j+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] swap(<span class="hljs-type">int</span> [] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>        <span class="hljs-type">int</span> tmp=nums[i];<br>        nums[i]=nums[j];<br>        nums[j]=tmp;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>能不能用O(n)的实现呢，想到了双指针实现，但是一时间没有捋顺代码，卡了半天，借鉴了别人的代码实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>,next=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 快慢指针,pre指向当前的0，next指向当前0后的第一个非零</span><br>        <span class="hljs-keyword">while</span>(next&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[next]!=<span class="hljs-number">0</span>)&#123;<br>                swap(nums,pre,next);<br>                pre++;<br>            &#125;<br>            next++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] swap(<span class="hljs-type">int</span> [] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>        <span class="hljs-type">int</span> tmp=nums[i];<br>        nums[i]=nums[j];<br>        nums[j]=tmp;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1802</title>
    <link href="/posts/23037.html"/>
    <url>/posts/23037.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p><p>nums.length &#x3D;&#x3D; n<br>nums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n<br>abs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1<br>nums 中所有元素之和不超过 maxSum<br>nums[index] 的值被 最大化<br>返回你所构造的数组中的 nums[index] 。</p><p>注意：abs(x) 等于 x 的前提是 x &gt;&#x3D; 0 ；否则，abs(x) 等于 -x 。</p><p><a href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/">1802. 有界数组中指定下标处的最大值 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>自己想的，没有什么章法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n==maxSum)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-type">int</span> nowSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 一个较小值，通过平均值计算，比平均值小n的数字一定是小于结果值的，因此设置所有数字都是rev</span><br>        <span class="hljs-type">int</span> rev=maxSum/n-n;<br>        <span class="hljs-keyword">if</span>(rev&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 当maxsum较大时，设置一个基值，相当于剪枝</span><br>            nowSum+=rev*n+<span class="hljs-number">1</span>;<br>            res=rev+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// rev小于0，表示maxsum不是很大</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            res=<span class="hljs-number">2</span>;<br>            nowSum=n+<span class="hljs-number">1</span>;<br><br>        &#125;<br>        <span class="hljs-keyword">while</span>(nowSum&lt;maxSum)&#123;<br>            <span class="hljs-type">int</span> left=index&gt;num?num:index;<br>            <span class="hljs-type">int</span> right=(index+num)&gt;(n-<span class="hljs-number">1</span>)?(n-<span class="hljs-number">1</span>-index):(num);<br>            nowSum+=left+right+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nowSum&gt;maxSum)&#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            res++;<br>            num++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 136</title>
    <link href="/posts/3944.html"/>
    <url>/posts/3944.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚好最近写项目用到了异或运算，一下子就想到了妙解，不然这个题要费一阵子劲</p><blockquote><p>异或运算：各个位上，相同为0，不同为1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a:nums)&#123;<br>            result^=a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2042</title>
    <link href="/posts/8062.html"/>
    <url>/posts/8062.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。</p><p>示例，”a puppy has 2 eyes 4 legs” 是一个由 7 个 token 组成的句子：”2” 和 “4” 是数字，其他像 “puppy” 这样的 tokens 属于单词。<br>给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。</p><p>如果满足题目要求，返回 true ，否则，返回 false 。</p><p><a href="https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/">2042. 检查句子中的数字是否递增 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>以后要仔细读题了，把简单题做复杂了</p></blockquote><p>这题没有看到数字的限制，自然而然的想到有些数字会超出int的范围（如 &gt;2147483647的数字），然后就写了个比较的函数，后来看见了题目后面的条件</p><ol><li>使用split的方式</li></ol><p><strong>98 &#x2F; 98</strong> 个通过测试用例</p><p>状态：<em>通过</em></p><p>执行用时: <strong>4 ms</strong></p><p>内存消耗: <strong>39.6 MB</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areNumbersAscending</span><span class="hljs-params">(String s)</span> &#123;<br>        String [] array=s.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        String tmp=<span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-keyword">for</span>(String a:array)&#123;<br>            <span class="hljs-keyword">if</span>(isNum(a))&#123;<br>                <span class="hljs-keyword">if</span>(!isBig(a,tmp))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                tmp=a;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(<span class="hljs-number">0</span>)&gt;<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s.charAt(<span class="hljs-number">0</span>)&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果a大于b，返回true，否则返回false</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBig</span><span class="hljs-params">(String a,String b)</span>&#123;<br>        <span class="hljs-type">int</span> a_len=a.length(),b_len=b.length();<br>        System.out.println(a_len);<br>        <span class="hljs-keyword">if</span>(a_len&gt;b_len)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a_len&lt;b_len)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a_len;i++)&#123;<br>                <span class="hljs-keyword">if</span>(a.charAt(i)&gt;b.charAt(i))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.charAt(i)&lt;b.charAt(i))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 相等返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2. </p><p>执行用时：1 ms, 在所有 Java 提交中击败了89.21%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了56.43%的用户</p><p>通过测试用例：98 &#x2F; 98</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areNumbersAscending</span><span class="hljs-params">(String s)</span> &#123;<br>        String [] array=s.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>;<br>        String tmp=<span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-keyword">for</span>(String a:array)&#123;<br>            <span class="hljs-keyword">if</span>(isNum(a))&#123;<br>                <span class="hljs-type">int</span> now=Integer.parseInt(a);<br>                <span class="hljs-keyword">if</span>(now&lt;=pre)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                pre=now;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(<span class="hljs-number">0</span>)&gt;<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s.charAt(<span class="hljs-number">0</span>)&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>自己切分字符串，更快</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 20</title>
    <link href="/posts/39266.html"/>
    <url>/posts/39266.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用栈辅助存储左括号，来进行匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length()%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Stack&lt;Character&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">char</span> a=s.charAt(i);<br>            <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;&#123;&#x27;</span>||a==<span class="hljs-string">&#x27;[&#x27;</span>||a==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stack.push(a);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.pop()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.pop()!=<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.pop()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写完通过后，看了别人的解法，可以说是相当简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt;stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>)stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;[&#x27;</span>)stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1801</title>
    <link href="/posts/22717.html"/>
    <url>/posts/22717.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二维整数数组 orders ，其中每个 orders[i] &#x3D; [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。</p><p>订单类型 orderTypei 可以分为两种：</p><p>0 表示这是一批采购订单 buy<br>1 表示这是一批销售订单 sell<br>注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><p>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。<br>反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。</p><p><a href="https://leetcode.cn/problems/number-of-orders-in-the-backlog/">1801. 积压订单中的订单总数 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>采用优先级队列解决，但由于对于这里不太熟，所以参考了解析</p><p>按照题目描述的思路，主要是捋顺了比较的逻辑，加上清楚优先级队列的使用；这题可以做出来</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberOfBacklogOrders</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] orders)</span> &#123; <br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; buyOrders=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b[<span class="hljs-number">0</span>]-a[<span class="hljs-number">0</span>]);<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; sellOrders=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> [] order:orders)&#123;<br>            <span class="hljs-type">int</span> price=order[<span class="hljs-number">0</span>],amount=order[<span class="hljs-number">1</span>],orderType=order[<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 采购订单</span><br>            <span class="hljs-keyword">if</span>(orderType==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>(amount&gt;<span class="hljs-number">0</span>&amp;&amp;!sellOrders.isEmpty()&amp;&amp;sellOrders.peek()[<span class="hljs-number">0</span>]&lt;=price)&#123;<br>                    <span class="hljs-comment">// 取出销售订单中的最低销售订单</span><br>                    <span class="hljs-type">int</span>[] sellOrder=sellOrders.poll();<br>                    <span class="hljs-type">int</span> dellAmount=amount&gt;sellOrder[<span class="hljs-number">1</span>]?sellOrder[<span class="hljs-number">1</span>]:amount;<br>                    amount-=dellAmount;<br>                    sellOrder[<span class="hljs-number">1</span>]-=dellAmount;<br>                    <span class="hljs-comment">// 如果最低销售订单未耗尽</span><br>                    <span class="hljs-keyword">if</span>(sellOrder[<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>                        sellOrders.offer(sellOrder);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果耗尽了所有的低价订单，仍有部分未采购，则加入购买的积压订单</span><br>                <span class="hljs-keyword">if</span>(amount&gt;<span class="hljs-number">0</span>)&#123;<br>                    buyOrders.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;price,amount&#125;);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 销售订单</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(amount&gt;<span class="hljs-number">0</span>&amp;&amp;!buyOrders.isEmpty()&amp;&amp;buyOrders.peek()[<span class="hljs-number">0</span>]&gt;=price)&#123;<br>                    <span class="hljs-comment">// 取出采购订单中的最高订单</span><br>                    <span class="hljs-type">int</span>[] buyOrder=buyOrders.poll();<br>                    <span class="hljs-type">int</span> dellAmount=amount&gt;buyOrder[<span class="hljs-number">1</span>]?buyOrder[<span class="hljs-number">1</span>]:amount;<br>                    amount-=dellAmount;<br>                    buyOrder[<span class="hljs-number">1</span>]-=dellAmount;<br>                    <span class="hljs-keyword">if</span>(buyOrder[<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>                        buyOrders.offer(buyOrder);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(amount&gt;<span class="hljs-number">0</span>)&#123;<br>                    sellOrders.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;price,amount&#125;);<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq: Arrays.asList(buyOrders,sellOrders))&#123;<br>            <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>                <span class="hljs-type">int</span>[] order=pq.poll();<br>                res=(res+order[<span class="hljs-number">1</span>])%<span class="hljs-number">1000000007</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2351</title>
    <link href="/posts/36559.html"/>
    <url>/posts/36559.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>简单题不简单</p><p>给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。</p><p>注意：</p><p>如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。<br>s 包含至少一个出现两次的字母。</p><p><a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">2351. 第一个出现两次的字母 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>最开始想用hashmap解决，因为用的比较熟悉了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">repeatedCharacter</span><span class="hljs-params">(String s)</span> &#123;<br>        HashMap map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<br>                <span class="hljs-keyword">return</span> s.charAt(i);<br>            &#125;<br>            map.put(s.charAt(i),<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.charAt(<span class="hljs-number">0</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>后来发现，这东西用hashset更合适，因为只需要存key，value没有实际意义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">repeatedCharacter</span><span class="hljs-params">(String s)</span> &#123;<br>        HashSet set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(!set.add(s.charAt(i)))&#123;<br>                <span class="hljs-keyword">return</span> s.charAt(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>看了解析之后，发现可以用位运算，通过int类型的后26位，模拟26个字母，对应某位为1则 &amp;的结果不为0，因此可以找到第一个元素；否则将该元素 | 运算后将对应位置为1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">repeatedCharacter</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> letter=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">int</span> l=s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>((letter&amp;(<span class="hljs-number">1</span>&lt;&lt;l))!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> s.charAt(i);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                letter=letter|<span class="hljs-number">1</span>&lt;&lt;l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 11</title>
    <link href="/posts/43427.html"/>
    <url>/posts/43427.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><a href="https://leetcode.cn/problems/container-with-most-water/">题目链接11. 盛最多水的容器 - 力扣（LeetCode）</a></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li><p>拿过来一看，最先想到的就是暴力解法，两层for循环遍历，寻找最大元素，但作为中等题，果然是超时的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;left&lt;height.length-<span class="hljs-number">1</span>;left++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=left+<span class="hljs-number">1</span>;right&lt;height.length;right++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span>(height[right]&gt;height[left]?height[left]:height[right])*(right-left);<br>                max=max&gt;tmp?max:tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>暴力不行，然后考虑采用其他方式，按照提示，考虑采用双指针，分别指向开头和结尾，从两边向中间缩，但怎么移动指针是关键，面积是容器底[1]*两边中较小的一方[2]，底随着移动不断缩小，因此只有增大[2]，短板效应，需要将[2]中较小的一方扩大，才能扩大，因此较小的一方移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> tmp=(height[right]&gt;height[left]?height[left]:height[right])*(right-left);<br>            max=max&gt;tmp?max:tmp;<br>            <span class="hljs-keyword">if</span>(height[right]&gt;height[left])&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坦格利安家族人物关系</title>
    <link href="/posts/9659.html"/>
    <url>/posts/9659.html</url>
    
    <content type="html"><![CDATA[<h1 id="龙之家族人物关系"><a href="#龙之家族人物关系" class="headerlink" title="龙之家族人物关系"></a>龙之家族人物关系</h1><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215241372.png" alt="image-20221211215241372"  /><blockquote><p>最近在追剧权游前传-《龙之家族》，看了第一季之后意犹未尽，索性找来原著小说，原著中龙家的关系比较复杂，所以画个个图方便自己屡清关系（hh，看小说还记笔记）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="流程图"></p><p>图为截止坦格利安王朝史·第一卷的坦格利安家族的主要人物关系</p><p>其中人物名字上方为其所御之龙的名字</p><p>红色箭头代表七大王国的王位继承顺序</p><h3 id="放几张剧照吧"><a href="#放几张剧照吧" class="headerlink" title="放几张剧照吧"></a>放几张剧照吧</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215410115.png" alt="image-20221211215410115"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215446184.png" alt="image-20221211215446184"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215508154.png" alt="image-20221211215508154"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215602968.png" alt="image-20221211215602968"></p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://weread.qq.com/book-detail?type=1&senderVid=328921405&v=02f325c071aebcf302f6772&wtheme=white&wfrom=app&wvid=328921405&scene=bottomSheetShare">血与火：坦格利安王朝史·第一卷（HBO 热播剧《龙之家族》影视原著小说，奇幻巨著冰与火之歌前传）》乔治·R.R.马丁</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/posts/953.html"/>
    <url>/posts/953.html</url>
    
    <content type="html"><![CDATA[<h2 id="git常用命令总结"><a href="#git常用命令总结" class="headerlink" title="git常用命令总结"></a>git常用命令总结</h2><blockquote><p>总结我常用的git命令，不然每次想不起来了还要去找</p><p>持续更新…</p></blockquote><ul><li>git add ：添加文件到缓存，常用git add . 添加所有文件夹</li><li>git status ：查看项目内文件的状态</li><li>git stash : 暂存当前的修改（不能保存为追踪文件，如新建文件）</li><li>git stash pop : 将暂存文件恢复，与git stash 配合使用</li><li>git diff ：查看未缓存的更改</li><li>git commit ：提交命令，<ul><li>常用git commit -m “update内容”</li><li>偷懒可以git commit -am “update内容”，这样不需要每次都add</li></ul></li><li>git push originname a:b ：将本地的a分支推送到originname 的b上去</li><li>git pull originname a ：将远程originname分支的a拉取到本地当前分支上</li><li>git reset –hard “commitID” ：回退到某个版本</li><li>git reset HEAD test.txt ：取消已缓存的test.txt文件</li><li>git branch ：查看本地的分支<ul><li>git branch newbranch ：创建分支newbranch</li></ul></li><li>git checkout branchname：切换到branchname 分支</li><li>git merge branchname ：将任意分支合并到到当前分支中</li><li>git branch -d branchname)：删除某个分支</li><li>git remote add urlname urllink：添加新的远程仓库地址，一般一个项目托管到不同平台用得到</li><li>git remote：查看当前的远程仓库</li><li>git merge –abort ：取消merging状态</li><li>git checkout -b newbranch origin&#x2F;abranch ：从远程分支abranch创建本地新分支newbranch</li><li>git fetch –all : 拉取远程仓库的所有数据，包括更新的分支和提交</li><li>git fetch <remote-name> : 只想更新特定的远程仓库</li><li>git push origin_name -d branch_name：删除远程分支</li><li>git branch -d branch_name： 删除本地分支</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>酒香归纳</title>
    <link href="/posts/57461.html"/>
    <url>/posts/57461.html</url>
    
    <content type="html"><![CDATA[<h2 id="酒香归纳"><a href="#酒香归纳" class="headerlink" title="酒香归纳"></a>酒香归纳</h2><blockquote><p>偶尔会接触一些酒，但总是听说各种香型，但都没太深的了解，这里先记录一下，以后有机会都尝一尝</p></blockquote><h3 id="香型及其特征"><a href="#香型及其特征" class="headerlink" title="香型及其特征"></a>香型及其特征</h3><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127182513378.png" alt="image-20221127182513378" style="zoom:50%;" /><h3 id="各香型代表酒"><a href="#各香型代表酒" class="headerlink" title="各香型代表酒"></a>各香型代表酒</h3><ul><li>酱香型 茅台</li><li>清香型 汾酒<ul><li>42度的汾酒喝了半斤，入口微微辣，第二天上午也迷瞪的</li></ul></li><li>浓香型 五粮液、泸州老窖、剑南春<ul><li>泸州老窖52度喝了塑料杯一杯半，入口比较辣，晚上感觉浑身暖和，第二天毫无感觉</li></ul></li><li>凤香型 西凤酒<ul><li>45度西凤酒喝了三两，过了太久，记不得啥情况了</li></ul></li><li>董香型&#x2F;药香型 董酒</li><li>米香型&#x2F;蜜香型 桂林三花</li><li>芝麻香型 景芝酒</li><li>豉香型 佛山石湾玉冰烧</li><li>兼香型也叫浓酱兼香型白酒 白云边<ul><li>喝了两塑料杯53度白云边，酒比较好入口，第二天早上起来微微有点头疼</li></ul></li><li>老白干 衡水老白干</li><li>馥郁香 酒鬼酒</li><li>特香型</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>非技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动部署hexo博客</title>
    <link href="/posts/32022.html"/>
    <url>/posts/32022.html</url>
    
    <content type="html"><![CDATA[<h2 id="懒人脚本"><a href="#懒人脚本" class="headerlink" title="懒人脚本"></a>懒人脚本</h2><p>每次写完博客，都要输入一串机械化的命令，很无聊，索性写个bat脚本，具体内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">@<span class="hljs-built_in">echo</span> off<br>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source&amp;&amp;<span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>然后以bat的格式保存在博客目录下，点击执行即可（比如这篇博客就是这么发布的）</p><h4 id="指令解释："><a href="#指令解释：" class="headerlink" title="指令解释："></a>指令解释：</h4><ol><li><code>@echo off</code> ：关闭cmd指令的回显</li><li><code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code> ：hexo的指令，分别是：<ol><li><code>hexo clean</code>：清除缓存文件 <code>db.json</code> 和已生成的静态文件 <code>public</code></li><li><code>hexo g</code>：生成网站静态文件到默认设置的 <code>public</code> 文件夹</li><li><code>hexo d</code>：自动生成网站静态文件，并部署到设定的仓库</li></ol></li><li><code>git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source</code>，是git指令</li><li><code>pause</code>：暂停执行的语句</li></ol><blockquote><p>其中的远程仓库分支source是github的项目分支之一，hexo里设置在<code>hexo d</code>后将代码部署到master分支中，我设置了source分支用来保存其他代码（当然不包括一些静态代码和node的代码），防止换了设备之后会丢失内容</p><p>方便好用，强烈推荐</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实时调度器</title>
    <link href="/posts/46423.html"/>
    <url>/posts/46423.html</url>
    
    <content type="html"><![CDATA[<h2 id="LINUX调度器关系图"><a href="#LINUX调度器关系图" class="headerlink" title="LINUX调度器关系图"></a>LINUX调度器关系图</h2><blockquote><p>所谓调度，就是按照某种调度的算法，从<strong>进程的就绪队列中选取进程分配CPU</strong>，主要是协调对CPU等的资源使用。进程调度的目标是最大限度利用CPU时间</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127111427338.png" alt="image-20221127111427338" style="zoom: 33%;" /><p>linux里的调度器</p><p><code>RT调度器， rt_sched_class</code>：实时调度器，为每个优先级维护一个队列</p><p><code>CFS调度器， cfs_sched_class</code>：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念，采用红黑树实现进程实体的存放；</p><h2 id="调度策略FIFO、RR"><a href="#调度策略FIFO、RR" class="headerlink" title="调度策略FIFO、RR"></a>调度策略FIFO、RR</h2><p>linux的进程分为两大类：<strong>实施进程和普通进程</strong></p><p>二者的根本不同在于：如果系统中有一个实时进程可以运行，那么调度器总是会选择它，除非另有一个优先级更高的实时进程</p><p><strong>实时进程</strong>分为两种策略进行调度：</p><p><strong>SCHED_FIFO：</strong>没有时间片，在被调度器选择之后，可以运行任意长时间。</p><p><strong>SCHED_RR：</strong>有时间片，其值在进程运行时会减少。在所有的时间段都到期后，则该值重置为初始值，而进程则置于队列末尾。这确保了在有几个优先级相同的SCHED_RR进程的情况下，它们总是依次执行。</p><h2 id="runqueue-运行队列"><a href="#runqueue-运行队列" class="headerlink" title="runqueue 运行队列"></a>runqueue 运行队列</h2><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/asynccode" alt="img" style="zoom:50%;" /><ul><li><p>每个CPU都有一个运行队列，每个调度器都作用于运行队列；</p></li><li><p>分配给CPU的task，作为调度实体加入到运行队列中；</p></li></ul><p><strong>rt_rq的结构</strong></p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127111507059.png" alt="image-20221127111507059" style="zoom: 33%;" /><blockquote><p>这里每一个CPU的运行队列rq内都有一个实时进程运行队列rt_rq，制定了优先级链表，链表个数为优先级个数，每个链表存放对应就绪状态的进程实体</p></blockquote><h2 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h2><ol><li>enqueue_task_rt(struct rq *rq, struct process_control_block *p, int flags)</li></ol><blockquote><p>将进程添加到对应rt_rq的优先级的队列中去</p></blockquote><ol><li>dequeue_task_rt(struct rq *rq, struct process_control_block *p, int flags)</li></ol><blockquote><p>从rt_rq的优先级队列中取出某一个进程</p></blockquote><ol><li>pick_next_task_rt()</li></ol><blockquote><p>从优先级队列中取出当前优先级最高的进程</p></blockquote><ol><li>sched_rt()</li></ol><blockquote><ul><li><p>此函数是进程调度的核心函数</p></li><li><p>核心逻辑：选择另一个进程来替换掉当前的运行进程。具体替换进程的选择是通过pick_next_task_rt()函数来实现的</p></li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127111532683.png" alt="image-20221127111532683" style="zoom: 67%;" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.man7.org/linux/man-pages/man7/sched.7.html">sched(7) - Linux manual page (man7.org)</a></p><p><a href="https://www.cnblogs.com/LoyenWang/p/12249106.html">【原创】（一）Linux进程调度器-基础 - LoyenWang - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/arnoldlu/p/9025981.html">Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验 - ArnoldLu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/hellokitty2/p/14199741.html">RT调度学习笔记（1） - Hello-World3 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/sucjhwaxp/article/details/106602613">(15条消息) Kernel Scheduler学习之五：RT 调度器_sucjhwaxp的博客-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实时调度器</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>市场体制下企业定价方法</title>
    <link href="/posts/25422.html"/>
    <url>/posts/25422.html</url>
    
    <content type="html"><![CDATA[<p>在市场经济中，卖方才有定价权，因此需要考虑主要价格制定与变动的是卖方</p><p>现有的企业定价方式有三类：成本导向、需求导向和竞争导向</p><h3 id="一、成本导向定价法"><a href="#一、成本导向定价法" class="headerlink" title="一、成本导向定价法"></a><strong>一、成本导向定价法</strong></h3><blockquote><p>以营销产品的成本为主要依据制定价格的方法统称为成本导向定价法,这是最简单、应用相当广泛的一种定价方法。</p></blockquote><ol><li><p>**总成本定价法:**成本加成,目标利润</p><ol><li>成本加成定价法（cost-plus pricing），即按产品单位成本加上一定比例的毛利定出销售价。 　其计算公式为：P&#x3D;c×(1+r) 　P—商品的单价 　c—商品的单位总成本 　r—商品的加成率</li><li>目标利润定价法，是根据企业总成本和预期销售量，确定一个目标利润率，并以次作为定价的标准。 　其计算公式为：单位商品价格&#x3D;总成本×（1+目标利润率）&#x2F; 预计销量</li></ol><p> 　　</p></li><li><p><strong>边际成本定价法：</strong>边际成本是企业每增以单位产品所必须支付的成本，采用这种方式暂不考虑固定成本，以边际成本加一定的利润作为最终价格，可以帮助企业迅速打开市场。</p></li><li><p><strong>盈亏平衡定价</strong>：考虑到销售额变化后，成本也在发生变化，这种方法是运用损益平衡原理实行的一种保本定价法。 　其公式是： 　盈亏平衡点销售量&#x3D;固定成本&#x2F;单位—单位变动成本 　盈亏平衡点销售额&#x3D;固定成本&#x2F;1—单位变动成本率</p></li></ol><h3 id="二、需求导向定价法"><a href="#二、需求导向定价法" class="headerlink" title="二、需求导向定价法"></a><strong>二、需求导向定价法</strong></h3><blockquote><p>需求导向定价法是指根据市场需求状况和消费者对产品的感觉差异来确定价格的定价方法。 它包括以下三种</p></blockquote><ol><li><p><strong>认知导向定价法：</strong>是根据消费者对企业提供的产品价值的主观评判来制定价格的一种定价方法。</p></li><li><p><strong>逆向定价法：</strong>它是指依据消费者能够接受的最终销售价格，考虑中间商的成本及正常利润后，逆向推算出中间商的批发价和生产企业的出产价格。 　可通过公式计算价格：出厂价格&#x3D;市场可零售价格×（1—批零差率）×（1—进销差率）</p></li><li><p><strong>习惯定价法：</strong>是按照市场长期以来行成的习惯价格定价。</p></li></ol><h3 id="三、竞争导向定价法"><a href="#三、竞争导向定价法" class="headerlink" title="三、竞争导向定价法"></a><strong>三、竞争导向定价法</strong></h3><blockquote><p>竞争导向定价法是企业通过研究竞争对手的生产条件、服务状况、价格水平等因素，依据自身的竞争实力，参考成本和供求状况来确定商品价格。以市场上竞争者的类似产品的价格作为本企业产品定价的参照系的一种定价方法 这种定价方法主要有3方面特点。竞争导向定价主要包括随行就市定价法、产品差别定价法和密封投标定价法。</p></blockquote><ol><li><p>**随行就市定价法:**在垄断竞争和完全竞争的市场结构条件下，任何一家企业都无法凭借自己的实力而在市场上取得绝对的优势，为了避免竞争特别是价格竞争带来的损失，大多数企业都采用随行就市定价法，即将本企业某产品价格保持在市场平均价格水平上，利用这样的价格来获得平均报酬。此外，采用随行就市定价法，企业就不必去全面了解消费者对不同价差的反应，也不会引起价格波动。</p></li><li><p>**产品差别定价法:**产品差别定价法是指企业通过不同营销努力，使同种同质的产品在消费者心目中树立起不同的产品形象，进而根据自身特点，选取低于或高于竞争者的价格作为本企业产品价格。因此，产品差别定价法是一种进攻性的定价方法。</p></li><li><p>**密封投标定价法:**在国内外，许多大宗商品、原材料、成套设备和建筑工程项目的买卖和承包、以及出售小型企业等，往往采用发包人招标、承包人投标的方式来选择承包者，确定最终承包价格。一般来说，招标方只有一个，处于相对垄断地位，而投标方有多个，处于相互竞争地位。标的物的价格由参与投标的各个企业在相互独立的条件下来确定。在买方招标的所有投标者中，报价最低的投标者通常中标，它的报价就是承包价格。这样一种竞争性的定价方法就称密封投标定价法。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>市场经济</tag>
      
      <tag>定价方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化问题</title>
    <link href="/posts/31098.html"/>
    <url>/posts/31098.html</url>
    
    <content type="html"><![CDATA[<h1 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h1><p>定义：在给定的约束条件下，选择最优的参数和方案，使得目标函数最大化&#x2F;最小化的问题</p><p>分类：</p><ul><li>根据约束条件不同，分为<ul><li>无约束问题</li><li>约束最优问题<ul><li>等式约束最优问题</li><li>不等式约束最优问题</li><li>混合约束优化问题</li></ul></li></ul></li><li>根据目标函数的状态，分为<ul><li>连续最优化问题：决策变量取值连续<ul><li>光滑最优化问题：函数连续可微<ul><li>线性规划</li><li>非线性规划</li></ul></li><li>非光滑优化</li></ul></li><li>离散最优化问题：决策标量取值离散<ul><li>整数规划、资源配置、油路问题生产安排等</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>最优化问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks</title>
    <link href="/posts/40422.html"/>
    <url>/posts/40422.html</url>
    
    <content type="html"><![CDATA[<h3 id="Coding-based-Distributed-Data-Shufflfling-for-Low-Communication-Cost-in-DataCenter-Networks"><a href="#Coding-based-Distributed-Data-Shufflfling-for-Low-Communication-Cost-in-DataCenter-Networks" class="headerlink" title="Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks"></a>Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks</h3><h3 id="基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌"><a href="#基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌" class="headerlink" title="基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌"></a>基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>分布式机器学习框架在实际使用中依然存在许多挑战与问题，训练数据样本分布和训练数据样本输入顺序是影响机器学习模型收敛效果的重要因素。全局数据重排能够为分布式机器学习提供更接近于单机的机器学习的数据重排效果。然而其会带来巨大的网络开销</p><p>为了让全局数据重排能够应用到实际的分布式机器学习中，目前存在一些使用编码的方法来降低其网络资源开销。</p><p>但目前的基于编码的网络传输优化方法都假设存在一台拥有无限存储能力的机器<br>存储了整个训练样本集中的所有样本，并且由这台机器负责所有样本数据的发送工作，<br>而其他机器不具备发送数据的功能。</p><h3 id="系统模型和问题制定"><a href="#系统模型和问题制定" class="headerlink" title="系统模型和问题制定"></a>系统模型和问题制定</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195221509.png" alt="image-20220724195221509"></p><p>基于上述模型优化</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195252224.png" alt="image-20220724195252224"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195300494.png" alt="image-20220724195300494"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195308972.png" alt="image-20220724195308972"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195316646.png" alt="image-20220724195316646"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195326229.png" alt="image-20220724195326229"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195336124.png" alt="image-20220724195336124"></p><h3 id="方法制定"><a href="#方法制定" class="headerlink" title="方法制定"></a>方法制定</h3><p>Distributed Coded Shuffling（DCS算法）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195407995.png" alt="image-20220724195407995"></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>算力网络</tag>
      
      <tag>边缘博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摩斯电码快速记忆</title>
    <link href="/posts/58667.html"/>
    <url>/posts/58667.html</url>
    
    <content type="html"><![CDATA[<h3 id="摩斯电码快速记忆"><a href="#摩斯电码快速记忆" class="headerlink" title="摩斯电码快速记忆"></a>摩斯电码快速记忆</h3><p>之前无聊的时候翻知乎，看到一个有关摩斯电码的讨论，感觉其中一个回答对记忆莫斯电码十分有帮助，在这里分享下</p><h4 id="原电码表"><a href="#原电码表" class="headerlink" title="原电码表"></a>原电码表</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724150944205.png" alt="image-20220724150944205"></p><h4 id="通过图像记忆"><a href="#通过图像记忆" class="headerlink" title="通过图像记忆"></a>通过图像记忆</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724151014928.png" alt="image-20220724151014928"></p><p>有那么两天我甚至感觉自己精通了，勤加练习不难</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摩斯电码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments</title>
    <link href="/posts/37834.html"/>
    <url>/posts/37834.html</url>
    
    <content type="html"><![CDATA[<h3 id="Partitioning-Stateful-Data-Stream-Applications-in-Dynamic-Edge-Cloud-Environments"><a href="#Partitioning-Stateful-Data-Stream-Applications-in-Dynamic-Edge-Cloud-Environments" class="headerlink" title="Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments"></a>Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments</h3><h3 id="动态边缘云环境下的有状态数据流应用的划分"><a href="#动态边缘云环境下的有状态数据流应用的划分" class="headerlink" title="动态边缘云环境下的有状态数据流应用的划分"></a>动态边缘云环境下的有状态数据流应用的划分</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>计算分区是一种通过选择性地将一些计算从移动设备卸载到附近的边缘云来提高应用程序性能的重要技术。在动态环境中，边缘云的网络带宽可能会频繁变化，计算的划分需要相应地更新。分区的频繁更新导致了移动端和边缘云之间的高状态迁移成本。但是，现有的工作没有考虑状态迁移开销。因此，分区决策可能会导致重大的拥塞控制，并极大地增加整体完成时间。本文在考虑状态迁移开销的基础上，提出了一套基于网络带宽变化的分区更新算法。据我们所知，<strong>这是第一个针对动态环境中的有状态数据流应用程序进行计算分区的工作。这些算法旨在通过在动态边缘云环境中选择性迁移状态来减轻拥塞控制和最小化制造跨度</strong>。大量的仿真结果表明，该算法不仅可以选择性地迁移状态，而且在生成时间方面优于其他经典的基准算法。所提出的模型和算法将丰富有状态任务的调度理论，这是以前从未有过的研究。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>边缘计算是使云计算技术能够从传统的互联网数据中心到网络边缘进行低延迟数据访问和实时数据处理[7]。作为边缘计算资源的抽象，边缘云通常分布在离终端用户较近的地方，如蜂窝基站和无线局域网。边缘计算的一般形式包括 Cloudlets [9]和 Foglets [10] ，甚至还有一小群有限的设备[8]。与传统的云数据中心相比，边缘云更轻量级，资源受限[11]。随着边缘云在当今网络基础设施中的部署越来越多，计算分区被认为是一种有效的技术，通过选择性地将一些计算从移动设备卸载到附近的边缘云[4][12][18]来提高移动应用程序的性能</p><p>为了达到不同的目的，在计算分区方面存在许多相关的工作，比如减少执行时间，节省终端设备的能源消耗，以及云的数据传输开销。这些工作对应用程序有不同的建模方法。典型的应用程序模型包括面向过程程序的方法调用树、面向服务应用程序的服务调用图和面向数据流应用程序的数据流图。&#x2F;n在这些类型的应用程序中，数据流应用程序越来越受到关注，例如扩增实境和目标跟踪。应用程序由一组功能模块组成，数据流通过这些模块。数据流应用程序的分区旨在为每个传入的数据帧决定哪些函数在本地执行，哪些函数在边缘云中执行[4][12]。但是，现有的工作不考虑有状态数据流应用程序的分区。如果数据流应用程序包含有状态函数模块，我们将其定义为有状态应用程序。通过状态函数模块，如果一个数据帧流经它，那么在处理该模块的设备上将留下一个“足迹”。这个“内存占用”(也由状态命名)是下一个数据帧的处理所需要的。许多应用程序(如对象跟踪)都属于有状态应用程序。</p><p>对有状态数据流应用程序进行分区非常具有挑战性，尤其是在动态边缘云环境中，在这种环境中，到边缘云的网络连接经常发生变化，甚至可能发生断开连接。由于网络连接的动态性，应用程序的划分需要相应地更新，这将导致移动设备和边缘云之间的状态迁移。因此，我们需要通过选择性迁移状态来划分计算，以减轻网络拥塞。现有的计算划分工作考虑了应用程序的无状态功能模块。当它们应用于有状态应用程序的分区时，网络中会出现较高的状态迁移开销，这可能导致拥塞控制和应用程序的长时间完成。这就是为什么我们需要为有状态应用程序的分区特别设计新的方法，旨在平衡良好的分区和低完成时间以及网络上额外的状态迁移时间。</p><p>在本文中，我们开发了一套有效的算法来解决有状态数据流应用程序的划分问题，目的是通过选择性迁移 ing 状态来减少拥塞控制和最小化使用时间。特别地，我们设计了一种新的算法，即基于得分矩阵的启发式算法(SM-H)来解决一次性问题，该算法在边缘网络环境改变时更新当前到达数据帧的划分。SM-H 采用矩阵形式记录调整各模块执行位置的效益得分，然后始终选择得分最大的模块进行调整。调整是迭代进行的，直到没有一个模块得到正分，这意味着调整任何一个模块将导致完成时间的增加。在一次性 SM-H 算法的基础上，进一步推广到解决多步骤的分区问题。</p><p>我们通过大量的仿真对提出的算法进行评估，并将它们与几种基准方法进行比较，包括顺序调整(一种幼稚的贪婪启发式方法)、列表调度(一种经典的并行和分布式计算调度方法)、遗传算法等。结果表明，所提出的算法在制作跨度方面优于基准算法。我们将本文的贡献总结如下。</p><p>•据我们所知，我们是第一个研究有状态数据流应用程序分区问题的人。这些问题模型可以推广到分布式处理器上的有状态任务调度，这是目前在任务调度领域尚未研究的问题。&#x2F;n</p><p>•我们开发了一种新算法来划分有状态数据流应用程序。该算法丰富了有状态应用任务的调度理论和方法。&#x2F;n</p><p>•我们通过广泛的仿真对提出的算法进行了评估，结果表明，提出的 SM-H 算法在制作跨度方面优于基准算法。</p><h4 id="系统模型和问题制定"><a href="#系统模型和问题制定" class="headerlink" title="系统模型和问题制定"></a>系统模型和问题制定</h4><p>定义决策变量表示分配给状态迁移、网络传输的网络带宽，将最小化make-span制定为目标并表示，限制模块之间的依赖性定义，从而定义对状态迁移的限制、对网络带宽的限制</p><p>最终形成有状态的数据流应用程序计算分区问题(SCPP)，</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>算力网络</tag>
      
      <tag>边缘博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于博弈论的云/边缘计算资源分配与优化算法及应用</title>
    <link href="/posts/23505.html"/>
    <url>/posts/23505.html</url>
    
    <content type="html"><![CDATA[<h1 id="基于博弈论的云-x2F-边缘计算资源分配与优化算法及应用"><a href="#基于博弈论的云-x2F-边缘计算资源分配与优化算法及应用" class="headerlink" title="基于博弈论的云&#x2F;边缘计算资源分配与优化算法及应用"></a>基于博弈论的云&#x2F;边缘计算资源分配与优化算法及应用</h1><blockquote><p>作者：胡俊艳 湖南大学 博士毕业论文</p></blockquote><h2 id="论文创新点"><a href="#论文创新点" class="headerlink" title="论文创新点"></a>论文创新点</h2><ol><li>基于非合作博弈的多属性云计算资源竞价算法</li><li>时间约束感知的云计算资源联合采购博弈论方法</li><li>基于博弈论的边缘计算任务卸载算法</li></ol><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用户在意的是QoS，最小成本和最大收益问题，比如响应时间、可靠性、任务的完成时间、资源定价等，</p><p>云提供商的主要效益 需要考虑节约能耗、负载均衡等因素，这对减小开销、合理配置资源、提高资源利用率和服务质量有重要意义</p><p>无论是云环境还是边环境，都存在资源配置和资源优化问题、尽最大努力改善用户的服务质量和用户体验，降低系统的运行成本问题。因此本文采用了博弈论方法来研究在云&#x2F;边环境下的计算资源的分配优化配置方法</p><blockquote><p>由于文章其他内容与我的研究点“算力网络的多方利益均衡”不同，所以没做记录</p></blockquote><h2 id="基于非合作博弈的多属性云计算资源竞价算法"><a href="#基于非合作博弈的多属性云计算资源竞价算法" class="headerlink" title="基于非合作博弈的多属性云计算资源竞价算法"></a>基于非合作博弈的多属性云计算资源竞价算法</h2><h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><p>针对云计算中多属性资源供应问题，提出一种<strong>基于非合作博弈关于云用户和提供商组成的利润最大化的价格竞价算法</strong>，提出一种新颖的关于服务质量和竞价的激励性资源购买模型。</p><p>然后结合用户的资源购买模型，将提供商的价格竞价问题转化为一个博弈模型来为每个云提供商找到合适的价格。</p><p>通过假设每个提供商提供的资源的数量函数是连续的，证明了针对已制定的博弈模型的纳什均衡解集的存在。</p><p>为了找到纳什均衡解，提出了一种均衡迭代算法，该算法被证明可以收敛到纳什均衡。</p><p>最后提出了一种近均衡价格竞价算法，对获得的纳什均衡解进行修正</p><h3 id="多属性云资源价格竞价系统模型"><a href="#多属性云资源价格竞价系统模型" class="headerlink" title="多属性云资源价格竞价系统模型"></a>多属性云资源价格竞价系统模型</h3><h4 id="云资源供应的参与者"><a href="#云资源供应的参与者" class="headerlink" title="云资源供应的参与者"></a>云资源供应的参与者</h4><p>将多用户和多提供商的情况并行化为<strong>一个用户和多个提供商的情况</strong></p><p>3个CPs（提供商）构成一个资源组，2的3次方个方案（这里的方案只是确定CPi是否提供资源，具体提供多少未知）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724155121067.png" alt="image-20220724155121067"></p><h4 id="云用户对多属性云资源的评估"><a href="#云用户对多属性云资源的评估" class="headerlink" title="云用户对多属性云资源的评估"></a>云用户对多属性云资源的评估</h4><p>用户的属性偏好</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724171032448.png" alt="image-20220724171032448"></p><p>其中 用户的资源属性偏好</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724171333310.png" alt="image-20220724171333310"></p><h4 id="云用户的云资源购买机制"><a href="#云用户的云资源购买机制" class="headerlink" title="云用户的云资源购买机制"></a>云用户的云资源购买机制</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724192555620.png" alt="image-20220724192555620"></p><h2 id="文章题目：移动边缘计算中基于博弈论的资源分配技术研究"><a href="#文章题目：移动边缘计算中基于博弈论的资源分配技术研究" class="headerlink" title="文章题目：移动边缘计算中基于博弈论的资源分配技术研究"></a>文章题目：移动边缘计算中基于博弈论的资源分配技术研究</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>基于不完全合同的资源所有权分配算法设计<ol><li>有关不同所有权分配下的最优投资，最大化运营商部门效用函数（针对运营商）</li></ol></li><li>基于匹配理论的基站资源分配算法设计<ol><li>添加考虑基站，将基站作为边缘节点，优化系统整体资源分配效益，用户希望选择损失最小的基站（基站分为欠载基站、满载基站、过载基站）。考虑了小基站网络中用户到基站的任务迁移以及基站共同协作处理任务量的模型</li></ol></li><li>基于联合博弈的动态资源分配算法设计<ol><li>针对边缘计算节点的租用（基于匹配理论）以及计算服务提供商与用户之间的节点拍卖问题（拍卖理论与强化学习理论结合）</li><li>网络模型<ol><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220726091144358.png" alt="image-20220726091144358"></li><li></li></ol></li></ol></li></ol><h2 id="文章题目：基于任务特性的公有云资源交易机制"><a href="#文章题目：基于任务特性的公有云资源交易机制" class="headerlink" title="文章题目：基于任务特性的公有云资源交易机制"></a>文章题目：基于任务特性的公有云资源交易机制</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ol><li>缓解资源需求峰值的任务调度策略和计价机制<ol><li></li></ol></li></ol><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul><li>MEC中的资源分配问题主要有：<ol><li>通信资源分配，根据无线系统环境，高效地分配通信资源，优化传输效率，降低用户间的干扰；</li><li>计算资源分配，根据用户的任务需求，有效地分配计算资源，最小化任务时延和能耗，提高卸载效率；</li><li>存储资源分配，根据用户的存储需求，分配对应的存储资源，避免用户存储空间不足引发的设备卡顿，提升用户 QoE。</li></ol></li><li>当前对 MEC 资源分配方法的研究大致从两个方面进行：技术层面和经济层面<ul><li>技术：计算卸载</li><li>经济：而经济层面不仅需要考虑如何分配资源，更需要考虑市场竞争性。用户不仅需要评估资源出价，更需要考虑向哪个服务器购买资源，以使自身效益最大化。因此，经济层面的资源分配问题计算复杂度大，综合管理更加复杂。对此，研究者一般采用&#x3D;&#x3D;动态分布式算法、拍卖、博弈&#x3D;&#x3D;等经济分析方法求解</li><li></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>算力网络</tag>
      
      <tag>边缘博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git merge与git pull的区别</title>
    <link href="/posts/23828.html"/>
    <url>/posts/23828.html</url>
    
    <content type="html"><![CDATA[<h3 id="使用GitHubPages-jekyll搭建博客平台"><a href="#使用GitHubPages-jekyll搭建博客平台" class="headerlink" title="使用GitHubPages+jekyll搭建博客平台"></a>使用GitHubPages+jekyll搭建博客平台</h3><h3 id="git-merge与git-pull的区别"><a href="#git-merge与git-pull的区别" class="headerlink" title="git merge与git pull的区别"></a>git merge与git pull的区别</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近做项目的时候使用git，遇到一个情形：</p><p>在本地自己的分支开发的时候，主分支合并了其他人的工作，此时需要将主分支的代码合并过来，一直使用的是git pull origin main命令，如果有他人合并的工作与我本地工作有冲突，需要自己处理对应冲突</p><p>今天偶然看到其他的做法是git pull origin main main，然后git merge main mybranch，发现这也是种实现方式</p><p>于是乎开始查这两种做法的区别</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>直接将origin的分支与本地当前分支合并，会将过程都隐藏起来，</p><p>遇到冲突解决</p><h4 id="git-fetch-git-merge"><a href="#git-fetch-git-merge" class="headerlink" title="git fetch+ git merge"></a>git fetch+ git merge</h4><p>git fetch origin main 将远程仓库中的最新代码拉回，</p><p>git merge origin&#x2F;main 把本地代码和已取得的main代码合并</p><p>遇到冲突去解决</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>网上很多文章都推荐使用fetch+merge，因为pull会直接更改你的工作，你不了解具体更改了什么</p><p>但如果使用了IDE，现在的IDE都集成了冲突处理功能，所以我觉着使用pull也问题不大</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>merge</tag>
      
      <tag>pull</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC学习笔记</title>
    <link href="/posts/60381.html"/>
    <url>/posts/60381.html</url>
    
    <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="技术体系"><a href="#技术体系" class="headerlink" title="技术体系"></a>技术体系</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220511151328240.png" alt="image-20220511151328240"></p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220511193455866.png" alt="image-20220511193455866"></p><blockquote><p>JDBC由java官方定义的一组标准：接口；对应各个数据库厂商实现对应的方法即驱动</p><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</p></blockquote><ul><li><p>在使用JDBC情况下访问数据库</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220525143030809.png" alt="image-20220525143030809"></p></li></ul><h4 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220511194633369.png" alt="image-20220511194633369"></p><h3 id="二、获取数据库连接"><a href="#二、获取数据库连接" class="headerlink" title="二、获取数据库连接"></a>二、获取数据库连接</h3><blockquote><p>方式一到五，1-4作为过程存在，了解即可</p></blockquote><ul><li><p>方式五</p><ul><li>&#96;&#96;&#96;java<br>&#x2F;**<br> * 获取数据库连接<br> * @return<br> * @throws Exception<br> *&#x2F;<br>public static Connection getConnection() throws Exception {<br>&#x2F;&#x2F;        读取配置文件信息<br>    InputStream ips &#x3D; ClassLoader.getSystemClassLoader().getResourceAsStream(“jdbc.properties”);<br>    Properties pros&#x3D;new Properties();<br>    pros.load(ips);<br>    String user &#x3D; pros.getProperty(“user”);<br>    String password &#x3D; pros.getProperty(“password”);<br>    String url &#x3D; pros.getProperty(“url”);<br>    String driverClass &#x3D; pros.getProperty(“driverClass”);<br>&#x2F;&#x2F;        2.加载驱动<br>    Class.forName(driverClass);<br>&#x2F;&#x2F;        3.连接<br>    Connection conn &#x3D; DriverManager.getConnection(url, user, password);<br>    System.out.println(conn);<br>    return conn;<br>}<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- 配置文件jdbc.properties存放在src下<br><br>  - ```xml<br>        <span class="hljs-attribute">user</span>=root<br>        <span class="hljs-attribute">password</span>=123456<br>        <span class="hljs-attribute">url</span>=jdbc:mysql://localhost:3306/test?serverTimezone=GMT<br>        <span class="hljs-attribute">driverClass</span>=com.mysql.cj.jdbc.Driver<br>    <br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三、JDBCUtils-java"><a href="#三、JDBCUtils-java" class="headerlink" title="三、JDBCUtils.java"></a>三、JDBCUtils.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> utils;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 操作数据库的工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtils</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取数据库连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//        读取配置文件信息</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">ips</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>        Properties pros=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        pros.load(ips);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> pros.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> pros.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> pros.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">driverClass</span> <span class="hljs-operator">=</span> pros.getProperty(<span class="hljs-string">&quot;driverClass&quot;</span>);<br><span class="hljs-comment">//        2.加载驱动</span><br>        Class.forName(driverClass);<br><span class="hljs-comment">//        3.连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);<br>        System.out.println(conn);<br>        <span class="hljs-keyword">return</span> conn;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接和statement操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ps</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeResource</span><span class="hljs-params">(Connection conn, Statement ps)</span>&#123;<br>        <span class="hljs-comment">//        资源关闭</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(ps!=<span class="hljs-literal">null</span>)&#123;<br>                ps.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(conn!=<span class="hljs-literal">null</span>)&#123;<br>                conn.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeResource</span><span class="hljs-params">(Connection conn, Statement ps, ResultSet rs)</span>&#123;<br>        <span class="hljs-comment">//        资源关闭</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(ps!=<span class="hljs-literal">null</span>)&#123;<br>                ps.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(conn!=<span class="hljs-literal">null</span>)&#123;<br>                conn.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(rs!=<span class="hljs-literal">null</span>)&#123;<br>                rs.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><span class="hljs-comment">//    使用dbutils提供的close关闭数据库资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeResource1</span><span class="hljs-params">(Connection conn, Statement ps, ResultSet rs)</span>&#123;<br>        DbUtils.closeQuietly(conn);<br>        DbUtils.closeQuietly(ps);<br>        DbUtils.closeQuietly(rs);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="四、使用preparedStatement实现CRUD"><a href="#四、使用preparedStatement实现CRUD" class="headerlink" title="四、使用preparedStatement实现CRUD"></a>四、使用preparedStatement实现CRUD</h3><h4 id="4-1-使用statement的问题"><a href="#4-1-使用statement的问题" class="headerlink" title="4.1 使用statement的问题"></a>4.1 使用statement的问题</h4><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong><ul><li>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</li></ul></li><li>无法操作Blob类型数据</li><li>实现批量插入时，效率较低</li></ul><h4 id="4-2-使用preparestatement"><a href="#4-2-使用preparestatement" class="headerlink" title="4.2 使用preparestatement"></a>4.2 使用preparestatement</h4><ul><li><p>介绍</p><ul><li>是statement的子接口</li><li>使用预编译sql语句</li><li>可以解决sql注入问题，实现高效的批量操作</li></ul></li><li><p>通用增删改操作（V1.0）</p><ul><li>&#96;&#96;&#96;java<br>public void update(String sql,Object …args) {<br>    Connection conn &#x3D; null;<br>    PreparedStatement ps &#x3D; null;<br>    try {<br>&#x2F;&#x2F;        占位符的个数等于可变形参的个数<br>        conn &#x3D; JDBCUtils.getConnection();<br>        ps &#x3D; conn.prepareStatement(sql);<br>        for(int i&#x3D;0;i&lt;args.length;i++){<br>            ps.setObject(i+1,args[i]);<br>        }<br>&#x2F;&#x2F;            方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false<br>&#x2F;&#x2F;            ps.execute();<br>&#x2F;&#x2F;            方式二：<br>        ps.executeUpdate();<br>    } catch (Exception e) {<br>        e.printStackTrace();<br>    } finally {<br>        JDBCUtils.closeResource(conn,ps);<br>    }<br><br>}<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>    <br><br>- 通用查询操作（V1.<span class="hljs-number">0</span>）<br><br>  - ```java<br>    <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        *</span><br><span class="hljs-comment">        *@author Kong</span><br><span class="hljs-comment">        *@Description 针对不同表的通用查询操作，返回表中的一组记录</span><br><span class="hljs-comment">        *@Date 22:12 2022/5/19</span><br><span class="hljs-comment">        *@Param</span><br><span class="hljs-comment">        *@Return</span><br><span class="hljs-comment">        **/</span><br>        public &lt;T&gt; List&lt;T&gt; get<span class="hljs-constructor">ForList(Class&lt;T&gt; <span class="hljs-params">clazz</span>, String <span class="hljs-params">sql</span>, Object <span class="hljs-operator">...</span><span class="hljs-params">args</span>)</span>&#123;<br>            Connection conn = null;<br>            PreparedStatement ps = null;<br>            ResultSet rs = null;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>get<span class="hljs-constructor">Connection()</span>;<br>                ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                    ps.set<span class="hljs-constructor">Object(<span class="hljs-params">i</span>+1,<span class="hljs-params">args</span>[<span class="hljs-params">i</span>])</span>;<br>                &#125;<br>                rs = ps.execute<span class="hljs-constructor">Query()</span>;<br>                ResultSetMetaData rsmd = rs.get<span class="hljs-constructor">MetaData()</span>;<br>                <span class="hljs-built_in">int</span> columnCount = rsmd.get<span class="hljs-constructor">ColumnCount()</span>;<br>                ArrayList&lt;T&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span>(rs.next<span class="hljs-literal">()</span>)&#123;<br>                    T t = clazz.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;columnCount;i++)&#123;<br>                        Object value = rs.get<span class="hljs-constructor">Object(<span class="hljs-params">i</span> + 1)</span>;<br>                        String columnLabel = rsmd.get<span class="hljs-constructor">ColumnLabel(<span class="hljs-params">i</span> + 1)</span>;<br>                        Field field = clazz.get<span class="hljs-constructor">DeclaredField(<span class="hljs-params">columnLabel</span>)</span>;<br>                        field.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>                        field.set(t,value);<br>                    &#125;<br>                    <span class="hljs-built_in">list</span>.add(t);<br>                &#125;<br>                return <span class="hljs-built_in">list</span>;<br>            &#125; catch (Exception e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125; finally &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>close<span class="hljs-constructor">Resource(<span class="hljs-params">conn</span>,<span class="hljs-params">ps</span>,<span class="hljs-params">rs</span>)</span>;<br>            &#125;<br>            return null;<br>    <br>        &#125;<br>        public &lt;T&gt;T get<span class="hljs-constructor">ForInstance(Class&lt;T&gt; <span class="hljs-params">clazz</span>,String <span class="hljs-params">sql</span>,Object <span class="hljs-operator">...</span><span class="hljs-params">args</span>)</span> &#123;<br>            Connection conn = null;<br>            PreparedStatement ps = null;<br>            ResultSet rs = null;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>get<span class="hljs-constructor">Connection()</span>;<br>                ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                    ps.set<span class="hljs-constructor">Object(<span class="hljs-params">i</span>+1,<span class="hljs-params">args</span>[<span class="hljs-params">i</span>])</span>;<br>                &#125;<br>                rs = ps.execute<span class="hljs-constructor">Query()</span>;<br>                ResultSetMetaData rsmd = rs.get<span class="hljs-constructor">MetaData()</span>;<br>                <span class="hljs-built_in">int</span> columnCount = rsmd.get<span class="hljs-constructor">ColumnCount()</span>;<br>                <span class="hljs-keyword">if</span>(rs.next<span class="hljs-literal">()</span>)&#123;<br>                    T t = clazz.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;columnCount;i++)&#123;<br>                        Object value = rs.get<span class="hljs-constructor">Object(<span class="hljs-params">i</span> + 1)</span>;<br>                        String columnLabel = rsmd.get<span class="hljs-constructor">ColumnLabel(<span class="hljs-params">i</span> + 1)</span>;<br>                        Field field = clazz.get<span class="hljs-constructor">DeclaredField(<span class="hljs-params">columnLabel</span>)</span>;<br>                        field.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>                        field.set(t,value);<br>                    &#125;<br>                    return t;<br>                &#125;<br>            &#125; catch (Exception e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125; finally &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>close<span class="hljs-constructor">Resource(<span class="hljs-params">conn</span>,<span class="hljs-params">ps</span>,<span class="hljs-params">rs</span>)</span>;<br>            &#125;<br>            return null;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。</p></blockquote></li><li><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li><li><p>过程图示</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220512170224429.png" alt="image-20220512170224429"></p><ul><li>查询操作的流程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220519164815890.png" alt="image-20220519164815890"></p><h3 id="五、操作Blob类型的变量"><a href="#五、操作Blob类型的变量" class="headerlink" title="五、操作Blob类型的变量"></a>五、操作Blob类型的变量</h3><ul><li><p>具体的insert</p><ul><li>&#96;&#96;&#96;java<br>&#x2F;**<br>*<br>*@author Kong<br>*@Description 向数据表中插入blob信息<br>*@Date 13:59 2022&#x2F;5&#x2F;20<br>*@Param<br>*@Return<br>**&#x2F;<br>@Test<br>public void testInsert() throws Exception {<br><br>    Connection conn &#x3D; JDBCUtils.getConnection();<br>    String sql &#x3D; “insert into customers(name,email,birth,photo) values(?,?,?,?)”;<br>    PreparedStatement ps &#x3D; conn.prepareStatement(sql);<br>    ps.setObject(1, “孙悟空”);<br>    ps.setObject(2, “<a href="mailto:&#x73;&#x75;&#x6e;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;">&#x73;&#x75;&#x6e;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;</a>“);<br>    ps.setObject(3, “500-01-01”);<br><br>    FileInputStream is &#x3D; new FileInputStream(new File(“src&#x2F;sun.jpg”));<br><br>    ps.setBlob(4, is);<br>    ps.execute();<br>    JDBCUtils.closeResource(conn,ps);<br>}<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>- 具体的查询<br><br>  - ```java<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        *</span><br><span class="hljs-comment">        *@author Kong</span><br><span class="hljs-comment">        *@Description 从数据表中查询blob信息</span><br><span class="hljs-comment">        *@Date 14:00 2022/5/20</span><br><span class="hljs-comment">        *@Param</span><br><span class="hljs-comment">        *@Return</span><br><span class="hljs-comment">        **/</span><br>        @Test<br>        public  void test<span class="hljs-constructor">Query()</span> throws Exception &#123;<br>            Connection conn = null;<br>            PreparedStatement ps = null;<br>            InputStream is=null;<br>            FileOutputStream fos=null;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>get<span class="hljs-constructor">Connection()</span>;<br>    <br>                String sql = <span class="hljs-string">&quot;select id,name,email,birth,photo from customers  where id =?&quot;</span> ;<br>                ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>                ps.set<span class="hljs-constructor">Object(1, 20)</span>;<br>                ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br>                <span class="hljs-keyword">if</span>(rs.next<span class="hljs-literal">()</span>)&#123;<br>        <span class="hljs-comment">//            方式一</span><br>        <span class="hljs-comment">//            int id = rs.getInt(1);</span><br>        <span class="hljs-comment">//            String name = rs.getString(2);</span><br>        <span class="hljs-comment">//            String email = rs.getString(3);</span><br>        <span class="hljs-comment">//            Date birth = rs.getDate(4);</span><br>        <span class="hljs-comment">//            方式二：更易读，不易出错</span><br>                    <span class="hljs-built_in">int</span> id = rs.get<span class="hljs-constructor">Int(<span class="hljs-string">&quot;id&quot;</span>)</span>;<br>                    String name = rs.get<span class="hljs-constructor">String(<span class="hljs-string">&quot;name&quot;</span>)</span>;<br>                    String email = rs.get<span class="hljs-constructor">String(<span class="hljs-string">&quot;email&quot;</span>)</span>;<br>                    Date birth = rs.get<span class="hljs-constructor">Date(<span class="hljs-string">&quot;birth&quot;</span>)</span>;<br>                    Customer customer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Customer(<span class="hljs-params">id</span>, <span class="hljs-params">name</span>, <span class="hljs-params">email</span>, <span class="hljs-params">birth</span>)</span>;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(customer);<br>        <span class="hljs-comment">//          将文件下载到本地</span><br>                    Blob photo = rs.get<span class="hljs-constructor">Blob(<span class="hljs-string">&quot;photo&quot;</span>)</span>;<br>                    is = photo.get<span class="hljs-constructor">BinaryStream()</span>;<br>                    fos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileOutputStream(<span class="hljs-string">&quot;wukong.jpg&quot;</span>)</span>;<br>                    byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;<br>                    <span class="hljs-built_in">int</span> len;<br>                    <span class="hljs-keyword">while</span>((len=is.read(<span class="hljs-built_in">bytes</span>))!=-<span class="hljs-number">1</span>)&#123;<br>                        fos.write(<span class="hljs-built_in">bytes</span>,<span class="hljs-number">0</span>,len);<br>                &#125;<br>                &#125;<br>            &#125; catch (Exception e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125; finally &#123;<br>    <br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>close<span class="hljs-constructor">Resource(<span class="hljs-params">conn</span>,<span class="hljs-params">ps</span>)</span>;<br>                is.close<span class="hljs-literal">()</span>;<br>                fos.close<span class="hljs-literal">()</span>;<br>            &#125;<br>    <br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="六、批量插入"><a href="#六、批量插入" class="headerlink" title="六、批量插入"></a>六、批量插入</h3><ul><li><p>层次一：使用statement实现</p></li><li><p>层次二：使用preparestatement实现</p></li><li><p>层次三：</p><ul><li>修改1： 使用 addBatch() &#x2F; executeBatch() &#x2F; clearBatch()</li><li>修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。?rewriteBatchedStatements&#x3D;true 写在配置文件的url后面</li><li>修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</li></ul></li><li><p>层次四：</p><ul><li>在层次三的基础上操作使用Connection 的 setAutoCommit(false)  &#x2F;  commit()</li></ul></li></ul><p>最终代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//    方式四 :设置不允许自动提交数据</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            conn = JDBCUtils.getConnection();<br><span class="hljs-comment">//            设置不自动提交数据</span><br>            conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into goods(name) values(?)&quot;</span>;<br>            ps = conn.prepareStatement(sql);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20000</span>;i++)&#123;<br>                ps.setObject(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;name_&quot;</span>+i);<br><span class="hljs-comment">//                攒batch</span><br>                ps.addBatch();<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">500</span>==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//                    执行batch</span><br>                    ps.executeBatch();<br><span class="hljs-comment">//                    清空batch</span><br>                    ps.clearBatch();<br>                &#125;<br>            &#125;<br><span class="hljs-comment">//            提交数据</span><br>            conn.commit();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            System.out.println(<span class="hljs-string">&quot;时间为：&quot;</span>+(end-start)); <span class="hljs-comment">//13174</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.closeResource(conn,ps);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="面试题：Preparestatement和statement的异同"><a href="#面试题：Preparestatement和statement的异同" class="headerlink" title="面试题：Preparestatement和statement的异同"></a>面试题：Preparestatement和statement的异同</h4><ul><li><p>接口与子接口的关系</p></li><li><p>开发中多数使用前者</p></li><li><p>代码的可读性和可维护性。</p></li><li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li></ul></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li></ul><h3 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h3><h4 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h4><ul><li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p></li><li><p><strong>事务处理（事务操作）的原则：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p></li><li><p>避免数据自动提交</p><ul><li>执行DML语句会自动提交<ul><li><p>设置autocommit无效</p></li><li><p>执行DDL语句也会自动提交</p><ul><li>需要设置autocommit为false</li></ul></li></ul></li></ul></li><li><p>数据库连接关闭也会自动提交</p></li><li><p>事物的ACID属性</p><ul><li><p>多数的只解决了脏读问题就解决了</p></li><li><p>mysql支持四种隔离级别，Oracle只支持两种</p></li><li><p>一般情况保证 read commit就可以</p></li></ul></li><li><p>代码体现</p><ul><li><p>&#96;&#96;&#96;java<br>@Test<br>public void testUpdateTx() {<br>    Connection conn &#x3D; null;<br>    try {<br>        conn &#x3D; JDBCUtils.getConnection();<br>&#x2F;&#x2F;        取消自动提交<br>        conn.setAutoCommit(false);<br>        String sql1&#x3D;”update user_table set balance&#x3D;balance-100 where user&#x3D;?”;<br>        update(conn,sql1,”AA”);<br>&#x2F;&#x2F;        模拟错误<br>&#x2F;&#x2F;            System.out.println(1&#x2F;0);</p><pre><code class="hljs">        String sql2=&quot;update user_table set balance=balance+100 where user=?&quot;;        update(conn,sql2,&quot;BB&quot;);        System.out.println(&quot;成功&quot;);        conn.commit();    &#125; catch (Exception e) &#123;        e.printStackTrace();        try &#123;            conn.rollback();        &#125; catch (SQLException ex) &#123;            e.printStackTrace();        &#125;    &#125; finally &#123;</code></pre><p>&#x2F;&#x2F;            恢复默认值，在设置数据库连接池时使用<br>        try {<br>            conn.setAutoCommit(true);<br>        } catch (SQLException e) {<br>            e.printStackTrace();<br>        }<br>        JDBCUtils.closeResource(conn,null);<br>    }<br>}</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>- 使用事务后的增删改（V2.<span class="hljs-number">0</span>）<br><br>  - ```java<br>    <span class="hljs-comment">//    通用的增删改操作 v2.0（考虑到事务）</span><br>    public <span class="hljs-built_in">int</span> update(Connection conn,String sql,Object ...args) &#123;<br>        PreparedStatement ps = null;<br>        <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//        占位符的个数等于可变形参的个数</span><br>            ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                ps.set<span class="hljs-constructor">Object(<span class="hljs-params">i</span>+1,<span class="hljs-params">args</span>[<span class="hljs-params">i</span>])</span>;<br>            &#125;<br>    <span class="hljs-comment">//            方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false</span><br>    <span class="hljs-comment">//            ps.execute();</span><br>    <span class="hljs-comment">//            方式二：</span><br>            return ps.execute<span class="hljs-constructor">Update()</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JDBCUtils</span>.</span></span>close<span class="hljs-constructor">Resource(<span class="hljs-params">null</span>,<span class="hljs-params">ps</span>)</span>;<br>        &#125;<br>        return <span class="hljs-number">0</span>;<br>    <br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用事务后的查询（V2.0）</p><ul><li>略</li></ul></li></ul><h4 id="事物的四大属性"><a href="#事物的四大属性" class="headerlink" title="事物的四大属性"></a>事物的四大属性</h4><ol><li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol><h4 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h4><ul><li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><p><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</p></li><li><p><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</p></li><li><p><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</p></li></ul></li></ul><h4 id="四种隔离级别（隔离性越好，并发性越差）"><a href="#四种隔离级别（隔离性越好，并发性越差）" class="headerlink" title="四种隔离级别（隔离性越好，并发性越差）"></a>四种隔离级别（隔离性越好，并发性越差）</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220525180458502.png" alt="image-20220525180458502"></p><p>查看并设置隔离级别</p><h3 id="八、DAO"><a href="#八、DAO" class="headerlink" title="八、DAO"></a>八、DAO</h3><h4 id="BaseDAO-java"><a href="#BaseDAO-java" class="headerlink" title="BaseDAO.java"></a>BaseDAO.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao2;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能描述 通用的数据库操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/05/23  14:17</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDAO</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; clazz=<span class="hljs-literal">null</span>;<br><br>    &#123;<span class="hljs-comment">//此处为子类调用，正常声明在子类更好理解，但是为了避免新添加类就要重复写这段代码，所以放在父类中，在调用时，比如customerDAO类调用，此处的this指的是customerDAO类的对象</span><br><span class="hljs-comment">//        获取当前BaseDAO的子类继承的父类（即为BaseDAO）的泛型</span><br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getGenericSuperclass();<br>        ParameterizedType paramType= (ParameterizedType) genericSuperclass;<br><br>        Type[] types = paramType.getActualTypeArguments();<span class="hljs-comment">//获取父类的泛型</span><br>        clazz = (Class&lt;T&gt;) types[<span class="hljs-number">0</span>];<span class="hljs-comment">//泛型的第一个参数</span><br>    &#125;<br><br>    <span class="hljs-comment">//    通用的增删改操作 v2.0（考虑到事务）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Connection conn, String sql, Object ...args)</span> &#123;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//        占位符的个数等于可变形参的个数</span><br>            ps = conn.prepareStatement(sql);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                ps.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br><span class="hljs-comment">//            方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false</span><br><span class="hljs-comment">//            ps.execute();</span><br><span class="hljs-comment">//            方式二：</span><br>            <span class="hljs-keyword">return</span> ps.executeUpdate();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.closeResource(<span class="hljs-literal">null</span>,ps);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Description</span> 针对不同表的通用查询操作，返回表中的一条记录</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Date</span> 22:06 2022/5/19</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getForInstance</span><span class="hljs-params">(Connection conn,String sql,Object ...args)</span> &#123;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ps = conn.prepareStatement(sql);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                ps.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br>            rs = ps.executeQuery();<br>            <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">rsmd</span> <span class="hljs-operator">=</span> rs.getMetaData();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> rsmd.getColumnCount();<br>            <span class="hljs-keyword">if</span>(rs.next())&#123;<br>                <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;columnCount;i++)&#123;<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getObject(i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">columnLabel</span> <span class="hljs-operator">=</span> rsmd.getColumnLabel(i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(columnLabel);<br>                    field.setAccessible(<span class="hljs-literal">true</span>);<br>                    field.set(t,value);<br>                &#125;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.closeResource(<span class="hljs-literal">null</span>,ps,rs);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Description</span> 针对不同表的通用查询操作，返回表中的一组记录</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Date</span> 22:12 2022/5/19</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">     *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span>  List&lt;T&gt; <span class="hljs-title function_">getForList</span><span class="hljs-params">(Connection conn,  String sql, Object ...args)</span>&#123;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ps = conn.prepareStatement(sql);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                ps.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br>            rs = ps.executeQuery();<br>            <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">rsmd</span> <span class="hljs-operator">=</span> rs.getMetaData();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> rsmd.getColumnCount();<br>            ArrayList&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;columnCount;i++)&#123;<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getObject(i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">columnLabel</span> <span class="hljs-operator">=</span> rsmd.getColumnLabel(i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(columnLabel);<br>                    field.setAccessible(<span class="hljs-literal">true</span>);<br>                    field.set(t,value);<br>                &#125;<br>                list.add(t);<br>            &#125;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.closeResource(<span class="hljs-literal">null</span>,ps,rs);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    &#125;<br><span class="hljs-comment">//    查找特殊值的方法</span><br>    <span class="hljs-keyword">public</span> &lt;E&gt;E <span class="hljs-title function_">getValue</span><span class="hljs-params">(Connection conn,String sql,Object ...args)</span>  &#123;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ps = conn.prepareStatement(sql);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>                ps.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br>            rs = ps.executeQuery();<br>            <span class="hljs-keyword">if</span>(rs.next())&#123;<br>                 <span class="hljs-keyword">return</span> (E) rs.getObject(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.closeResource(<span class="hljs-literal">null</span>,ps,rs);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="CustomerDAO"><a href="#CustomerDAO" class="headerlink" title="CustomerDAO"></a>CustomerDAO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao2;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能描述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/05/23  14:35</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomerDAO</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 插入指定数据</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:35 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Connection conn, Customer cust)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 更新用户数据</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:36 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Connection conn,Customer cust)</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 根据id删除指定用户</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:37 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Connection conn,<span class="hljs-type">int</span> id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 根据ID获得对应的customer对象</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:38 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br>    Customer <span class="hljs-title function_">getCustomerById</span><span class="hljs-params">(Connection conn,<span class="hljs-type">int</span> id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 获取所有记录构成的记录</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:40 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br>    List&lt;Customer&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">(Connection conn)</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 返回数据表中数据的条目数量</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:42 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">(Connection conn)</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Description</span> 获取数据库表中最大的生日</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Date</span> 14:43 2022/5/23</span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Param</span></span><br><span class="hljs-comment">    *<span class="hljs-doctag">@Return</span></span><br><span class="hljs-comment">    **/</span><br><br>    Date <span class="hljs-title function_">getMaxBirth</span><span class="hljs-params">(Connection conn)</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="CuscomerDAOImpl"><a href="#CuscomerDAOImpl" class="headerlink" title="CuscomerDAOImpl"></a>CuscomerDAOImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao2;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能描述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Kong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/05/23  14:45</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerDAOImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDAO</span>&lt;Customer&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomerDAO</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Connection conn, Customer cust)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;insert into customers(name,email,birth) values(?,?,?)&quot;</span>;<br>        update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth());<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Connection conn, Customer cust)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;update customers set name=?,email=?,birth=? where id=?&quot;</span>;<br>        update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getId());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Connection conn, <span class="hljs-type">int</span> id)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;delete from customers where id = ?&quot;</span>;<br>        update(conn,sql,id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Customer <span class="hljs-title function_">getCustomerById</span><span class="hljs-params">(Connection conn, <span class="hljs-type">int</span> id)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;select id,name,email,birth from customers where id =?&quot;</span>;<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> getForInstance(conn,  sql, id);<br>        <span class="hljs-keyword">return</span> customer;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Customer&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;select id,name,email,birth   from customers&quot;</span>;<br>        List&lt;Customer&gt; list = getForList(conn,  sql);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;select count(*) from customers&quot;</span>;<br>        <span class="hljs-keyword">return</span> getValue(conn,sql);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getMaxBirth</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;select max(birth) from customers&quot;</span>;<br>        <span class="hljs-keyword">return</span> getValue(conn, sql);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220525182248752.png" alt="image-20220525182248752"></p><h3 id="九、数据库连接池"><a href="#九、数据库连接池" class="headerlink" title="九、数据库连接池"></a>九、数据库连接池</h3><p>必要性</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220523195426832.png" alt="image-20220523195426832"></p><p>几种连接池</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220523195941820.png" alt="image-20220523195941820"></p><h4 id="数据库连接池技术的优点"><a href="#数据库连接池技术的优点" class="headerlink" title="数据库连接池技术的优点"></a><strong>数据库连接池技术的优点</strong></h4><p><strong>1. 资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2. 更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><p><strong>3. 新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p><p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p><h4 id="几种连接池的使用"><a href="#几种连接池的使用" class="headerlink" title="几种连接池的使用"></a>几种连接池的使用</h4><h3 id="十、dbutils的使用"><a href="#十、dbutils的使用" class="headerlink" title="十、dbutils的使用"></a>十、dbutils的使用</h3>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.22leetcode周赛</title>
    <link href="/posts/42691.html"/>
    <url>/posts/42691.html</url>
    
    <content type="html"><![CDATA[<h2 id="5-22leetcode周赛"><a href="#5-22leetcode周赛" class="headerlink" title="5.22leetcode周赛"></a>5.22leetcode周赛</h2><blockquote><p>第一次参加这个周赛，很菜，过了两个题，稍微复盘一下</p></blockquote><h3 id="题目一：6074-字母在字符串中的百分比"><a href="#题目一：6074-字母在字符串中的百分比" class="headerlink" title="题目一：6074. 字母在字符串中的百分比"></a>题目一：<a href="https://leetcode.cn/problems/percentage-of-letter-in-string/">6074. 字母在字符串中的百分比</a></h3><p>难度简单0收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于 <code>letter</code> 字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;foobar&quot;</span>, letter = <span class="hljs-string">&quot;o&quot;</span><br>输出：<span class="hljs-number">33</span><br>解释：<br>等于字母 <span class="hljs-string">&#x27;o&#x27;</span> 的字符在 s 中占到的百分比是 <span class="hljs-number">2</span> / <span class="hljs-number">6</span> * <span class="hljs-number">100</span><span class="hljs-meta">%</span> = <span class="hljs-number">33</span><span class="hljs-meta">%</span> ，向下取整，所以返回 <span class="hljs-number">33</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">输入：s = <span class="hljs-string">&quot;jjjj&quot;</span>, letter = <span class="hljs-string">&quot;k&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>等于字母 <span class="hljs-string">&#x27;k&#x27;</span> 的字符在 s 中占到的百分比是 <span class="hljs-number">0</span><span class="hljs-comment">% ，所以返回 0 。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母</li></ul><p><strong>解答</strong></p><p>这道题是签到题，但是因为有关浮点数精度相关信息忘了，最开始使用float存储的，导致有测试用例不通过，浪费了十多分钟，还被罚时了10分钟</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">percentageLetter</span><span class="hljs-params">(String s, <span class="hljs-type">char</span> letter)</span> &#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//计算字符出现的次数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)==letter)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//题目给出s的length最大100，所以使用double不会损失精度，但float不可以，测试用例(float)59/100=58</span><br>        <span class="hljs-type">double</span> res=(<span class="hljs-type">double</span>)count/s.length();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(res*<span class="hljs-number">100</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目二：6075-装满石头的背包的最大数量"><a href="#题目二：6075-装满石头的背包的最大数量" class="headerlink" title="题目二：6075. 装满石头的背包的最大数量"></a>题目二：6075. 装满石头的背包的最大数量</h3><p>现有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示你可以放置的额外石头数量，石头可以往 <strong>任意</strong> 背包中放置。</p><p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大</strong> 数量<em>。</em></p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2<br>输出：3<br>解释：<br>1 块石头放入背包<span class="hljs-number"> 0 </span>，1 块石头放入背包<span class="hljs-number"> 1 </span>。<br>每个背包中的石头总数是 [2,3,4,4] 。<br>背包<span class="hljs-number"> 0 </span>、背包<span class="hljs-number"> 1 </span>和 背包<span class="hljs-number"> 2 </span>都装满石头。<br>总计<span class="hljs-number"> 3 </span>个背包装满石头，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明不存在超过<span class="hljs-number"> 3 </span>个背包装满石头的情况。<br>注意，可能存在其他放置石头的方案同样能够得到<span class="hljs-number"> 3 </span>这个结果。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100<br>输出：3<br>解释：<br>8 块石头放入背包<span class="hljs-number"> 0 </span>，2 块石头放入背包<span class="hljs-number"> 2 </span>。<br>每个背包中的石头总数是 [10,2,2] 。<br>背包<span class="hljs-number"> 0 </span>、背包<span class="hljs-number"> 1 </span>和背包<span class="hljs-number"> 2 </span>都装满石头。<br>总计<span class="hljs-number"> 3 </span>个背包装满石头，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明不存在超过<span class="hljs-number"> 3 </span>个背包装满石头的情况。<br>注意，不必用完所有的额外石头。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == capacity.length == rocks.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>1 &lt;= capacity[i] &lt;= 109</code></li><li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li><li><code>1 &lt;= additionalRocks &lt;= 109</code></li></ul><p><strong>代码</strong> </p><p>时空O(n)O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumBags</span><span class="hljs-params">(<span class="hljs-type">int</span>[] capacity, <span class="hljs-type">int</span>[] rocks, <span class="hljs-type">int</span> additionalRocks)</span> &#123;<br>        <span class="hljs-type">int</span> len=capacity.length;<br>        <span class="hljs-type">int</span> []tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [len];<br>        <span class="hljs-comment">//计算每个背包的剩余空间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            tmp[i]=capacity[i]-rocks[i];<br>        &#125;<br>        <span class="hljs-comment">//按照剩余空间大小排序</span><br>        Arrays.sort(tmp);<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-comment">//如果空间为0，则满，直接增加</span><br>            <span class="hljs-keyword">if</span>(tmp[i]==<span class="hljs-number">0</span>)&#123;<br>                res++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//剩余空间小于额外的石子数</span><br>            <span class="hljs-keyword">if</span>(tmp[i]&lt;=additionalRocks)&#123;<br>                additionalRocks-=tmp[i];<br>                res++;<br>            &#125;<br>            <span class="hljs-comment">//剩余空间大于额外石子数，不满条件，直接结束循环</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目三：6076-表示一个折线图的最少线段数"><a href="#题目三：6076-表示一个折线图的最少线段数" class="headerlink" title="题目三：6076. 表示一个折线图的最少线段数"></a>题目三：6076. 表示一个折线图的最少线段数</h3><p>给你一个二维整数数组 <code>stockPrices</code> ，其中 <code>stockPrices[i] = [dayi, pricei]</code> 表示股票在 <code>dayi</code> 的价格为 <code>pricei</code> 。<strong>折线图</strong> 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/1920px-pushkin_population_historysvg.png" alt="img"></p><p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/ex0.png" alt="img"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：stockPrices = [[<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：<br>上图为输入对应的图，横坐标表示日期，纵坐标表示价格。<br>以下 <span class="hljs-number">3</span> 个线段可以表示折线图：<br>- 线段 1 （红色）从 <span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> ，经过 <span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span> 和 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> 。<br>- 线段 2 （蓝色）从 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> 。<br>- 线段 3 （绿色）从 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)</span> ，经过 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)</span> 和 <span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)</span> 。<br>可以证明，无法用少于 3 条线段表示这个折线图。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/03/30/ex1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stockPrices = <span class="hljs-comment">[<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[7,8]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：1<br>解释：<br>如上图所示，折线图可以用一条线段表示。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stockPrices.length &lt;= 105</code></li><li><code>stockPrices[i].length == 2</code></li><li><code>1 &lt;= dayi, pricei &lt;= 109</code></li><li>所有 <code>dayi</code> <strong>互不相同</strong> 。</li></ul><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>这道题是没有AC的，卡在了一个隐藏测试用例上，没想到还是因为精度问题，这次我虽然用的是double类型，但是测试用例给到了10的10次方，导致精度丢失，WA</p><p>这里判断三个点在不在同一条直线上不能使用斜率判断，需要使用直线方程的一般式判断</p><p>在这里我们只需要用到直线方程的部分性质<br>直线方程的一般式为：<strong>ax+by+c&#x3D;0</strong><br>在平面直角坐标系中，我们知道任意两个点的坐标就可求出经过这两个点的直线方程<br>可得：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=y2-y1<br><span class="hljs-attr">b</span>=x1-x2//注意别写反了<br><span class="hljs-attr">c</span>=-(ax1+by1)<br><br></code></pre></td></tr></table></figure><p>显然只需要代入其他点判断是否满足一般式即可</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLines</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] stockPrices)</span> &#123;<br>        <span class="hljs-keyword">if</span>(stockPrices.length==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(stockPrices.length==<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> len=stockPrices.length;<br>        HashMap&lt;Integer,Integer&gt; hashmap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span> []tmpStock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            hashmap.put(stockPrices[i][<span class="hljs-number">0</span>],stockPrices[i][<span class="hljs-number">1</span>]);<br>            tmpStock[i]=stockPrices[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        Arrays.sort(tmpStock);<br><span class="hljs-comment">//         排序后的二维数组</span><br>        <span class="hljs-type">int</span>[][] stockPricesSort=stockPrices;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            stockPricesSort[i][<span class="hljs-number">0</span>]=tmpStock[i];<br>            stockPricesSort[i][<span class="hljs-number">1</span>]=hashmap.get(tmpStock[i]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a=stockPricesSort[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-stockPricesSort[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//y2-y1</span><br>        <span class="hljs-type">int</span> b=stockPricesSort[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]-stockPricesSort[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//x1-x2</span><br>        <span class="hljs-type">int</span> c=-(a*stockPricesSort[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+b*stockPricesSort[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//-(ax1+by1)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(a*stockPricesSort[i][<span class="hljs-number">0</span>]+b*stockPricesSort[i][<span class="hljs-number">1</span>]+c!=<span class="hljs-number">0</span>)&#123;<br>                res++;<br>                a=stockPricesSort[i][<span class="hljs-number">1</span>]-stockPricesSort[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>                b=stockPricesSort[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-stockPricesSort[i][<span class="hljs-number">0</span>];<br>                c=-(a*stockPricesSort[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+b*stockPricesSort[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//         使用浮点数精度会丢失</span><br><span class="hljs-comment">//         double k=(double)(stockPricesSort[1][1]-stockPricesSort[0][1])/(stockPricesSort[1][0]-stockPricesSort[0][0]);</span><br><span class="hljs-comment">//         for(int i=2;i&lt;len;i++)&#123;</span><br><span class="hljs-comment">//             double tmp=(double)(stockPricesSort[i][1]-stockPricesSort[i-1][1])/(stockPricesSort[i][0]-stockPricesSort[i-1][0]);</span><br><span class="hljs-comment">//             if(tmp!=k)&#123;</span><br><span class="hljs-comment">//                 res++;</span><br><span class="hljs-comment">//                 k=tmp;</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题：尝试解答，直接超时"><a href="#第四题：尝试解答，直接超时" class="headerlink" title="第四题：尝试解答，直接超时"></a>第四题：尝试解答，直接超时</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/bbbblzy/article/details/79380815">(5条消息) 判断几个点是否在同一条直线上（计算几何）_bbbblzy的博客-CSDN博客_判断两点在一条直线上</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>浮点数精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用GitHubPages+jekyll搭建博客平台</title>
    <link href="/posts/61277.html"/>
    <url>/posts/61277.html</url>
    
    <content type="html"><![CDATA[<h3 id="使用GitHubPages-jekyll搭建博客平台"><a href="#使用GitHubPages-jekyll搭建博客平台" class="headerlink" title="使用GitHubPages+jekyll搭建博客平台"></a>使用GitHubPages+jekyll搭建博客平台</h3><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><ul><li>cannot load such file – webrick (LoadError)<ul><li><a href="https://blog.csdn.net/guo_yue/article/details/117730314">(4条消息) jekyll 安装遇到的问题（cannot load such file – webrick (LoadError)）_阿gua的博客-CSDN博客</a></li></ul></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://cloud.tencent.com/developer/article/1607408">可能是最全面的github pages搭建个人博客教程 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://blog.csdn.net/weixin_43871601/article/details/104248805">(4条消息) 使用github pages+Jekyll模板搭建博客（网页小白）_Yan_wd的博客-CSDN博客_github pages模板</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>githubpags</tag>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 二维数组排序</title>
    <link href="/posts/1218.html"/>
    <url>/posts/1218.html</url>
    
    <content type="html"><![CDATA[<h3 id="Java-二维数组排序"><a href="#Java-二维数组排序" class="headerlink" title="Java 二维数组排序"></a>Java 二维数组排序</h3><p>按照第一个元素升序排序，如果第一个元素相同，则按照第二个元素升序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [][]people=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br>Arrays.sort(people, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>];<br>        &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果需要降序排序，将返回值加负号</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用typora+github实现图床</title>
    <link href="/posts/20962.html"/>
    <url>/posts/20962.html</url>
    
    <content type="html"><![CDATA[<h2 id="使用typora-github实现图床"><a href="#使用typora-github实现图床" class="headerlink" title="使用typora+github实现图床"></a>使用typora+github实现图床</h2><p>[TOC]</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>在使用typora的时候，有时需要放图片，但截图之类的只能保存在本地，如果换了电脑或者将正篇文档给别人，就无法打开，因此使用图床，方便使用typora</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><h3 id="下载PicGo-Core"><a href="#下载PicGo-Core" class="headerlink" title="下载PicGo-Core"></a>下载PicGo-Core</h3><p>首先保证有nodejs环境</p><p>然后安装picgo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install picgo -g<br></code></pre></td></tr></table></figure><p>安装后查看版本，检查是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">picgo -v<br></code></pre></td></tr></table></figure><h3 id="安装github-plus"><a href="#安装github-plus" class="headerlink" title="安装github-plus"></a>安装github-plus</h3><p>官方给的github上传不好用，安装github-plus</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">picgo install github-plus<br></code></pre></td></tr></table></figure><h3 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h3><ul><li>使用typora的PicGo-Core（不需要下载APP）+ github实现<ul><li>github上创建一个仓库，填写readme，拿到对应的拥有仓库读写权限的token</li><li>typora上打开偏好设置，图像栏选择如下图<img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20211003144400515.png" alt="image-20211003144400515" style="zoom: 67%;" /></li></ul></li></ul><h3 id="修改picgo配置"><a href="#修改picgo配置" class="headerlink" title="修改picgo配置"></a>修改picgo配置</h3><p>打开配置文件更改</p><ul><li><pre><code class="JSON">&#123;  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;githubPlus&quot;,    &quot;current&quot;: &quot;githubPlus&quot;,    &quot;githubPlus&quot;: &#123;      &quot;branch&quot;: &quot;master&quot;, // 仓库的分支      &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest&quot;, // 访问的自定义url      &quot;origin&quot;: &quot;github&quot;, // 存放的图片类型      &quot;repo&quot;: &quot;Kong-PR/Typora-picture&quot;, // 存放图片的仓库      &quot;path&quot;: &quot;img&quot;, // 仓库中存放图片的文件夹，也可以不填      &quot;token&quot;: &quot;&quot; // 访问github的仓库的token，就是一开始生成的    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;    &quot;picgo-plugin-github-plus&quot;: true//启动github-plus插件  &#125;,  &quot;picgo-plugin-github-plus&quot;: &#123;    &quot;lastSync&quot;: &quot;2021-10-03 02:44:04&quot;  &#125;&#125;</code></pre></li><li><p>对应的插件一栏是在PicGo-Core的安装目录下安装的,有的没用上</p><ul><li>picgo install smms-user</li><li>picgo install gitee-uploader</li><li>picgo install github-plus</li></ul></li><li><p>上面的 <code>customUrl</code>，在这里我是使用了 <em>jsdeliver</em> cdn 进行加速访问.比正常要上传快很多</p></li><li><p>token填写github的对应token</p></li><li><p>然后就可以使用了,图片放上去就自动上传了</p></li></ul><blockquote><p>有一个疑问</p><p>在我github账户改名后，我仍然可以通过原用户名访问，这是什么原因呢</p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[使用jsdelivr + GitHub + PicGo搭建免费图床 - 啸歌 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/SeanYoung/p/13407250.html#:~:text=%E7%94%B1%E4%BA%8EGitHub%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E6%85%A2%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8CDN%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E9%80%89%E6%8B%A9%E5%85%8D%E8%B4%B9%E7%9A%84jsdeliver%E8%BF%9B%E8%A1%8CCDN%E4%BC%98%E5%8C%96%E3%80%82">https://www.cnblogs.com/SeanYoung/p/13407250.html#:~:text=由于GitHub国内访问速度慢，所以可以考虑使用CDN优化加速进行访问，这里选择免费的jsdeliver进行CDN优化。</a> jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。 包含,JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。)</li><li><a href="http://www.manongjc.com/detail/20-pgwghzxhklulekh.html">Typora + PicGo-Core + Github 实现图片上传到Github - 码农教程 (manongjc.com)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥linux私房菜琐碎知识点</title>
    <link href="/posts/52308.html"/>
    <url>/posts/52308.html</url>
    
    <content type="html"><![CDATA[<h1 id="鸟哥linux私房菜琐碎知识点"><a href="#鸟哥linux私房菜琐碎知识点" class="headerlink" title="鸟哥linux私房菜琐碎知识点"></a>鸟哥linux私房菜琐碎知识点</h1><blockquote><p>看懂了在整理，这样子整理的才有意义；</p><p>切记不要为了整理而整理！！！</p></blockquote><h2 id="0-计算机基础知识"><a href="#0-计算机基础知识" class="headerlink" title="0. 计算机基础知识"></a>0. 计算机基础知识</h2><h3 id="固态硬盘（solid-state-disk，ssd）"><a href="#固态硬盘（solid-state-disk，ssd）" class="headerlink" title="固态硬盘（solid state disk，ssd）"></a>固态硬盘（solid state disk，ssd）</h3><p>​优点：马达不需要转动，所以速度快；</p><p>​缺点：写入次数限制，所以寿命短；</p><h3 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h3><h4 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h4><ol><li>每个符号（英文数字或符号）都占用1bytes，所以有2^8^&#x3D;256种变化；</li><li>每个汉字占用2bytes，所以用2<del>16</del>&#x3D;65536种变化，即可表示6w多个中文字；</li><li>big5码的中文字编码仅仅定义了一万三千多个中文字，所以有些中文使用big5无法实现；</li><li>big5中某些字码像是【许、盖、功】等字，由于这几个字的内部编码会误判为单双引号，所以常常出现乱码。（不仅中文字，其他非英语系国家也会有这样的问题出现）。</li><li>为解决上面的问题，国际组织ISO&#x2F;IEC制定了所谓的Unicode编码系统，我们常称为utf-8或者万国码。该编码打破了所有国家的不同编码，因此大多用户选择这个编码系统。</li></ol><h3 id="软件程序运作"><a href="#软件程序运作" class="headerlink" title="软件程序运作"></a>软件程序运作</h3><h4 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h4><p>机器语言：全部由0和1组成，人类识别起来相当难！</p><p>高级语言：计算机科学家大牛们为了推动人类计算机事业的发展，设计了一种人类能看得懂的语言，然后创造一种【编译程序】来将这些人类写的语言转译成机器能够看懂的机器码。</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>本质：也是一组程序，程序的终点在于管理计算机的所有活动以及驱动系统中的所有硬件。</p><h2 id="1-linux是什么？、如何学习？"><a href="#1-linux是什么？、如何学习？" class="headerlink" title="1.linux是什么？、如何学习？"></a>1.linux是什么？、如何学习？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li>简单定义：操作系统。</li><li>历史：主要原因是一些大牛为了完成自己的兴趣主键开发形成的一款操作系统，非常重要的一点是open  source。</li></ul><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>GNU&#x3D;GNU‘s Not Unix，:smile:大佬的脑子搞不懂。</li><li>GCC&#x3D;GNU Compiler Collection，是linux下的编译器，目前支持C、C++、Java、Objective-C、Fortran、Ada。</li><li>GPL&#x3D;GNU General Public License，自由软件的版权。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/%E9%B8%9F%E5%93%A5.png" alt="是"></p><ul><li>open source 协议说明</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200205220035465.png" alt="版权控制说明"></p><h3 id="linux发展"><a href="#linux发展" class="headerlink" title="linux发展"></a>linux发展</h3><ul><li><p><strong>重要人物</strong>：Linus Torvalds（托瓦兹），早期的Unix系统只提供运算功能，terminal仅负责IO，他想自己搞一个Unix，首先找到了minix。</p></li><li><p><strong>386硬件的多任务测试</strong>：理论上一个CPU在一个时间段内只能处理一个任务，具有多任务能力的CPU可以在不同程序之间切换，<em>eg：</em>一个CPU频率为1GHz，表示他一秒钟可进行10^9^次运算，假设每个程序以1000次作为运作周期，则CPU一秒钟就能切换10<del>6</del>次，如此快的运算速度，人为感觉两个程序是同时运行的了。</p></li><li><p><strong>linux0.02：</strong>托瓦兹参考minux的设计理念，写出的操作系统，早期的linux。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206094811396.png" alt="image-20200206094811396"></p><ul><li><strong>linux虚拟团队的发展：</strong><ul><li><strong>单人维护：</strong>最开始托瓦兹将linux核心放置在FTP上，用户下载使用发现问题主动汇给他；</li><li><strong>广大黑客加入：</strong>托瓦兹总是有解决不了的问题，像是硬件驱动程序的撰写，这是就有人提出可以帮忙写相关程序。托瓦兹的务实态度是linux发展迅速的重要原因。</li><li><strong>核心功能逐渐完善：</strong>托瓦兹一个人精力有限，所以有一些朋友跳出来帮忙做这些工作，1994年终于完成了linux的核心正式版1.0，94年完成2.0，而这些人其实都没见过面。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206100231360.png" alt="image-20200206100231360"></p><ul><li><p><strong>linux的核心版本：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206101541956.png" alt="image-20200206101541956"></p><ul><li><p><strong>奇偶版本分类：</strong></p><ul><li>2.6版本以前两股分类：<ul><li>主次版本为奇数：发展中版本（development）<em>eg：</em>2.5.xx</li><li>主次版本为偶数：稳定版本（stable）<em>eg：</em>2.6.xx</li></ul></li></ul></li><li><p><strong>主线版本、长期维护版本：</strong></p><p>3.0后开始使用</p></li><li><p><strong>linux核心版本与linux发布商版本</strong></p><p>linux核心版本与distribution版本不同</p><p>linux核心最新版本4.0.0（2015&#x2F;04）、centos的distribution版本7.x。</p></li></ul></li><li><p><strong>linux distributions</strong></p><p>出现了诸多版本像是：Red Hat,Ubuntu,Debian等等，但它们使用的核心（kernel）都是官方提供的，各种标准都相同，基本上除了开发商自家开发出的软件外，不同版本的差异并不大。</p><p><strong>鸟哥的分类：</strong></p><ol><li>使用RPM方式安装软件的系统：Red HAT、Fedora、SUSE等；</li><li>使用dpkg方式安装软件的系统：Debian、Ubuntu、B2D等；</li></ol><p><strong>鸟哥的选择建议：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206104202391.png" alt="image-20200206104202391"></p></li></ul><h3 id="linux当前的应用角色"><a href="#linux当前的应用角色" class="headerlink" title="linux当前的应用角色"></a>linux当前的应用角色</h3><p>主要分为企业应用于个人应用，这几年非常流行的云端运算机制中，linux似乎更有着力点。</p><h3 id="企业应用"><a href="#企业应用" class="headerlink" title="企业应用"></a>企业应用</h3><ol><li><strong>网络服务器：</strong>继承了Unix高稳定性的良好传统，linux上面的网络功能非常稳定，又有GNU计划于GPL授权模式，很多优秀的软件都在linux上发展。–15年为止，广泛流传的distribution仍旧是Red Hat和SUSE两个大厂。</li><li><strong>关键人物的应用：</strong>金融数据库、大型企业网管环境，像是金融业将存储数据的任务交给了linux。</li><li><strong>学术机构的高效能运算任务：</strong>服务器的CPU可以增加许多，而且linux的创造者本身就是一个性能癖，所以拥有强大的运算能力，加上linux具有支持范围广泛的GCC编译器，因此在这方面的优势相当明显。</li></ol><h3 id="个人环境的使用"><a href="#个人环境的使用" class="headerlink" title="个人环境的使用"></a>个人环境的使用</h3><p>平时接触的电子产品中，好多东西都有linux的存在，没看之前我还真不知道是linux提供的支持。</p><ol><li><p><strong>桌面计算机：</strong>在个人使用的计算机下，大多是办公学习之类的，desktop环境最需要的就是窗口，但最开始linux的设计者是一大堆工程师大牛，大牛们对于窗口并不是很需要，所以早期的linux并受众面并不是特别广泛；后来为了强化桌面计算机的使用率，linux与X Window System结合了</p><blockquote><p>X Windows System相当于在linux上运行的软件，就算他挂了，对linux也可能不会有直接的影响呢！</p></blockquote></li><li><p><strong>手持系统：</strong>手机、pda；Google推出的Android手机专用操作系统，其实就是linux核心的一支，专门针对手机、平板这类的ARM机器所设计的。</p><blockquote><p>观察了我的手机，Android系统9.0，linux kernel4.9.148</p></blockquote></li><li><p><strong>嵌入式系统：</strong></p><blockquote><p>理解：直接嵌入到产品当中的操作系统，理论上用户不会更动这个操作系统，所以叫嵌入式系统。</p></blockquote><p>产品例子：路由器、防火墙、手机、机器人控制芯片、家电用品的微电脑控制器等，都有linux的身影。</p><blockquote><p>不过嵌入式开发需要很熟悉linux kernel与驱动程序的结合才行，我准备在接下来尝试一些学习。</p></blockquote></li></ol><h3 id="云端使用"><a href="#云端使用" class="headerlink" title="云端使用"></a>云端使用</h3><blockquote><p>分久必合，合久必分：早期贼贵的大型主机分配终端的集中运算，到2010年前个人计算机运算能力增强，大部分运算在桌机或者笔电上进行，到现在人类活动的发达，产生庞大的数据需要集中处理，从而产生云端系统的需求，将信息集中管理。</p></blockquote><p>数据集中在云端，企业员工无时无地都可以办公，不知对于员工来说是喜是忧:smile:</p><ol><li><p><strong>云程序：</strong>公司内部私有云、大型因特网供货商等等</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206151658688.png" alt="image-20200206151658688"></p></li><li><p><strong>端设备：</strong>连接上面的云程序，很多时候使用智能手机、平板，连接到某云就可以使用了；还有像是更迷你的端点设备树莓派、香蕉派，网上售价百十块钱的样子。</p></li></ol><h3 id="linux该如何学习"><a href="#linux该如何学习" class="headerlink" title="linux该如何学习"></a>linux该如何学习</h3><ul><li><p>拒绝X Window的环境，因为它只算是一个linux的一个应用，对于某些深入级别的知识学习没有帮助。</p></li><li><p>站在要让linux成为自己的好用的工具为出发点学习。</p></li><li><p>从头学起。vi文本编辑器、shell scripts 、软件管理员（安装方式）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206182729268.png" alt="image-20200206182729268"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206182754327.png" alt="image-20200206182754327"></p></li><li><p>讨论地址</p><p><a href="http://phorum.study-area.org/">http://phorum.study-area.org/</a></p><p><a href="https://phorum.vbird.org/">https://phorum.vbird.org/</a></p></li><li><p>好习惯</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206184135286.png" alt="image-20200206184135286"></p></li><li><p>兴趣、成就感</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206184306861.png" alt="image-20200206184306861"></p></li><li><p><strong>不同的环境下，解决问题的办法有很多种，只要行得通，就是好办法！</strong></p></li></ul><h2 id="2-主机规划与磁盘划分"><a href="#2-主机规划与磁盘划分" class="headerlink" title="2.主机规划与磁盘划分"></a>2.主机规划与磁盘划分</h2><h3 id="linux与硬件搭配"><a href="#linux与硬件搭配" class="headerlink" title="linux与硬件搭配"></a>linux与硬件搭配</h3><h4 id="1-计算机硬件配备"><a href="#1-计算机硬件配备" class="headerlink" title="1.计算机硬件配备"></a>1.计算机硬件配备</h4><ul><li><strong>游戏or工作：</strong>一般的三位计算机游戏所需要的3D光影运算很多，显示适配器与CPU资源被耗用的就回很多，所以需要比较高的配置。而工作大多需要的是办公软件，所以多数入门级的极端及都能拍的非常流畅了。</li><li><strong>效能与与价格：</strong>个人用户似乎不太考虑这个，但是对于一些企业，就不得不考虑用电带来的经济账。</li><li><strong>支援度：</strong>有些极端及的硬件设计可能不支持某些操作系统，及时自己可以会搞编译程序，也要弄清楚硬件是否支持呐！</li></ul><h4 id="2-linux搭配主机"><a href="#2-linux搭配主机" class="headerlink" title="2.linux搭配主机"></a>2.linux搭配主机</h4><p>日常个人使用做个小服务器不需要太高的性能，CPU i3的够用，但是做一些重要的功能，还是需要高档一些的计算机配备了。</p><ul><li><strong>个人服务器的基本要求：</strong><ul><li>CPU：Intel i3的CPU不算太久，够用。</li><li>RAM：主存越大越好，因为如果主存不够用，就会用到硬盘的内存置换空间，而硬盘的速度要比内存速度慢得多，所以主存太小会影响整体系统的性能，如果再加上有X Window的话，主存太小会炸掉；一般的小型服务器，至少也要512MB以上的主存储器。</li><li>Hard Disk：硬盘容量取决于个人用途，小型服务器20G基本够用。</li><li>VGA：如果你不使用X Window，显示适配器可有可无，如果使用，显示器最好拥有32MB以上的内存。</li><li>NetWork InterFace Card：服务器上最重要的组件之一，但没看懂，后面会讲吧。</li><li>光盘，软盘、键盘and鼠标：能用就行，做服务器可能多数情况下不怎么用，通过网络管控，类似云服务器。</li></ul></li></ul><h4 id="3-各硬件装置在linux文件夹中的命名"><a href="#3-各硬件装置在linux文件夹中的命名" class="headerlink" title="3.各硬件装置在linux文件夹中的命名"></a>3.各硬件装置在linux文件夹中的命名</h4><blockquote><p>在linux中，每个装置都被当成一个文件夹来对待</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206203309823.png" alt="image-20200206203309823"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206203333441.png" alt="image-20200206203333441"></p><h4 id="使用虚拟机学习"><a href="#使用虚拟机学习" class="headerlink" title="使用虚拟机学习"></a>使用虚拟机学习</h4><ul><li>Windows：VMware、VirtualBox</li><li>linux：KVM</li></ul><h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><h4 id="磁盘连接方式与装置文件名的关系"><a href="#磁盘连接方式与装置文件名的关系" class="headerlink" title="磁盘连接方式与装置文件名的关系"></a>磁盘连接方式与装置文件名的关系</h4><p>正常实体机大概使用的都是&#x2F;dev&#x2F;sd[a-]磁盘文件名，但是在虚拟环境下，为了加速可能就会有&#x2F;dev&#x2F;vd[a-p]这种装置文件名。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206210514548.png" alt="image-20200206210514548"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206210531763.png" alt="image-20200206210531763"></p><blockquote><p>我的阿里云服务器，centos7.4，对应的文件名称为&#x2F;dec&#x2F;vda、&#x2F;dev&#x2F;vda1</p></blockquote><h4 id="MSDOS（MBR）与GPT磁盘分区表"><a href="#MSDOS（MBR）与GPT磁盘分区表" class="headerlink" title="MSDOS（MBR）与GPT磁盘分区表"></a>MSDOS（MBR）与GPT磁盘分区表</h4><ul><li><p>MSDOS：早期的linux系统为了兼容Windows的磁盘，使用的是Windows支持的MBR（Master Boot Record，主要开机记录区）的方式处理开机管理程序与分区表。</p><blockquote><p>吧啦吧啦，脑子不够用，看不懂了，总之这里出现了文件名称后面的对应数字。&#x2F;dev&#x2F;sda2</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200206211749441.png" alt="image-20200206211749441"></p></li><li><p>GUID partition table，GPT磁盘分区表</p><blockquote><p>也看不懂，容我歇歇，叫脑子起床</p></blockquote></li></ul><h4 id="开机流程中的BIOS与UEFI开机检测"><a href="#开机流程中的BIOS与UEFI开机检测" class="headerlink" title="开机流程中的BIOS与UEFI开机检测"></a>开机流程中的BIOS与UEFI开机检测</h4><h5 id="BIOS搭配MBR-x2F-GPT的开机流程"><a href="#BIOS搭配MBR-x2F-GPT的开机流程" class="headerlink" title="BIOS搭配MBR&#x2F;GPT的开机流程"></a>BIOS搭配MBR&#x2F;GPT的开机流程</h5><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200207113232733.png" alt="image-20200207113232733"></p><blockquote><p>BIOS不懂GPT</p></blockquote><h5 id="UEFI-BIOS搭配GPT"><a href="#UEFI-BIOS搭配GPT" class="headerlink" title="UEFI BIOS搭配GPT"></a>UEFI BIOS搭配GPT</h5><ul><li><strong>知识点：</strong>过去有一些cracker经常有BIOS的开机阶段来破坏系统，取得系统控制权，所以UEFI加入了一个所谓的安全启动（secure boot）机制，代表着即将开机的操作系统必须要被UEFI所验证，否则无法顺利开机，有些时候需要将此功能关闭，才可以进入linux系统。</li></ul><h4 id="linux安装的磁盘分区"><a href="#linux安装的磁盘分区" class="headerlink" title="linux安装的磁盘分区"></a>linux安装的磁盘分区</h4><ul><li><p>目录树结构</p><p>所有文件都是由根目录衍生来的</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/127.png" alt="image-20200207114016865"></p></li><li><p>文件系统与目录树的关系：挂载</p><p>定义：所谓的挂载就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下，即进入高目录就可以读取该分区槽。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/126.png" alt="image-20200207114547832"></p></li></ul><blockquote><p>当数据在&#x2F;home下的次目录时，对应的数据就是放在partition2的，如果不是在&#x2F;home下的数据，则被放置在partition1。</p></blockquote><h3 id="安装前的规划"><a href="#安装前的规划" class="headerlink" title="安装前的规划"></a>安装前的规划</h3><h4 id="选择合适的distribution"><a href="#选择合适的distribution" class="headerlink" title="选择合适的distribution"></a>选择合适的distribution</h4><ul><li>考虑网络环境的安全性，尽量选择最新的版本。</li><li>若linux定位在服务器上，Red Het Enterprise Linux orSUSE Enterprise Linux比较不错，因为版本更动幅度比较小，并且更新支持的期限比较长。</li></ul><h4 id="主机的服务规划与硬件的关系"><a href="#主机的服务规划与硬件的关系" class="headerlink" title="主机的服务规划与硬件的关系"></a>主机的服务规划与硬件的关系</h4><p>打造Windows、Linux双系统</p><ul><li><p>NAT：达成IP分享器的功能</p><p>通常像学校单位大多会有一条对外的联机，然后全校的计算机透过这个设备连接到互联网上，此时就得要使用IP分享器让这一条对外联机分享给所有的成员是用；在linux下要想达成此功能，需要透过NAT服务达成。</p><p>此时由于网络流量会比较大，网络卡就需要比较好的配备，而CPU、RAM硬盘等的影响力就小很多。</p><p>其实，仅利用linux作为NAT主机来分享IP是很不值的，因为PC的耗电能力要比IP分享器大很多。但由于NAT还可以加装更多的分析软件，实现控制带宽、流量等功能。</p></li><li><p>SAMBA：加入Windows 网上的邻居<br>Windows系统之间传输数据是用过网络邻居来循环数，但Windows 7的芳邻只能同时分享10步客户端联机，超过的话就要等待。</p><p>在linux上使用SAMBA软件达成加入Windows网邻的功能，无客户端限制，适合学校的文件服务器角色。</p><p>同样，由于分享的数据量较大，网卡与硬盘大小及速度就比较重要。此时可以考虑将&#x2F;home 目录独立出来，并且加大容量。</p><blockquote><p>Windows传输文件通过网络邻居？？？我不太懂哇，大家似乎传输的方式很多呐，不过还真没用过网络邻居。:smile:</p></blockquote></li><li><p>Mail：邮件服务器</p><p>现在免费的邮箱已经很多了，个人使用的邮箱应该不需要建设mail server 了，但是如果你是一家私人企业，一些邮件是有商业机密或隐私性的，就需要mail server 了，重要的硬件需求也是硬盘容量与网卡。此时可以将&#x2F;var 目录独立出来，并且加大容量。</p></li><li><p>Web：WWW服务器<br>WWW服务器几乎所有网络主机都会安装的一个功能，除了提供Internet的WWW联机，很多在网络主机上面的软件功能，也都使用WWW作为接口；若要提升WWW副武器的性能，通常提升RAM是一个不错的选择。</p></li><li><p>DHCP：提供客户端自动取得IP的功能</p><p>若你是一个局域网络管理员，区域内部有数十个计算机被使用，这些计算机联网时当然是自动分配比较省力，这就是DHCP的功能；这个功能对硬件的需求不是很高了。</p></li><li><p>FTP</p><p>FTP软件进行资源分享还是比较普遍的，硬盘容量与网卡质量相当重要。</p></li></ul><h4 id="主机硬盘的主要规划"><a href="#主机硬盘的主要规划" class="headerlink" title="主机硬盘的主要规划"></a>主机硬盘的主要规划</h4><blockquote><p>要考虑到计算机硬件出现问题时，文件数据能否安全保存</p></blockquote><blockquote><p>鸟哥说：没有装过十次以上的linux，是学不会linux与磁盘分区的:smile:</p><p>我有幸装过两三次了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/125.png" alt="image-20200208162047374"></p><h2 id="3-安装CentOS7-x"><a href="#3-安装CentOS7-x" class="headerlink" title="3.安装CentOS7.x"></a>3.安装CentOS7.x</h2><blockquote><p>由于我之前安装过Ubuntu1604，加上租的阿里云的Centos7.4的云服务器，这章就不跟着整理了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/124.png" alt="image-20200208205809610"></p><h2 id="4-登入系统"><a href="#4-登入系统" class="headerlink" title="4.登入系统"></a>4.登入系统</h2><h4 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h4><p>一般使用非管理员用户登录，因为系统管理员权限太高，避免出现一些手滑操作。</p><h4 id="基础操作介绍"><a href="#基础操作介绍" class="headerlink" title="基础操作介绍"></a>基础操作介绍</h4><ul><li><p>Ctrl+Alt+F1-F6切换终端</p></li><li><p>简单文本在线文本编辑器：nano</p></li><li><p>关机指令：shutdown、poweroff、reboot、halt</p></li><li><p>复杂关机指令：systemctl 【指令】，上面的几个指令都是调用这个指令。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/123.jpg"></p></li></ul><h2 id="5-Linux的文件权限与目录配置"><a href="#5-Linux的文件权限与目录配置" class="headerlink" title="5.Linux的文件权限与目录配置"></a>5.Linux的文件权限与目录配置</h2><h4 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h4><ul><li><p>文件拥有者（owner）：Linux是多人多任务的系统，因此可能会有多人同时使用一部主机的情况，此时文件拥有者这个角色就相当重要，不想让别人看到的文件，就可以设置成只有文件拥有者才可以看到文件的内容。</p></li><li><p>群组（group）：比如在团队协作的时候，某些文件是具有一定的保密性的，只能让团队里面的成员使用，组内成员之间可以互相修改对方的数据，但是其他组的成员不能看到本组的文件内容。帐号支持多群组设定。</p></li><li><p>其他人（others）：与文件拥有没有任何关系，只有上述两种使用者给予权限才可访问。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/sendpix1.jpg"></p><blockquote><p>上图中例子：以王三毛为例，王三毛这个文件的拥有者为王三毛，王三毛属于王大毛这个群组，而张小猪相对于王三毛，只是个其他人而已。</p><p>图中有一个特殊的人物，就是天神（root），拥有无限的权利，所以他可以访问任何一个地方。</p></blockquote></li><li><p>用户身份与群组记录文件</p><p>root相关的信息记录在&#x2F;etc&#x2F;passwd</p><p>个人的密码信息记录在&#x2F;etc&#x2F;shadow</p><p>Linux所有的组名记录在&#x2F;etc&#x2F;group</p><blockquote><p>打开这三个文件后，发现并不能看懂:smile:</p></blockquote></li></ul><h4 id="Linux文件权限概念"><a href="#Linux文件权限概念" class="headerlink" title="Linux文件权限概念"></a>Linux文件权限概念</h4><h5 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h5><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/sendpix3.jpg"></p><ul><li><p>第一栏表示这个文件的类型与权限</p><p>共有10个字符</p><ul><li><p>第一个字符代表文件类型</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文档（link file）</li><li>b：装置文件里面可供存储的接口设备</li><li>c：装置文件里面的串行端口设备，例如鼠标键盘</li></ul></li><li><p>接下来的字符中三个为一组，均为”rwx“三个参数的组合</p><blockquote><p>r：可读；w：可写；x：可执行（execute），三个参数的位置不会变，如果没有权限，会用-代替。</p></blockquote><ul><li>第一组为<strong>文件拥有者可具备的权限</strong>，上图中对应的权限为<em>rw</em>，表示拥有者可读写，但不可执行。</li><li>第二组为<strong>加入群组的用户的权限</strong>，途中对应权限为<em>r</em>，表示群组内用户可写。</li><li>第三组为<strong>其他用户的权限</strong>，途中对用权限为<em>r</em>，表示其他用户可写。</li></ul></li></ul></li><li><p>第二栏表示有多少档名链接到此节点</p><p>每个文档都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用温金明来记录，因此每个档名会连接到一个i-node。从.目录和.. 目录就可以看出个数。</p></li><li><p>第三栏表示这个文件的拥有者名称</p><p>图中文件为root用户有。</p></li><li><p>第四栏表示这个文件的所属群组</p><p>图中文件的所属群组为root，在root群组内的用户拥有r权限。</p></li><li><p>第五栏表示文件的容量大小</p><blockquote><p>默认单位为bytes，图中文件容量为148bytes。</p></blockquote></li><li><p>第六栏表示文件的建档日期或者是最近的修改日期</p><blockquote><p>这一栏的内容分别为日期（月&#x2F;日）及时间，如果修改的时间局不是在现在的时间年份，会显示年份。</p><p>如果想看完整的时间格式，使用：ls -l –full-time 就能显示出完整的时间格式了。     </p></blockquote></li><li><p>第七栏为这个文档的名称</p><blockquote><p>如果文档名前面有一个[.]，则代表这个文件为隐藏文件。</p></blockquote></li></ul><blockquote><p>对于目录的权限：</p><p>r：读包含目录中的文件名称；</p><p>w：写信息到目录中去（增加和删除索引点的链接）；</p><p>x：搜索目录（能用改目录名称作为路径名去访问它所包含的文件个子目录）；拥有此权限相当于拥有了目录下文件名称及内容的权限。</p><p>即：</p><ul><li>有只读权限的用户不能用cd进入该目录，还必须有执行权限才能进入。</li><li>有执行权限的用户只有在知道文件名，并拥有文件的读权利的情况下才可以访问目录下的文件。</li><li>必须有读和执行权限才可以ls列出目录清单，或者使用cd进入该目录。</li><li><del>有目录的写权限，可以创建、删除或修改该目录下的任何文件或子目录，即使该文件或子目录属于其他用户。</del></li></ul></blockquote><ul><li>Linux文件权限重要性<ul><li>系统保护的功能：像是&#x2F;etc&#x2F;shadow 这种文件，用来保存系统中所有账号的数据，不能被任何人读取，所以对应权限为———，只有root可读。</li><li>团队开发数据共享：希望某些文件只有你团队的人可以实用，其他人都不能看到的时候。</li><li>未将权限合理化的危害：比如给了用户开关机权限，使用者不小心关了机，系统就会慕名的挂掉；或者密码被其他人士获得了，他使用root登录就会轻而易举的做root的一些工作。</li></ul></li></ul><h5 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h5><ul><li><p>更改所属群组：chgrp</p><p>被改变的组名必须要在&#x2F;etc&#x2F;group 文件内存在才行。</p></li><li><p>更改文件拥有者：chown</p><p>被更改的用户名必须要在&#x2F;etc&#x2F;passwd 文件内才行。</p></li><li><p>更改文件权限：chmod</p><ul><li><p>数字类型更改权限：</p><p>r:4;w:2;x:1；暴力授权的时候经常用的：chmod 777  filename。</p></li><li><p>符号类型更改权限：</p><p>使用user（u）、group（g）、others（o）表示三种身份的权限，a则代表全部的身份。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200211202434460.png" alt="image-20200211202434460"></p></li></ul></li></ul><h5 id="目录与文件之权限意义"><a href="#目录与文件之权限意义" class="headerlink" title="目录与文件之权限意义"></a>目录与文件之权限意义</h5><ul><li><p>权限对文件的重要性</p><p>Windows下的可执行文件室友拓展名来判断的，像是.exe、.bat、.com等，但是在Linux下，是否能够执行，完全是由x这个权限确定的，跟文档名没有绝对的关系。</p><p>w权限，表示可以写入、编辑、新增、修改文件内容的权限，但并不具有删除文件本身的权限。对于文件的rwx，都是针对文件的内容而言的，与文档的存在与否没有关系。</p></li><li><p>权限对目录的重要性</p><p>r：具有读取目录结构列表的权限，可以查询该目录下的文件名数据，所以你可以使用ls指令将目录的内容显示出来。</p><p>w：这个权限对于目录来说比较重要，表示用户拥有变更目录结构的权限，即：</p><ul><li><p>建立新的文件与目录；</p></li><li><p>删除已经存在的文件与目录（无论该文件的权限如何）；</p></li><li><p>将已存在的文件或目录进行更名；</p></li><li><p>移动该目录内的文件与目录的位置；</p><p>总之，w权限与该目录下的文件名变更有关。</p></li></ul><p>x：代表用户能否进入该目录成为工作目录的用途。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200211212933823.png" alt="image-20200211212933823"></p><blockquote><p>上图例子中，r都不是必须的，因为我知道要找的文件file1的名字，缺少r只是缺少了tab补全。</p></blockquote></li></ul><h5 id="Linux文件种类与拓展名"><a href="#Linux文件种类与拓展名" class="headerlink" title="Linux文件种类与拓展名"></a>Linux文件种类与拓展名</h5><ul><li><p>文件种类</p><ul><li><p>正规文件（regular file）</p><p>在查看文件属性时，第一个字符为-的文件；</p><p>按照文件内容，大致分为：</p><ul><li>纯文本文档（ASCII）：Linux系统中最多的一种文件类型，几乎用来作为设定的文件都是这个文件类型。</li><li>二进制文件（binary）：Linux当中的可执行文件就是这种格式，比如指令cat。</li><li>数据格式文件（date）：有些文件在运行的过程当中会读取某些特定格式的文件，这些文件可被称作数据文件，数据文件了可以使用last读出来，但使用cat就会出现乱码。</li></ul></li><li><p>目录（directory）</p><p>第一个属性为d。</p></li><li><p>连接文档（link file）</p><p>类似Windows下的快捷方式，第一个属性为l。</p></li><li><p>设备与装置文件（device）</p><p>与系统周边及储存相关的一些文件，通常都集中在&#x2F;dev这个目录下，通常分为两种：</p><ul><li>区块（block）设备文档：一些存储数据，以提供系统随机存取的接口设备，比如硬盘与软盘，第一个属性为b。</li><li>字符（character）设备文件：即一些串行端口的接口设备，例如键盘鼠标，特征为一次性读取，不能够截断输出。例如不能让鼠标跳到另一个画面，而是连续滑动，第一个属性为c。</li></ul></li><li><p>资料接口文档（sockets）</p><p>这种文件通常被用在网络上的数据承接，当启动一个程序来监听客户端的要求，客户端就可以通过这个socket进行数据的沟通了。第一个属性为s。</p></li><li><p>数据传送文件（FIFO，pipe）</p><p>FIFO也是一种特殊的文件类型，主要目的在解决多个程序同时存取一个文件所造成的错误问题。第一个属性为p。</p></li></ul></li><li><p>文件拓展名</p><p>基本上Linux没有所谓的拓展名，一个文件能不能执行，取决于第一栏的十个属性。不过文件能不能执行成功还要取决于文件是否具备可执行的程序代码。</p><p>虽然如此，我们仍希望可以通过文件名来了解某文件是什么东西，所以我们通常还是会以适当的拓展名来区分文件种类的：</p><ul><li>.sh：脚本或批处理文件，因为批处理文件用shell写成，所以缩写为sh。</li><li>Z，.tar，.tar.gz，.zip，tgz：经过打包的压缩文件。因为压缩软件分别为gunzip，tar等，所以取名。</li><li>.html，.php：网页相关文件，分别代表HTML语法与PHP语法的网页文件。</li></ul></li><li><p>文件名长度限制</p><p>最大容许文件名255bytes，即约英文字符255个，中文字约128个。</p></li><li><p>文件名限制</p><p>文字接口下的一些指令的操作关系，在设定名称时，最好避免一些特殊字符：*?&lt;&gt;;[]{}()&amp;&#96;’”-|</p></li></ul><h4 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h4><h5 id="Linux的目录配置依据—FHS"><a href="#Linux的目录配置依据—FHS" class="headerlink" title="Linux的目录配置依据—FHS"></a>Linux的目录配置依据—FHS</h5><blockquote><p>由于使用Linux开发产品或者distributions的开发者太多了，如果每个人都按照自己的想法来配置文件防止的目录，那可能会造成管理上的困扰，这就有了后来的FHS（Filesystem Hierarchy Standard）标准出炉了。</p></blockquote><p>FHS根据文件系统使用的频繁与否与是否允许使用者随意更改，而将目录定义成为四种交互作用的形态，类似下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212183430045.png" alt="image-20200212183430045"></p><p>这是一些代表性的目录，关于这四种类型：</p><ul><li>可分享的：可以分享给其他系统挂在使用的目录，像是执行文件、用户的邮件等数据。</li><li>不可分享的：自己机器上面运作的装置文件或者与程序有关的socket文件等，由于仅仅与自身及其有关，所以当然不适合分享给其他主机了。</li><li>不变的：有些数据是不会经常变动的，跟随着distribution而不变动，例如函数库、文件说明文件、系统管理员所管理的主机服务配置文件等等。</li><li>可变的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</li></ul><p>事实上，FHS针对目录树架构仅定义出三层目录下应该放什么数据而已，分别为：</p><ul><li>&#x2F;（root，根目录）：与开机系统有关；</li><li>&#x2F;usr（unix software resource）：与软件安装、执行有关；</li><li>&#x2F;var（variable）：与系统运作过程有关。</li></ul><blockquote><p>下面是FHS系统规定的必须要存在的目录以及建议存在的目录</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212204726879.png" alt="image-20200212204726879"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212204749591.png" alt="image-20200212204749591"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212204814579.png" alt="image-20200212204814579"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212204833246.png" alt="image-20200212204833246"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212204854755.png" alt="image-20200212204854755"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212204912143.png" alt="image-20200212204912143"></p><blockquote><p>在CentOS 7 中，目录编排与过去版本不同，将一部分原本在根目录下的目录，内部数据全部挪到&#x2F;usr 中，然后进行连接设定，具体如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212205251812.png" alt="image-20200212205251812"></p></blockquote><h5 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h5><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200212205640418.png" alt="image-20200212205640418"></p><blockquote><p>如图，&#x2F;var 目录最好能够独立出来，这样对于系统的数据还有一些安全性的保护，至少&#x2F;var 死掉时，根目录还活着，还能够进入救援模式。</p><p>个人理解因为&#x2F;var 存放的是常态性变动文件，所以容易被搞出事情，所以这里强调将其单独放出来。</p></blockquote><h5 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h5><p>绝对路径：一定是从根目录写起；</p><p>相对路径：从相对于当前工作目录的路径写起；</p><ul><li>. ：代表当前的目录，可使用.&#x2F;代替；</li><li>.. ：代表上一层目录，可使用..&#x2F;代替；</li></ul><blockquote><p>之前编译过后进行的文件运行时使用.&#x2F;run.sh，就表示的是本目录下的run.sh 文件。</p></blockquote><h2 id="6-Linux文件与目录管理"><a href="#6-Linux文件与目录管理" class="headerlink" title="6.Linux文件与目录管理"></a>6.Linux文件与目录管理</h2><h3 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h3><h4 id="绝对路径与相对路径用途"><a href="#绝对路径与相对路径用途" class="headerlink" title="绝对路径与相对路径用途"></a>绝对路径与相对路径用途</h4><ul><li><p>绝对路径：比如在使用shell编写管理系统的程序时，写绝对路径虽然比较麻烦但是保险。</p></li><li><p>相对路径：在同目录下多个文件操作，或者文件树比较深的时候，相对路径简洁的优势就显现出来了。</p></li></ul><h4 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h4><p>常用指令：cd、pwd、mkdir、rmdir。</p><blockquote><p>根目录下也是存在.. 目录的，不过与. 目录所指的是同一个目录。</p></blockquote><ul><li><p>cd（change directory，变换目录）</p><p>cd、cd ~ ：指的都是返回家目录；</p><p>cd - ：指的是返回上次的目录，类似电视机遥控器的返回键。</p></li><li><p>pwd（print working directory，显示目前所在的工作目录）</p><p>pwd -P 表示显示实际路径，而非使用链接路径。</p></li><li><p>mkdir（make directory，建立新目录）</p><p>默认情况下，需要的目录需要一层一层建立。</p><p>mkdir -p pathname&#x2F;pathname2&#x2F;filename ：指的是递归建立目录。</p><p>-m 参数表示预设权限：我的CentOS7.7默认的权限是755。</p><blockquote><p>同时-p -m 创建的目录，只有最底层目录的权限是预设参数，其他的均为默认值。</p><p>默认属性跟umask有关。</p></blockquote></li><li><p>rmdir（remove directory，删除目录）</p><p>-p ：递归删除空目录，像是rmdir -p test&#x2F;kong&#x2F;；</p><p>rm -r ：可删除非空目录。</p></li></ul><h4 id="关于执行文件路径的变量：-PATH"><a href="#关于执行文件路径的变量：-PATH" class="headerlink" title="关于执行文件路径的变量：$PATH"></a>关于执行文件路径的变量：$PATH</h4><p>像是Windows中的环境变量一样，Linux中的环境变量为用户可以在任何地方使用某些指令提供了帮助。</p><p>以ls为例，当你输入ls，系统会按照PATH的设定去每个PATH目录下搜寻文件名为ls的可执行文件，若遇到多个名为ls的文件，那么先搜索到的同名文件先执行。</p><blockquote><p>echo $PATH 指令可以查看当前的环境变量。echo有打印的意思，$后面接的是变量，所以会显示出目前的PATH。</p><p>将&#x2F;usr&#x2F;bin&#x2F; 目录下的ls文件移动到&#x2F;root&#x2F;中，会发现ls无法使用，但是使用绝对路径&#x2F;root&#x2F;ls或者&#x2F;root目录下.&#x2F;ls可以执行，说明这个目录不在PATH中。</p><p>添加PATH：PATH&#x3D;”${PATH}:&#x2F;root”。</p><p>安全起见，不建议将. 加入PATH中，避免写某些文件过度使用权限。</p></blockquote><h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><h4 id="文件目录查看：ls"><a href="#文件目录查看：ls" class="headerlink" title="文件目录查看：ls"></a>文件目录查看：ls</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213204432458.png" alt="image-20200213204432458"></p><blockquote><p>bash shell 实现了将ll 代表ls -l 的指令。</p></blockquote><h4 id="复制、删除与移动：cp，rm，mv"><a href="#复制、删除与移动：cp，rm，mv" class="headerlink" title="复制、删除与移动：cp，rm，mv"></a>复制、删除与移动：cp，rm，mv</h4><ul><li><p>cp（copy）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213205052303.png" alt="image-20200213205052303"></p><blockquote><p>常用-a 或-p 来完整复制文件的权限，否则都会按照默认的权限复制的！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213205345601.png" alt="image-20200213205345601"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213210154434.png" alt="image-20200213210154434"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213210211747.png" alt="image-20200213210211747"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213210305522.png" alt="image-20200213210305522"></p><blockquote><p>总之，由于cp有种种的文件属性与权限的特性，所以在复制时必须要考虑到：</p></blockquote><blockquote><ul><li><p>是否需要完整的保留来源文件的信息？</p></li><li><p>来源文件是否为链接文档？</p></li><li><p>来源文件是否为特殊文件，如FIFO，socket 等？</p></li><li><p>来源文件是否为目录？</p></li></ul></blockquote></li><li><p>rm（remove）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213211042388.png" alt="image-20200213211042388"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213211052093.png" alt="image-20200213211052093"></p><blockquote><p>rm -r 递归删除一些废弃文件夹很好用，慎用。</p><p>当然还有毁天灭地的rm -rf &#x2F;* 指令，千万别用！！！:smile:</p></blockquote></li><li><p>mv(move)</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213212307438.png" alt="image-20200213212307438"></p></li></ul><h4 id="获取路径的文件名与目录名称"><a href="#获取路径的文件名与目录名称" class="headerlink" title="获取路径的文件名与目录名称"></a>获取路径的文件名与目录名称</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213212512116.png" alt="image-20200213212512116"></p><h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ol><li><p>cat：从第一行开始显示文件内容；</p></li><li><p>tac：从最后一行开始显示，其实是cat倒着拼写；</p></li><li><p>nl：显示的时候，输出行号；</p></li><li><p>more：一页一页显示文件的内容；</p></li><li><p>less：与more相似，不过他可以向前翻页；</p></li><li><p>head：只看前几行；</p></li><li><p>tail：只看尾巴几行；</p></li><li><p>od：以二进制的方式读取文件内容。</p></li></ol><blockquote><p>前三个都是一口气阿静数据显示在屏幕上面，more和less都可以一页一页的观察。</p></blockquote><ul><li><p>cat(concatenate)</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213213722126.png" alt="image-20200213213722126"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213213750140.png" alt="image-20200213213750140"></p></li><li><p>tac</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213214349626.png" alt="image-20200213214349626"></p><p>有点意思，tac就是将cat输出的内容按照行数倒序连续输出。</p></li><li><p>nl(添加行号打印)</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213215313331.png" alt="image-20200213215313331"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213215335744.png" alt="image-20200213215335744"></p><blockquote><p>nl的预设和cat -n有点不太一样，nl可以将行号做比较多的显示设计，包括位数与是否自动补齐0等等。</p></blockquote></li><li><p>more()</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213215713217.png" alt="image-20200213215713217"></p><blockquote><ul><li>空格键：代表向下翻一页；</li><li>回车键：代表向下翻一行；</li><li>&#x2F;字符串：代表在这个显示的内容当中，向下搜索【字符串】这个关键词；</li><li>:f ：立即显示文件名以及目前的行数；</li><li>q ：代表立即离开more，不在显示文件内容；</li><li>b 或【Ctrl】-b：代表往回翻页，支队文件有效，对管线无效；</li></ul><p>尝试使用&#x2F; 搜索，不知为何失败了。</p></blockquote></li><li><p>less(一页一页翻动)</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213220719850.png" alt="image-20200213220719850"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213220831228.png" alt="image-20200213220831228"></p><blockquote><p>man page 就是使用less来显示说明文件的内容的。</p></blockquote></li><li><p>head(取出前面几行)</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213220956469.png" alt="image-20200213220956469"></p><blockquote><p>如果n 为负数，代表不显示后面-n行。</p></blockquote></li><li><p>tail()</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213221120485.png" alt="image-20200213221120485"></p><blockquote><p>类似tail ，相反方向。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213221443604.png" alt="image-20200213221443604"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213221507687.png" alt="image-20200213221507687"></p></li><li><p>od(非纯文本文档)</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213221550546.png" alt="image-20200213221550546"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200213221607454.png" alt="image-20200213221607454"></p></li><li><p>修改文件时间或新建文档：touch</p><p>Linux下记录许多的时间参数，其实是三个主要的变动时间：</p><ul><li><p>modification time（mtime）</p><p>当文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容。</p></li><li><p>status time（ctime）</p><p>当文件的状态改变时，就会更新这个时间，像是权限与属性被更改了，就回更细这个时间。</p></li><li><p>access time（atime）</p><p>当文件的内容被取用时，就会更新这个时间，比如使用cat读取文件内容，就会更新这个时间。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214103905832.png" alt="image-20200214103905832"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214103921169.png" alt="image-20200214103921169"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214103948331.png" alt="image-20200214103948331"></p><blockquote><p>touch改变的是mtime和atime，因此常被用来更改文件日期为某时间。</p><p>另一个常用是创建一个空文件。</p></blockquote></li></ul><h3 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h3><h4 id="文件预设权限：umask"><a href="#文件预设权限：umask" class="headerlink" title="文件预设权限：umask"></a>文件预设权限：umask</h4><p>默认权限的属性上，目录与文件是不一样的，一般情况下，x权限对于目录来说十分重要，而文件则主要是用于数据记录，不需要执行权限。所以：</p><blockquote><p>当使用者建立文件则预设没有可执行权限，即只有rw两个权限，最大的数字表示为666，即-rw-rw-rw-；</p><p>当使用者建立目录则预设默认所有权限均开放，最大数字为777，即drwxrwxrwx。</p></blockquote><p>umask的数字代表被减掉的权限，以umask为022为例，相当于：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214170455218.png" alt="image-20200214170455218"></p><h4 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h4><ul><li><p>chattr（配置文件隐藏属性）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214184446932.png" alt="image-20200214184446932"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214184502739.png" alt="image-20200214184502739"></p></li><li><p>lsattr（显示文件隐藏属性）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214184555202.png" alt="image-20200214184555202"></p></li></ul><h4 id="文件特殊权限：SUID，SGID，SBIT"><a href="#文件特殊权限：SUID，SGID，SBIT" class="headerlink" title="文件特殊权限：SUID，SGID，SBIT"></a>文件特殊权限：SUID，SGID，SBIT</h4><ul><li><p>Set UID</p><p>当s出现在文件拥有者的x权限上时，即称为SUID。</p><p>SUID针对文件设定。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214191238116.png" alt="image-20200214191238116"></p><blockquote><p>例子：Linux的所有账号密码都在&#x2F;etc&#x2F;shadow 这个文件里，这个文件权限为———- 1 root root ,即为只有root可用。但是作为普通用户可以通过passwd修改自己的密码，更改该文件，这就是SUID的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214191548099.png" alt="image-20200214191548099"></p><p>但是像用户dmtsai并不能使用cat查看&#x2F;etc&#x2F;shadow ，因为cat不具有SUID权限。</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214191838591.png" alt="image-20200214191838591"></p></blockquote></li><li><p>Set GID</p><p>当s出现在文件群组的x权限上时，即称为SGID。</p><p>SGID针对目录和文件设定。</p><p>当对一个文件设定了SGID权限时：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214192112500.png" alt="image-20200214192112500"></p><p>与SUID类似，在执行一些有SGID权限的文件时会获得对应群组的权限支持。</p><p>当对一个目录设定了SGID权限时：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200214192301506.png" alt="image-20200214192301506"></p></li><li><p>Sticky Bit</p><p>SBIT仅作用在目录上。对于目录的作用为：</p><ul><li>当用户对目录具有rwx权限时；</li><li>用户在该目录下创建文件或者目录，仅有自己与root才有权利删除该文件。</li></ul><blockquote><p>t的作用就是不能删除别人的文件。</p></blockquote><p>留白，root用户创建的777权限的目录下，普通用户能否进行更改权限，删除文件等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">正常情况下，更改权限只能是文件拥有者或是root用户进行。该目录下用户可以删除文件和空目录，非空目录能否删除取决于目录及目录内文件的权限设置。<br></code></pre></td></tr></table></figure></li><li><p>权限设定</p><ul><li><p>数字指令</p><p>SUID：4</p><p>SGID：２</p><p>SGIT：１</p><p>在原先的７７７权限之前加上一个数字，因为这三个数字分别在三个用户组下，所以不会有冲突。像是chmod 4755 filename ，当出现Ｓ，Ｔ时，表示对应位置没有ｘ权限。</p></li><li><p>字母指令</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/sendpix0-1581686048358.jpg"></p></li></ul></li><li><p>观察文件类型：file</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/sendpix1-1581686146762.jpg"></p></li></ul><h3 id="指令与权限的搜寻"><a href="#指令与权限的搜寻" class="headerlink" title="指令与权限的搜寻"></a>指令与权限的搜寻</h3><h4 id="脚本文件名的搜寻"><a href="#脚本文件名的搜寻" class="headerlink" title="脚本文件名的搜寻"></a>脚本文件名的搜寻</h4><ul><li><p>which</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200215193803899.png" alt="image-20200215193803899"></p></li><li><p>type</p></li></ul><h4 id="文档名的搜索"><a href="#文档名的搜索" class="headerlink" title="文档名的搜索"></a>文档名的搜索</h4><ul><li><p>whereis</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200215193841400.png" alt="image-20200215193841400"></p></li><li><p>locate &#x2F; updatedb</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200215193910644.png" alt="image-20200215193910644"></p></li><li><p>find</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20200215193923828.png" alt="image-20200215193923828"></p><blockquote><p>find 有很多的用途，懒惰至极的我没整理。</p></blockquote></li></ul><blockquote><p>这一章后面的习题很精彩，在Pages 276</p></blockquote><h2 id="认识Linux的文件系统"><a href="#认识Linux的文件系统" class="headerlink" title="认识Linux的文件系统"></a>认识Linux的文件系统</h2>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>push项目遇到timeout</title>
    <link href="/posts/18120.html"/>
    <url>/posts/18120.html</url>
    
    <content type="html"><![CDATA[<h3 id="今天push项目遇到timeout"><a href="#今天push项目遇到timeout" class="headerlink" title="今天push项目遇到timeout"></a>今天push项目遇到timeout</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20211014223237685.png" alt="image-20211014223237685"></p><p>不知为何遇到了这个问题，仿佛不是第一次了</p><p>经过一番百度，找到了解决方案</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20211014223326834.png" alt="image-20211014223326834"></p><p>但不知道为什么，其中的端口号是clash使用的端口号，猜测与其有关</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>查看全局配置参数</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git config</span> <span class="hljs-literal">--</span><span class="hljs-comment">global</span> <span class="hljs-literal">--</span><span class="hljs-comment">list</span><br></code></pre></td></tr></table></figure><p>在开启shadowsock的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global http.proxy http://127.0.0.1:7890<br>git config --global https.proxy http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><blockquote><p> 其中的7890改成你的ssh端口号</p><p>http:&#x2F;&#x2F;也可以改成sockets5:&#x2F;&#x2F;,但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。 </p></blockquote><p><strong>取消代理：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global --unset http.proxy  <br>git config --global --unset https.proxy <br></code></pre></td></tr></table></figure><p>然后就可以使用了</p>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
