{"meta":{"title":"虫兑变的博客","subtitle":"我的博客","description":"","author":"Kong Weichao","url":"https://kkkkkong.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-11-27T02:47:42.479Z","updated":"2022-11-27T02:47:42.479Z","comments":false,"path":"books/index.html","permalink":"https://kkkkkong.github.io/books/index.html","excerpt":"","text":"目前还没有！"},{"title":"404 Not Found：该页无法显示","date":"2022-11-27T02:47:24.114Z","updated":"2022-11-19T12:50:54.398Z","comments":false,"path":"/404.html","permalink":"https://kkkkkong.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-27T02:48:02.522Z","updated":"2022-11-27T02:48:02.522Z","comments":true,"path":"links/index.html","permalink":"https://kkkkkong.github.io/links/index.html","excerpt":"","text":"链接测试"},{"title":"Repositories","date":"2022-11-20T02:03:45.950Z","updated":"2022-11-19T12:50:54.404Z","comments":false,"path":"repository/index.html","permalink":"https://kkkkkong.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-27T02:47:19.876Z","updated":"2022-11-27T02:47:19.876Z","comments":false,"path":"about/index.html","permalink":"https://kkkkkong.github.io/about/index.html","excerpt":"","text":"个人详细介绍，写啥还没想好"},{"title":"标签","date":"2022-11-27T02:48:08.642Z","updated":"2022-11-19T12:50:54.405Z","comments":false,"path":"tags/index.html","permalink":"https://kkkkkong.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-11-27T02:47:48.803Z","updated":"2022-11-19T12:50:54.402Z","comments":false,"path":"categories/index.html","permalink":"https://kkkkkong.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 学习资料","slug":"Java-学习资料","date":"2023-03-08T12:19:01.000Z","updated":"2023-03-08T12:23:58.693Z","comments":true,"path":"posts/50986.html","link":"","permalink":"https://kkkkkong.github.io/posts/50986.html","excerpt":"","text":"Java复习资料 分享一些在准备Java面试过程中的常用资料，大多是别人整理的笔记 Java基础-尚硅谷康师傅课程笔记 JavaSE目录_程序员卖剩鸭的博客-CSDN博客 ssm+SpringBoot 全家桶-黑马程序员 SpringMVC · 语雀 (yuque.com) Java常用面试题集合及路线规划 JavaGuide（Java学习&amp;&amp;面试指南） | JavaGuide(Java面试+学习指南) Java程序员进阶之路x沉默王二 | Java程序员进阶之路 (tobebetterjavaer.com) LeetCode模板 labuladong 的算法小抄 :: labuladong的算法小抄 未完待续…","categories":[{"name":"Java","slug":"Java","permalink":"https://kkkkkong.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kkkkkong.github.io/tags/Java/"}]},{"title":"leetcode 76","slug":"leetcode-76","date":"2023-03-08T07:05:06.000Z","updated":"2023-03-08T08:13:58.094Z","comments":true,"path":"posts/52193.html","link":"","permalink":"https://kkkkkong.github.io/posts/52193.html","excerpt":"","text":"题目描述76. 最小覆盖子串给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 123输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。 解题思路 滑动窗口： 注意：Java 的 Integer，String 等类型判定相等不能使用&#x3D;&#x3D;，而要使用equals，这是包装类的一个细节 执行用时：14 ms, 在所有 Java 提交中击败了63.87%的用户 内存消耗：42.2 MB, 在所有 Java 提交中击败了38.80%的用户 通过测试用例：267 &#x2F; 267 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public String minWindow(String s, String t) &#123; if(s.length()&lt;t.length())return &quot;&quot;; HashMap&lt;Character,Integer&gt; map_s=new HashMap(); HashMap&lt;Character,Integer&gt; map_t=new HashMap(); for(int i=0;i&lt;t.length();i++)&#123; char c=t.charAt(i); map_t.put(c,map_t.getOrDefault(c,0)+1); &#125; int num=0; int ans=Integer.MAX_VALUE; int l=0,r=0; int left=0,right=0; while(right&lt;s.length())&#123; char c=s.charAt(right); map_s.put(c,map_s.getOrDefault(c,0)+1); if(map_t.containsKey(c))&#123; if(map_s.get(c).equals(map_t.get(c)))&#123; num++; &#125; &#125; right++; while(num==map_t.size())&#123; if(ans&gt;right-left)&#123; l=left; r=right; ans=right-left; &#125; char c2=s.charAt(left); if(map_t.containsKey(c2))&#123; if(map_s.get(c2).equals(map_t.get(c2)))&#123; num--; &#125; map_s.put(c2,map_s.get(c2)-1); &#125; left++; &#125; &#125; return s.substring(l,r); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 34","slug":"leetcode-34","date":"2023-03-07T06:41:58.000Z","updated":"2023-03-07T06:52:22.222Z","comments":true,"path":"posts/51810.html","link":"","permalink":"https://kkkkkong.github.io/posts/51810.html","excerpt":"","text":"题目描述34. 在排序数组中查找元素的第一个和最后一个位置给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 解题思路 两个二分，分别找左边界和右边界 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：44.2 MB, 在所有 Java 提交中击败了98.88%的用户 通过测试用例：88 &#x2F; 88 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int left=0,right=nums.length-1; int []ans=new int[2]; while(left&lt;=right)&#123; int mid=left+(right-left)/2; if(nums[mid]&gt;target)&#123; right=mid-1; &#125; else if(nums[mid]&lt;target)&#123; left=mid+1; &#125; else if(nums[mid]==target)&#123; right=mid-1; &#125; &#125; if(left==nums.length)ans[0]=-1; else&#123; ans[0]=nums[left]==target?left:-1; &#125; left=0; right=nums.length-1; while(left&lt;=right)&#123; int mid=left+(right-left)/2; if(nums[mid]&gt;target)&#123; right=mid-1; &#125; else if(nums[mid]&lt;target)&#123; left=mid+1; &#125; else if(nums[mid]==target)&#123; left=mid+1; &#125; &#125; if(left&lt;1)ans[1]=-1; else&#123; ans[1]=nums[left-1]==target?left-1:-1; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 704","slug":"leetcode-704","date":"2023-03-07T06:21:04.000Z","updated":"2023-03-07T06:52:22.225Z","comments":true,"path":"posts/16137.html","link":"","permalink":"https://kkkkkong.github.io/posts/16137.html","excerpt":"","text":"题目描述704. 二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 解题思路 二分 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：42.1 MB, 在所有 Java 提交中击败了50.35%的用户 通过测试用例：47 &#x2F; 47 时间 O(N) 空间 O(1) 123456789101112131415161718class Solution &#123; public int search(int[] nums, int target) &#123; int left=0,right=nums.length-1; while(left&lt;=right)&#123; int mid =left+(right-left)/2; if(nums[mid]==target)&#123; return mid; &#125; else if(nums[mid]&lt;target)&#123; left=mid+1; &#125; else if(nums[mid]&gt;target)&#123; right=mid-1; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 752","slug":"leetcode-752","date":"2023-03-07T03:35:58.000Z","updated":"2023-03-07T03:37:24.691Z","comments":true,"path":"posts/28042.html","link":"","permalink":"https://kkkkkong.github.io/posts/28042.html","excerpt":"","text":"题目描述752. 打开转盘锁你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。 示例 1: 123456输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。 解题思路 BFS 执行用时：86 ms, 在所有 Java 提交中击败了31.88%的用户 内存消耗：46.8 MB, 在所有 Java 提交中击败了58.50%的用户 通过测试用例：48 &#x2F; 48 时间 O(N) 空间 O(N) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123; public String up(String s,int i)&#123; char []charArray=s.toCharArray(); if(charArray[i]==&#x27;9&#x27;)&#123; charArray[i]=&#x27;0&#x27;; &#125; else&#123; charArray[i]+=1; &#125; return new String(charArray); &#125; public String down(String s,int i)&#123; char []charArray=s.toCharArray(); if(charArray[i]==&#x27;0&#x27;)&#123; charArray[i]=&#x27;9&#x27;; &#125; else&#123; charArray[i]-=1; &#125; return new String(charArray); &#125; public int openLock(String[] deadends, String target) &#123; Queue&lt;String&gt; queue=new LinkedList(); Set&lt;String&gt; set=new HashSet(); Set&lt;String&gt; visited=new HashSet(); // for(String s:deadends)set.add(s); Collections.addAll(set,deadends); queue.offer(&quot;0000&quot;); visited.add(&quot;0000&quot;); int ans=0; while(!queue.isEmpty())&#123; int len=queue.size(); for(int i=0;i&lt;len;i++)&#123; String val=queue.poll(); if(set.contains(val))continue; if(val.equals(target))&#123; return ans; &#125; for(int j=0;j&lt;4;j++)&#123; String up=up(val,j); String down=down(val,j); if(!visited.contains(up))&#123; queue.offer(up); visited.add(up); &#125; if(!visited.contains(down))&#123; queue.offer(down); visited.add(down); &#125; &#125; &#125; ans++; &#125; return -1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 111","slug":"leetcode-111","date":"2023-03-07T02:44:50.000Z","updated":"2023-03-07T03:37:24.689Z","comments":true,"path":"posts/44328.html","link":"","permalink":"https://kkkkkong.github.io/posts/44328.html","excerpt":"","text":"题目描述111. 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：2 解题思路 BFS 执行用时：1 ms, 在所有 Java 提交中击败了93.80%的用户 内存消耗：60.4 MB, 在所有 Java 提交中击败了86.65%的用户 通过测试用例：52 &#x2F; 52 时间 O(N) 空间 O(N) 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null)return 0; Queue&lt;TreeNode&gt; queue=new LinkedList(); queue.offer(root); int deepth=1; while(!queue.isEmpty())&#123; int len=queue.size(); for(int i=0;i&lt;len;i++)&#123; TreeNode node=queue.poll(); if(node.left==null&amp;&amp;node.right==null)&#123; return deepth; &#125; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; &#125; deepth++; &#125; return deepth; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"github 首页个人信息展示","slug":"github-首页个人信息展示","date":"2023-03-06T12:35:20.000Z","updated":"2023-03-06T14:05:10.475Z","comments":true,"path":"posts/18448.html","link":"","permalink":"https://kkkkkong.github.io/posts/18448.html","excerpt":"","text":"github首页配置背景美化github首页，成果如下，欢迎访问 kkkkkong (kong) (github.com) 主要步骤 创建github同名仓库 填写README.md 配置README.md 遇到问题问题描述 Error: Pushing to https://github.com/kkkkkong/kkkkkong remote: Permission to kkkkkong&#x2F;kkkkkong.git denied to github-actions[bot]. fatal: unable to access ‘https://github.com/kkkkkong/kkkkkong/&#39;: The requested URL returned error: 403 这个错误意味着你尝试将代码推送到GitHub上的一个仓库，但是你没有足够的权限来进行这个操作。具体地说，这个错误信息显示了github-actions[bot]被拒绝了权限，因此无法推送代码到这个仓库。 我尝试了以下操作 首先可能是因为github action没有权限，因此创建访问令牌或者使用ssh秘钥，然后配置文件被我修改成这样 首先，在你的GitHub账户中生成一个新的访问令牌。你可以按照以下步骤来生成一个GitHub访问令牌： 首先，登录到你的GitHub帐户中。 点击右上角的你的头像，然后选择”Settings”。 在左侧菜单中，选择”Developer settings”，然后选择”Personal access tokens”。 点击”Generate new token”按钮。 在”Note”字段中，为你的访问令牌添加一个描述性的名称。 选择所需的权限。根据你的需求，你可以选择只授予必要的权限，以便最大程度地减少安全风险。如果你不确定要选择哪些权限，请参考GitHub官方文档。 点击”Generate token”按钮。 复制生成的访问令牌。请注意，此令牌仅在此时显示，你必须复制它以后才能使用。 将该访问令牌安全地保存在一个安全的位置，以便以后使用。 将生成的访问令牌添加到你的GitHub存储库的Secrets中。在你的存储库中，点击Settings，然后点击Secrets，再点击New repository secret按钮来添加一个新的秘密。你需要将秘密的名称设置为ACCESS_TOKEN，并将生成的访问令牌作为值输入。 在你的workflow文件中，使用$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;来引用你的访问令牌。 1234567891011121314151617181920212223242526272829303132333435# GitHub Action for generating a contribution graph with a snake eating your contributions.name: Generate Snakeon: schedule: - cron: &quot;0 0 * * *&quot; workflow_dispatch:jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2.3.4 - name: Generate Snake uses: Platane/snk@master id: snake-gif with: github_user_name: $&#123;&#123; github.repository_owner &#125;&#125; gif_out_path: ./assets/github-contribution-grid-snake.gif svg_out_path: ./assets/github-contribution-grid-snake.svg github_token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; - name: Push to GitHub uses: EndBug/add-and-commit@v7.2.1 with: branch: main message: &#x27;Generate Contribution Snake&#x27; author_name: Your Name author_email: yourname@example.com force: true 我的仍然不起作用，后来发现仓库默认情况下，新存储库没有适当的工作流权限。修改后可以运行了 转到存储库Setting 选择Actions&gt;&gt;&gt;General 在”工作流权限(Workflow permissions)”中，选择Read and write permissions 参考链接Github 首页美化教程（一）：打造个性化的GitHub首页 - 知乎 (zhihu.com) 【Git】workflows 部署 vuepress 错误“The process ‘&#x2F;usr&#x2F;bin&#x2F;git‘ failed with exit code 128“_the process ‘&#x2F;usr&#x2F;bin&#x2F;git’ failed with exit code 1_菜鸟点滴的博客-CSDN博客","categories":[{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/tags/github/"}]},{"title":"leetcode 47","slug":"leetcode-47","date":"2023-03-06T09:08:01.000Z","updated":"2023-03-06T09:40:23.443Z","comments":true,"path":"posts/64288.html","link":"","permalink":"https://kkkkkong.github.io/posts/64288.html","excerpt":"","text":"题目描述47. 全排列 II给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 12345输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]] 解题思路 回溯：元素重复的不可重复选的排列问题 执行用时：2 ms, 在所有 Java 提交中击败了41.88%的用户 内存消耗：41.9 MB, 在所有 Java 提交中击败了89.25%的用户 通过测试用例：33 &#x2F; 33 时间 O(N) 空间 O(N) 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList(); List&lt;Integer&gt; list=new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; boolean []used=new boolean[nums.length]; backTrack(nums,used); return ans; &#125; public void backTrack(int []nums,boolean []used)&#123; if(list.size()==nums.length)&#123; ans.add(new ArrayList(list)); return ; &#125; Set&lt;Integer&gt; set=new HashSet(); for(int i=0;i&lt;nums.length;i++)&#123; if(set.contains(nums[i])||used[i]==true)&#123; continue; &#125; set.add(nums[i]); list.add(nums[i]); used[i]=true; backTrack(nums,used); list.remove(list.size()-1); used[i]=false; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 40","slug":"leetcode-40","date":"2023-03-06T06:40:04.000Z","updated":"2023-03-06T09:40:23.439Z","comments":true,"path":"posts/14689.html","link":"","permalink":"https://kkkkkong.github.io/posts/14689.html","excerpt":"","text":"题目描述40. 组合总和 II给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]] 解题思路 回溯：元素可重复的不可重复选的组合问题。如果不进行第二段剪枝的话会超时 执行用时：4 ms, 在所有 Java 提交中击败了43.75%的用户 内存消耗：41.7 MB, 在所有 Java 提交中击败了65.39%的用户 通过测试用例：176 &#x2F; 176 时间 O(N) 空间 O(N) 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; list=new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backTrack(candidates,target,0,0); return ans; &#125; public void backTrack(int []candidates,int target,int start,int sum)&#123; if(sum==target)&#123; ans.add(new ArrayList(list)); return ; &#125; if(sum&gt;target)&#123; return; &#125; for(int i=start;i&lt;candidates.length;i++)&#123; if(i&gt;start&amp;&amp;candidates[i]==candidates[i-1])continue; list.add(candidates[i]); backTrack(candidates,target,i+1,sum+candidates[i]); list.remove(list.size()-1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 90","slug":"leetcode-90","date":"2023-03-06T06:22:59.000Z","updated":"2023-03-06T06:28:46.443Z","comments":true,"path":"posts/43365.html","link":"","permalink":"https://kkkkkong.github.io/posts/43365.html","excerpt":"","text":"题目描述90. 子集 II给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例 1： 12输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 解题思路 回溯：元素重复不可复选问题，需要提前排序 执行用时：1 ms, 在所有 Java 提交中击败了99.17%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了76.27%的用户 通过测试用例：20 &#x2F; 20 时间 O(N) 空间 O(N) 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backTrace(nums,0); return res; &#125; public void backTrace(int []nums,int begin)&#123; res.add(new ArrayList&lt;&gt;(list)); for(int i=begin;i&lt;nums.length;i++)&#123; if((i&gt;begin)&amp;&amp;(nums[i]==nums[i-1]))&#123; continue; &#125; list.add(nums[i]); backTrace(nums,i+1); list.remove(list.size()-1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 77","slug":"leetcode-77","date":"2023-03-06T02:57:08.000Z","updated":"2023-03-06T03:03:51.104Z","comments":true,"path":"posts/2848.html","link":"","permalink":"https://kkkkkong.github.io/posts/2848.html","excerpt":"","text":"题目描述77. 组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例 1： 12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路 回溯：元素无重复不可复选问题 执行用时：18 ms, 在所有 Java 提交中击败了25.06%的用户 内存消耗：42.9 MB, 在所有 Java 提交中击败了37.61%的用户 通过测试用例：27 &#x2F; 27 时间 O(N) 空间 O(N) 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backTrace(n,1,k); return res; &#125; public void backTrace(int n,int begin,int k)&#123; if(list.size()==k)&#123; res.add(new ArrayList(list)); return; &#125; for(;begin&lt;=n;begin++)&#123; list.add(begin); backTrace(n,begin+1,k); list.remove(list.size()-1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 78","slug":"leetcode-78","date":"2023-03-06T02:32:06.000Z","updated":"2023-03-06T03:03:51.106Z","comments":true,"path":"posts/3936.html","link":"","permalink":"https://kkkkkong.github.io/posts/3936.html","excerpt":"","text":"题目描述78. 子集给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 解题思路 回溯+组合：元素无重复不可重复选问题 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.9 MB, 在所有 Java 提交中击败了6.15%的用户 通过测试用例：10 &#x2F; 10 时间 O(N) 空间 O(N) 1234567891011121314151617class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; getSets(nums,0,new ArrayList&lt;Integer&gt;()); res.add(new ArrayList()); return res; &#125; public void getSets(int []nums,int begin,List&lt;Integer&gt; list)&#123; for(;begin&lt;nums.length;begin++)&#123; list.add(nums[begin]); res.add(new ArrayList(list)); getSets(nums,begin+1,list); list.remove(list.size()-1); &#125; &#125;&#125; 稍微修改一下 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.9 MB, 在所有 Java 提交中击败了10.75%的用户 通过测试用例：10 &#x2F; 10 时间 O(N) 空间 O(N) 1234567891011121314151617class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; getSets(nums,0); return res; &#125; public void getSets(int []nums,int begin)&#123; res.add(new ArrayList(list)); for(;begin&lt;nums.length;begin++)&#123; list.add(nums[begin]); getSets(nums,begin+1); list.remove(list.size()-1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"一台电脑连接多个github账户如何配置秘钥","slug":"一台电脑连接多个github账户","date":"2023-03-04T14:05:22.000Z","updated":"2023-03-04T14:16:50.879Z","comments":true,"path":"posts/37835.html","link":"","permalink":"https://kkkkkong.github.io/posts/37835.html","excerpt":"","text":"背景实验室多个人使用同一台服务器，使用git时配置秘钥分别连接自己的github账户，此时会出现总是匹配一个固定的秘钥的情况 解决方案1. 生成秘钥此处具体细节和网上的一样，假设生成两个秘钥，名字分别为id_rsa和id_rsa_bak，对应的公钥为后缀多了.pub 2. 编辑配置文件编辑.ssh/config文件，内容为 123456789# 第一个Host github_oneHostname github.comIdentityFile ~/.ssh/id_rsa# 第二个Host github_twoHostname github.comIdentityFile ~/.ssh/id_rsa_bak 网上的大部分教程都是避其锋芒，配置里大多是不同的网站，比如github和gitee，明显不符合我们的需求 把公钥放在对应的github账户上，然后执行下面的命令即可 12ssh -T git@github_onessh -T git@github_two 3. 关联仓库在以后关联仓库的时候，把@后面的内容要修改为对应的host 12git remote add origin git@github_one:xxx/example.git # public usergit remote add origin git@github_two:xxx/example.git # priavate user 参考链接一台电脑双GitHub账户配置 - 知乎 (zhihu.com)","categories":[{"name":"git","slug":"git","permalink":"https://kkkkkong.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kkkkkong.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"https://kkkkkong.github.io/tags/ssh/"}]},{"title":"leetcode 51","slug":"leetcode-51","date":"2023-03-02T08:37:21.000Z","updated":"2023-03-04T14:16:50.878Z","comments":true,"path":"posts/27041.html","link":"","permalink":"https://kkkkkong.github.io/posts/27041.html","excerpt":"","text":"题目描述51. N 皇后按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例 1： 123输入：n = 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。 解题思路 回溯+哈希：做前序状态记录比较麻烦，导致效率不高 执行用时：9 ms, 在所有 Java 提交中击败了10.60%的用户 内存消耗：41.9 MB, 在所有 Java 提交中击败了34.87%的用户 通过测试用例：9 &#x2F; 9 时间 O(NLogN) 空间 O(N) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; List&lt;List&lt;String&gt;&gt; ans=new ArrayList&lt;List&lt;String&gt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; backTrack(n,new ArrayList&lt;String&gt;(),new HashMap&lt;Integer,Integer&gt;()); return ans; &#125; public void backTrack(int n,List&lt;String&gt; list,HashMap&lt;Integer,Integer&gt; used)&#123; if(list.size()==n)&#123; ans.add(new ArrayList(list)); return ; &#125; for(int i=0;i&lt;n;i++)&#123; if(used.containsValue(i))continue; int x=used.getOrDefault(used.size()-1,-1); if(x!=-1&amp;&amp;!isTrue(used,i,n))&#123; continue; &#125; char []c=new char[n]; Arrays.fill(c,&#x27;.&#x27;); c[i]=&#x27;Q&#x27;; used.put(used.size(),i); list.add(String.valueOf(c)); backTrack(n,list,used); list.remove(list.size()-1); used.remove(used.size()-1); &#125; &#125; public boolean isTrue(HashMap&lt;Integer,Integer&gt; used,int i,int n)&#123; int j=used.size(); for(int t=0;t&lt;j;t++)&#123; if(used.getOrDefault(t,-1)==i)&#123; return false; &#125; &#125; for(int t=1;t+i&lt;n&amp;&amp;j-t&gt;=0;t++)&#123; if(used.getOrDefault(j-t,-1)==i+t)&#123; return false; &#125; &#125; for(int t=1;t&lt;=j&amp;&amp;t&lt;=i;t++)&#123; if(used.getOrDefault(j-t,-1)==i-t)&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 46","slug":"leetcode-46","date":"2023-03-02T02:50:05.000Z","updated":"2023-03-04T14:16:50.876Z","comments":true,"path":"posts/15329.html","link":"","permalink":"https://kkkkkong.github.io/posts/15329.html","excerpt":"","text":"题目描述46. 全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 解题思路 哈希表+回溯：引入了额外的哈希表，但浪费时间，可能是在数组与list的转换上，需要用到stream来装箱 执行用时：2 ms, 在所有 Java 提交中击败了8.40%的用户 内存消耗：41.9 MB, 在所有 Java 提交中击败了28.32%的用户 通过测试用例：26 &#x2F; 26 时间 O(N!) 空间 O(N) 123456789101112131415161718192021222324252627class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;Integer&gt; tmpNums=Arrays.stream(nums).boxed().collect(Collectors.toList()); backTrack(tmpNums,new ArrayList&lt;Integer&gt;()); return ans; &#125; public void backTrack(List&lt;Integer&gt; nums,List&lt;Integer&gt; tmp)&#123; if(nums.size()==1)&#123; tmp.add(nums.get(0)); ans.add(new ArrayList(tmp)); tmp.remove(tmp.size()-1); return; &#125; for(int i=nums.size()-1;i&gt;=0;i--)&#123; int num=nums.get(i); tmp.add(num); nums.remove(i); backTrack(nums,tmp); nums.add(i,num); tmp.remove(tmp.size()-1); &#125; &#125;&#125; 回溯：使用额外的数组来标记是否使用了某元素 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.8 MB, 在所有 Java 提交中击败了44.06%的用户 通过测试用例：26 &#x2F; 26 时间 O(N!) 空间 O(N) 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; boolean []used=new boolean [nums.length]; backTrack(nums,new ArrayList&lt;Integer&gt;(),used); return ans; &#125; public void backTrack(int [] nums,List&lt;Integer&gt; tmp,boolean []used)&#123; if(tmp.size()==nums.length)&#123; ans.add(new ArrayList(tmp)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]==true)continue; tmp.add(nums[i]); used[i]=true; backTrack(nums,tmp,used); used[i]=false; tmp.remove(tmp.size()-1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 322","slug":"leetcode-322","date":"2023-03-01T03:05:28.000Z","updated":"2023-03-04T14:16:50.874Z","comments":true,"path":"posts/40137.html","link":"","permalink":"https://kkkkkong.github.io/posts/40137.html","excerpt":"","text":"题目描述322. 零钱兑换给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 解题思路 暴力解 超时 加备忘录 执行用时：142 ms, 在所有 Java 提交中击败了5.00%的用户 内存消耗：43.3 MB, 在所有 Java 提交中击败了5.08%的用户 通过测试用例：189 &#x2F; 189 时间 O(N) 空间 O(N) 123456789101112131415161718192021class Solution &#123; HashMap&lt;Integer,Integer&gt; map=new HashMap(); public int coinChange(int[] coins, int amount) &#123; return getChange(coins,amount); &#125; public int getChange(int[] coins, int amount)&#123; if(amount&lt;0)return -1; if(amount==0)return 0; if(map.containsKey(amount))return map.get(amount); int ans=Integer.MAX_VALUE; for(int i:coins)&#123; int tmp=getChange(coins,amount-i); if(tmp==-1)continue; ans=Math.min(ans,tmp+1); &#125; ans = ans==Integer.MAX_VALUE?-1:ans; map.put(amount,ans); return ans; &#125;&#125; 自底向上，dp数组迭代，来自题解 123456789101112131415161718192021int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; // 数组大小为 amount + 1，初始值也为 amount + 1 Arrays.fill(dp, amount + 1); // base case dp[0] = 0; // 外层 for 循环在遍历所有状态的所有取值 for (int i = 0; i &lt; dp.length; i++) &#123; // 内层 for 循环在求所有选择的最小值 for (int coin : coins) &#123; // 子问题无解，跳过 if (i - coin &lt; 0) &#123; continue; &#125; dp[i] = Math.min(dp[i], 1 + dp[i - coin]); &#125; &#125; return (dp[amount] == amount + 1) ? -1 : dp[amount];&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 344","slug":"leetcode-344","date":"2023-02-28T07:19:44.000Z","updated":"2023-02-28T07:28:00.717Z","comments":true,"path":"posts/15946.html","link":"","permalink":"https://kkkkkong.github.io/posts/15946.html","excerpt":"","text":"题目描述344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。 示例 1： 12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 解题思路 双指针，简单题我重拳出击 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：47.8 MB, 在所有 Java 提交中击败了94.56%的用户 通过测试用例：477 &#x2F; 477 时间 O(N) 空间 O(1) 123456789101112class Solution &#123; public void reverseString(char[] s) &#123; int left=0,n=s.length,right=n-1; while(left&lt;right)&#123; char tmp=s[left]; s[left]=s[right]; s[right]=tmp; left++; right--; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 83","slug":"leetcode-83","date":"2023-02-28T07:01:20.000Z","updated":"2023-02-28T07:04:15.560Z","comments":true,"path":"posts/14372.html","link":"","permalink":"https://kkkkkong.github.io/posts/14372.html","excerpt":"","text":"题目描述83. 删除排序链表中的重复元素给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： 12输入：head = [1,1,2]输出：[1,2] 解题思路 双指针 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：40.9 MB, 在所有 Java 提交中击败了69.93%的用户 通过测试用例：166 &#x2F; 166 时间 O(N) 空间 O(1) 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null||head.next==null)return head; ListNode low=head,fast=head.next; while(fast!=null)&#123; if(fast.val==low.val)&#123; low.next=fast.next; fast=low.next; &#125; else&#123; fast=fast.next; low=low.next; &#125; &#125; return head; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 26","slug":"leetcode-26","date":"2023-02-28T06:35:28.000Z","updated":"2023-02-28T07:04:15.556Z","comments":true,"path":"posts/39906.html","link":"","permalink":"https://kkkkkong.github.io/posts/39906.html","excerpt":"","text":"题目描述26. 删除有序数组中的重复项给你一个 升序排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 解题思路 快慢指针 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：43.3 MB, 在所有 Java 提交中击败了29.47%的用户 通过测试用例：361 &#x2F; 361 时间 O(N) 空间 O(1) 12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; int low=1,fast=1,n=nums.length; for(int i=1;i&lt;n;i++)&#123; if(nums[i]!=nums[i-1])&#123; nums[low]=nums[i]; low++; &#125; &#125; return low; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 86","slug":"leetcode-86","date":"2023-02-28T03:11:28.000Z","updated":"2023-02-28T07:04:15.562Z","comments":true,"path":"posts/15332.html","link":"","permalink":"https://kkkkkong.github.io/posts/15332.html","excerpt":"","text":"题目描述86. 分隔链表给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 示例 1： 12输入：head = [1,4,3,2,5,2], x = 3输出：[1,2,2,4,3,5] 解题思路 注意要断开原指针的链接 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.1 MB, 在所有 Java 提交中击败了40.53%的用户 通过测试用例：168 &#x2F; 168 时间 O(N) 空间 O(1) 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode ans=new ListNode(-1),p=ans; ListNode tail=new ListNode(-1),p2=tail; while(head!=null)&#123; if(head.val&lt;x)&#123; p.next=head; p=p.next; &#125; else&#123; p2.next=head; p2=p2.next; &#125; // 断开原链表中的每个节点的 next 指针 ListNode tmp=head.next; head.next=null; head=tmp; &#125; p.next=tail.next; return ans.next; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 904","slug":"leetcode-904","date":"2023-02-28T02:04:57.000Z","updated":"2023-02-28T07:04:15.563Z","comments":true,"path":"posts/64616.html","link":"","permalink":"https://kkkkkong.github.io/posts/64616.html","excerpt":"","text":"题目描述904. 水果成篮你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 12输入：fruits = [1,2,1]输出：3 解题思路 滑动窗口+哈希表 执行用时：42 ms, 在所有 Java 提交中击败了64.08%的用户 内存消耗：50.6 MB, 在所有 Java 提交中击败了52.45%的用户 通过测试用例：91 &#x2F; 91 时间 O(N) 空间 O(1),最多只用3个空间的map，可以看做是常数空间 12345678910111213141516171819202122class Solution &#123; public int totalFruit(int[] fruits) &#123; HashMap&lt;Integer,Integer&gt; map=new HashMap(); int left=0,right=0,n=fruits.length,ans=0; while(right&lt;n)&#123; map.put(fruits[right],map.getOrDefault(fruits[right],0)+1); right++; while(map.size()&gt;2)&#123; int value=map.get(fruits[left]); if(value&gt;1)&#123; map.put(fruits[left],value-1); &#125; else&#123; map.remove(fruits[left]); &#125; left++; &#125; ans=Math.max(ans,right-left); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 395","slug":"leetcode-395","date":"2023-02-28T01:34:21.000Z","updated":"2023-02-28T07:04:15.559Z","comments":true,"path":"posts/28303.html","link":"","permalink":"https://kkkkkong.github.io/posts/28303.html","excerpt":"","text":"题目描述395. 至少有 K 个重复字符的最长子串给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 示例 1： 123输入：s = &quot;aaabb&quot;, k = 3输出：3解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。 解题思路 分治：递归返回条件：s.length()&lt;k或找到符合条件的s 执行用时：4 ms, 在所有 Java 提交中击败了60.30%的用户 内存消耗：41.3 MB, 在所有 Java 提交中击败了34.40%的用户 通过测试用例：37 &#x2F; 37 时间 O(N2626) 空间 O(26*26） 123456789101112131415161718192021class Solution &#123; public int longestSubstring(String s, int k) &#123; int n=s.length(); if(n&lt;k)return 0; Map&lt;Character,Integer&gt; map=new HashMap(); for(int i=0;i&lt;n;i++)&#123; char c=s.charAt(i); map.put(c,map.getOrDefault(c,0)+1); &#125; for(char c:map.keySet())&#123; if(map.get(c)&lt;k)&#123; int res=0; for(String str:s.split(String.valueOf(c)))&#123; res=Math.max(res,longestSubstring(str,k)); &#125; return res; &#125; &#125; return n; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 978","slug":"leetcode-978","date":"2023-02-27T03:31:23.000Z","updated":"2023-02-27T03:37:49.963Z","comments":true,"path":"posts/51562.html","link":"","permalink":"https://kkkkkong.github.io/posts/51562.html","excerpt":"","text":"题目描述978. 最长湍流子数组给定一个整数数组 arr ，返回 arr 的 最大湍流子数组的长度 。 如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 湍流子数组 。 更正式地来说，当 arr 的子数组 A[i], A[i+1], ..., A[j] 满足仅满足下列条件时，我们称其为湍流子数组： 若 1i &lt;= k &lt; j ： 当 k 为奇数时， A[k] &gt; A[k+1]，且 当 k 为偶数时，A[k] &lt; A[k+1]； 或 若 1i &lt;= k &lt; j ： 当 k 为偶数时，A[k] &gt; A[k+1] ，且 当 k 为奇数时， A[k] &lt; A[k+1]。 示例 1： 123输入：arr = [9,4,2,10,7,8,8,1,9]输出：5解释：arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5] 解题思路 滑窗，使用一个boolean类型变量记录情况， 面向测试用例编程 执行用时：6 ms, 在所有 Java 提交中击败了43.97%的用户 内存消耗：45.5 MB, 在所有 Java 提交中击败了70.82%的用户 通过测试用例：91 &#x2F; 91 时间 O(N) 空间 O(1) 123456789101112131415161718192021222324class Solution &#123; public int maxTurbulenceSize(int[] arr) &#123; int ans=0; int left=0,right=0,n=arr.length; if(n&lt;2)return n; boolean judge=arr[0]&gt;arr[1]; while(right&lt;n-1)&#123; // 如果符合条件 if((arr[right]&gt;arr[right+1])==judge&amp;&amp;arr[right]!=arr[right+1])&#123; right++; judge=!judge; &#125; else&#123; if(arr[right]==arr[right+1])right++; left=right; if(right&lt;n-1)&#123; judge=arr[right]&gt;arr[right+1]; &#125; &#125; ans=Math.max(ans,right-left+1); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 567","slug":"leetcode-567","date":"2023-02-27T02:32:34.000Z","updated":"2023-02-27T03:37:49.961Z","comments":true,"path":"posts/24299.html","link":"","permalink":"https://kkkkkong.github.io/posts/24299.html","excerpt":"","text":"题目描述567. 字符串的排列给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。 换句话说，s1 的排列之一是 s2 的 子串 。 示例 1： 123输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出：true解释：s2 包含 s1 的排列之一 (&quot;ba&quot;). 解题思路 滑窗：滑窗更新字符出现的次数，两数组相等时为true，但每次判断是否相等需要O(N)，因此使用一个变量来保存二者之间的距离 执行用时：5 ms, 在所有 Java 提交中击败了79.71%的用户 内存消耗：41.5 MB, 在所有 Java 提交中击败了46.65%的用户 通过测试用例：108 &#x2F; 108 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; // 数组存放字母出现的次数 int []s1Count=new int[26]; int []s2Count=new int[26]; // 滑窗更新字符出现的次数，两数组相等时为true，但每次判断是否相等需要O(N)，因此使用一个变量来保存二者之间的距离 int left=0,right=0,s1Len=s1.length(),s2Len=s2.length(); int diff=s1Len; for(int i=0;i&lt;s1Len;i++)&#123; s1Count[s1.charAt(i)-&#x27;a&#x27;]++; &#125; while(right&lt;s2Len)&#123; char c=s2.charAt(right); if(s2Count[c-&#x27;a&#x27;]&lt;s1Count[c-&#x27;a&#x27;])&#123; diff--; &#125; else&#123; diff++; &#125; s2Count[c-&#x27;a&#x27;]++; right++; if(right-left&gt;s1Len)&#123; char c2=s2.charAt(left); if(s2Count[c2-&#x27;a&#x27;]&lt;=s1Count[c2-&#x27;a&#x27;])&#123; diff++; &#125; else&#123; diff--; &#125; s2Count[c2-&#x27;a&#x27;]--; left++; &#125; if(diff==0)return true; &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"JVM 学习","slug":"JVM-学习","date":"2023-02-22T11:31:11.000Z","updated":"2023-02-27T03:37:49.959Z","comments":true,"path":"posts/34491.html","link":"","permalink":"https://kkkkkong.github.io/posts/34491.html","excerpt":"","text":"经典面试题内存管理 介绍下 Java 内存区域（运行时数据区） （方法区、堆）线程共享，不安全 （栈、本地方法区、程序计数器）线程独享，安全 Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）1. 对象的访问定位的两种方式（句柄和直接指针两种方式） 垃圾回收 如何判断对象是否死亡（两种方法）。 引用计数法 给对象中添加一个引用计数器 每当有一个地方引用它，计数器加一 当引用失效时，计数器减一 任何时候计数器为0都说明对象不可能再被使用了 此方法简单，效率高。但目前主流的虚拟机并没有使用该方法，因为无法解决循环引用问题 可达性分析算法 基本思想是通过一些列“GC root” 的对象作为起点，从这些节点向下搜索，节点走过的路径称为引用链，当一个对象到GC root没有任何引用链的时候，则证明该对象是不可用的，需要回收。 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。 强引用 软引用 弱引用 虚引用 如何判断一个常量是废弃常量 没有被任何String对象引用的常量就是废弃常量 如何判断一个类是无用的类 三点 加载该类的Classloader被回收 类对应的实例都被回收 该类对应的java.lang.class对象没有在任何地方被引用，也无法通过反射机制访问该类的方法 垃圾收集有哪些算法，各自的特点？ 标记清除-容易产生碎片 标记复制-占用空间比较大 标记整理- 分代回收- 将java堆中的对象分为新生代、老年代和永久代 HotSpot 为什么要分为新生代和老年代？ 方便垃圾回收，新生代每次回收都会有大量对象死去，因此选用标记清除算法，每次只需要少量的对象复制空间即可完成回收；而老年代多是存活纪律较高的对象，而且没有额外的空间去怼他进行分配担保，所以选用标记清除或标记整理进行回收 常见的垃圾回收器有哪些？ serial收集器 parNew Parallel Scavenge Serial Old Parallel Old CMS 以获取最短回收时间为目标的收集器，第一个真正的并发收集器 G1 ZGC 介绍一下 CMS,G1 收集器。1. Minor Gc 和 Full GC 有什么不同呢？ Minor GC 回收年轻代 Full GC： 负责从整个内存区回收","categories":[{"name":"Java","slug":"Java","permalink":"https://kkkkkong.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kkkkkong.github.io/tags/Java/"}]},{"title":"leetcode 438","slug":"leetcode-438","date":"2023-02-21T06:29:10.000Z","updated":"2023-02-21T06:34:06.139Z","comments":true,"path":"posts/51961.html","link":"","permalink":"https://kkkkkong.github.io/posts/51961.html","excerpt":"","text":"题目描述438. 找到字符串中所有字母异位词给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 解题思路 数组差+滑窗，用两个数组分别表示字符串p中字母出现的次数以及滑窗中字母出现的次数，方便统计，采用变量diff表示两个数组的不同字母数。diff为0时，将left指针加入结果集中 执行用时：8 ms, 在所有 Java 提交中击败了67.39%的用户 内存消耗：42.7 MB, 在所有 Java 提交中击败了38.45%的用户 通过测试用例：64 &#x2F; 64 时间 O(N) 空间 O(N) 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; int []ptmp=new int [26]; int []stmp=new int [26]; int left=0,right=0,n=s.length(); int plen=p.length(); int diff=plen; List&lt;Integer&gt; ans=new ArrayList(); for(int i=0;i&lt;plen;i++)&#123; ptmp[p.charAt(i)-&#x27;a&#x27;]++; &#125; while(right&lt;n)&#123; if(right-left+1&gt;plen)&#123; if(stmp[s.charAt(left)-&#x27;a&#x27;]&lt;=ptmp[s.charAt(left)-&#x27;a&#x27;])&#123; diff++; &#125; else&#123; diff--; &#125; stmp[s.charAt(left)-&#x27;a&#x27;]--; left++; &#125; else&#123; if(stmp[s.charAt(right)-&#x27;a&#x27;]&gt;=ptmp[s.charAt(right)-&#x27;a&#x27;])&#123; diff++; &#125; else&#123; diff--; &#125; stmp[s.charAt(right)-&#x27;a&#x27;]++; right++; &#125; if(diff==0)&#123; ans.add(left); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1004","slug":"leetcode-1004","date":"2023-02-21T02:13:15.000Z","updated":"2023-02-21T06:34:06.129Z","comments":true,"path":"posts/39420.html","link":"","permalink":"https://kkkkkong.github.io/posts/39420.html","excerpt":"","text":"题目描述1004. 最大连续1的个数 III给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。 示例 1： 1234输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释：[1,1,1,0,0,1,1,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 6。 解题思路 滑窗，数组中只有1和0，可以用做和的形式来表示，左指针移动的条件为right-left+1&gt;sum+k 执行用时：4 ms, 在所有 Java 提交中击败了17.57%的用户 内存消耗：43.2 MB, 在所有 Java 提交中击败了20.81%的用户 通过测试用例：52 &#x2F; 52 时间 O(N) 空间O(1) 123456789101112131415161718class Solution &#123; public int longestOnes(int[] nums, int k) &#123; int sum=0,left=0,right=0,ans=0; int n=nums.length; while(right&lt;n)&#123; sum+=nums[right]; if(right-left+1&lt;=sum+k)&#123; right++; &#125; else&#123; sum-=nums[left]; left++; &#125; ans=Math.max(ans,right-left); &#125; return ans; &#125;&#125; 精简一下，因为在一次左指针移动后，下次循环必定不会再进if，所以默认每次right++，减少循环次数 执行用时：3 ms, 在所有 Java 提交中击败了69.83%的用户 内存消耗：42.6 MB, 在所有 Java 提交中击败了91.21%的用户 通过测试用例：52 &#x2F; 52 时间 O(N) 空间 O(1) 12345678910111213141516class Solution &#123; public int longestOnes(int[] nums, int k) &#123; int sum=0,left=0,right=0,ans=0; int n=nums.length; while(right&lt;n)&#123; sum+=nums[right]; if(right-left+1&gt;sum+k)&#123; sum-=nums[left]; left++; &#125; right++; ans=Math.max(ans,right-left); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 424","slug":"leetcode-424","date":"2023-02-21T01:46:17.000Z","updated":"2023-02-21T06:34:06.136Z","comments":true,"path":"posts/24568.html","link":"","permalink":"https://kkkkkong.github.io/posts/24568.html","excerpt":"","text":"题目描述424. 替换后的最长重复字符给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。 在执行上述操作后，返回包含相同字母的最长子字符串的长度。 示例 1： 123输入：s = &quot;ABAB&quot;, k = 2输出：4解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。 解题思路 数组+滑窗：两个关键条件，一个是maxcount，表示当前窗口内的单个单词的最大数目；另一个是left向前移动的条件，right-left&gt;max+k，巧妙的进行了控制 执行用时：8 ms, 在所有 Java 提交中击败了29.40%的用户 内存消耗：41.3 MB, 在所有 Java 提交中击败了53.10%的用户 通过测试用例：37 &#x2F; 37 时间 O(N) 空间 O(N) 1234567891011121314151617181920class Solution &#123; public int characterReplacement(String s, int k) &#123; int []tmp=new int [26]; int left=0,right=0,ans=0; int n=s.length(); int maxCount=0; while(right&lt;n)&#123; tmp[s.charAt(right)-&#x27;A&#x27;]++; maxCount=Math.max(maxCount,tmp[s.charAt(right)-&#x27;A&#x27;]); right++; if(right-left&gt;maxCount+k)&#123; tmp[s.charAt(left)-&#x27;A&#x27;]--; left++; &#125; ans=Math.max(ans,right-left); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 219","slug":"leetcode-219","date":"2023-02-20T02:31:47.000Z","updated":"2023-02-20T02:35:47.759Z","comments":true,"path":"posts/27609.html","link":"","permalink":"https://kkkkkong.github.io/posts/27609.html","excerpt":"","text":"题目描述219. 存在重复元素 II给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。 示例 1： 12输入：nums = [1,2,3,1], k = 3输出：true 解题思路 哈希表+滑动窗口 执行用时：16 ms, 在所有 Java 提交中击败了84.97%的用户 内存消耗：51.8 MB, 在所有 Java 提交中击败了34.72%的用户 通过测试用例：54 &#x2F; 54 时间 O(N) 空间 O(N) 123456789101112131415161718192021 class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set=new HashSet(); int left=0,right=0; int n=nums.length; while(right&lt;n)&#123; if(right-left&lt;=k)&#123; if(set.contains(nums[right]))&#123; return true; &#125; set.add(nums[right]); right++; &#125; else&#123; set.remove(nums[left]); left++; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 3","slug":"leetcode-3","date":"2023-02-20T02:00:47.000Z","updated":"2023-02-20T02:16:10.203Z","comments":true,"path":"posts/41773.html","link":"","permalink":"https://kkkkkong.github.io/posts/41773.html","excerpt":"","text":"题目描述3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 解题思路 滑动窗口+哈希表：右指针前进条件，set中不包含right指向元素，否则左指针前进，并移除掉当前左指针指向元素。 执行用时：5 ms, 在所有 Java 提交中击败了58.48%的用户 内存消耗：41.3 MB, 在所有 Java 提交中击败了91.46%的用户 通过测试用例：987 &#x2F; 987 时间 O(N) 空间 O(N) 12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); if(n&lt;2)return n; int left=0,right=0,ans=0; Set&lt;Character&gt; set=new HashSet(); int len=0; while(right&lt;n)&#123; char c=s.charAt(right); if(!set.contains(c))&#123; len++; right++; set.add(c); &#125; else&#123; len--; set.remove(s.charAt(left)); left++; &#125; ans=Math.max(ans,len); &#125; return ans; &#125;&#125; 滑动窗口+数组：优化1，使用数组存放，ASCII编码，使用128大小的数组存放 执行用时：2 ms, 在所有 Java 提交中击败了92.81%的用户 内存消耗：41.2 MB, 在所有 Java 提交中击败了96.93%的用户 通过测试用例：987 &#x2F; 987 时间 O(N) 空间 O(1) 123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); if(n&lt;2)return n; int left=0,right=0,ans=0; int []tmp=new int[128]; int len=0; while(right&lt;n)&#123; char c=s.charAt(right); if(tmp[c]==0)&#123; len++; right++; tmp[c]=1; &#125; else&#123; len--; tmp[s.charAt(left)]=0; left++; &#125; ans=Math.max(ans,len); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 523","slug":"leetcode-523","date":"2023-02-20T01:08:11.000Z","updated":"2023-02-20T02:16:10.208Z","comments":true,"path":"posts/24040.html","link":"","permalink":"https://kkkkkong.github.io/posts/24040.html","excerpt":"","text":"题目描述523. 连续的子数组和给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。 示例 1： 123输入：nums = [23,2,4,6,7], k = 6输出：true解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。 解题思路 哈希表+同余定理+前缀和 执行用时：25 ms, 在所有 Java 提交中击败了9.51%的用户 内存消耗：56.9 MB, 在所有 Java 提交中击败了59.05%的用户 通过测试用例：98 &#x2F; 98 时间 O(N) 空间 O(N) 123456789101112131415161718class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); map.put(0,-1); int sum=0,n=nums.length; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; int mod=sum%k; int value=map.getOrDefault(mod,-2); if(value!=-2&amp;&amp;i-value&gt;1)&#123; return true; &#125; map.put(mod,map.getOrDefault(mod,i)); &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 974","slug":"leetcode-974","date":"2023-02-19T08:52:01.000Z","updated":"2023-02-19T08:57:55.890Z","comments":true,"path":"posts/52330.html","link":"","permalink":"https://kkkkkong.github.io/posts/52330.html","excerpt":"","text":"题目描述974. 和可被 K 整除的子数组给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的（连续、非空） 子数组 的数目。 子数组 是数组的 连续 部分。 示例 1： 12345输入：nums = [4,5,0,-2,-3,1], k = 5输出：7解释：有 7 个子数组满足其元素之和可被 k = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 解题思路 前缀和+同余定理+哈希表，a和b对k的余数相同，那么(a-b)对k取余为0 执行用时：16 ms, 在所有 Java 提交中击败了81.95%的用户 内存消耗：47.6 MB, 在所有 Java 提交中击败了5.25%的用户 通过测试用例：73 &#x2F; 73 时间 O(N) 空间 O(N) 1234567891011121314151617class Solution &#123; public int subarraysDivByK(int[] nums, int k) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); map.put(0,1); int ans=0,sum=0,n=nums.length; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; int mod=(sum%k+k)%k; int value=map.getOrDefault(mod,0); if(value!=0)&#123; ans+=value; &#125; map.put(mod,value+1); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 930","slug":"leetcode-930","date":"2023-02-19T07:17:09.000Z","updated":"2023-02-19T08:02:27.999Z","comments":true,"path":"posts/53097.html","link":"","permalink":"https://kkkkkong.github.io/posts/53097.html","excerpt":"","text":"题目描述930. 和相同的二元子数组给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。 子数组 是数组的一段连续部分。 示例 1： 1234输入：nums = [1,0,1,0,1], goal = 2输出：4解释：有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1] 解题思路 哈希表+前缀和：hashmap存放sum出现的次数 执行用时：20 ms, 在所有 Java 提交中击败了59.25%的用户 内存消耗：46.1 MB, 在所有 Java 提交中击败了35.95%的用户 通过测试用例：60 &#x2F; 60 时间 O(N) 空间 O(N) 123456789101112131415161718class Solution &#123; public int numSubarraysWithSum(int[] nums, int goal) &#123; // hashmap存放sum出现的次数 Map &lt;Integer,Integer&gt; map=new HashMap(); map.put(0,1); int n=nums.length; int sum=0,ans=0;; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; int value=map.getOrDefault(sum-goal,-1); if(value!=-1)&#123; ans+=value; &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return ans; &#125;&#125; 滑动窗口，重点打开思路，因为数组中只有0和1，需要使用两个左指针来表示right固定的情况下，有多少种情况满足 执行用时：3 ms, 在所有 Java 提交中击败了78.77%的用户 内存消耗：45.2 MB, 在所有 Java 提交中击败了60.27%的用户 通过测试用例：60 &#x2F; 60 时间 O(N) 空间 O(1) 123456789101112131415161718192021class Solution &#123; public int numSubarraysWithSum(int[] nums, int goal) &#123; int n=nums.length; int left1=0,left2=0,right=0,ans=0,sum1=0,sum2=0; while(right&lt;n)&#123; sum1+=nums[right]; while(left1&lt;=right&amp;&amp;sum1&gt;goal)&#123; sum1-=nums[left1]; left1++; &#125; sum2+=nums[right]; while(left2&lt;=right&amp;&amp;sum2&gt;=goal)&#123; sum2-=nums[left2]; left2++; &#125; ans+=left2-left1; right++; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 724","slug":"leetcode-724","date":"2023-02-19T02:26:13.000Z","updated":"2023-02-19T08:02:27.997Z","comments":true,"path":"posts/24328.html","link":"","permalink":"https://kkkkkong.github.io/posts/24328.html","excerpt":"","text":"题目描述724. 寻找数组的中心下标给你一个整数数组 nums ，请计算数组的 中心下标 。 数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。 如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。 示例 1： 123456输入：nums = [1, 7, 3, 6, 5, 6]输出：3解释：中心下标是 3 。左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。 解题思路 前缀和 执行用时：1 ms, 在所有 Java 提交中击败了73.45%的用户 内存消耗：42.4 MB, 在所有 Java 提交中击败了32.02%的用户 通过测试用例：746 &#x2F; 746 时间 O(N) 空间 O(N) 123456789101112131415class Solution &#123; public int pivotIndex(int[] nums) &#123; int n=nums.length; int []sum=new int [n+1]; for(int i=1;i&lt;n+1;i++)&#123; sum[i]=sum[i-1]+nums[i-1]; &#125; for(int i=0;i&lt;n;i++)&#123; if(sum[i]==sum[n]-sum[i+1])&#123; return i; &#125; &#125; return -1; &#125;&#125; 前缀和优化，不需要使用数组存储，只需要用一个变量记录当前的数组和是多少即可 执行用时：3 ms, 在所有 Java 提交中击败了36.89%的用户 内存消耗：42 MB, 在所有 Java 提交中击败了75.86%的用户 通过测试用例：746 &#x2F; 746 时间 O(N) 空间 O(1) 一样的代码，运行两次，也不知道是为何两次差距这么大 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：42.6 MB, 在所有 Java 提交中击败了10.93%的用户 通过测试用例：746 &#x2F; 746 123456789101112131415161718class Solution &#123; public int pivotIndex(int[] nums) &#123; int n=nums.length; int sum=0; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; int pre=0; for(int i=0;i&lt;n;i++)&#123; if(pre==sum-pre-nums[i])&#123; return i; &#125; pre+=nums[i]; &#125; return -1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 560","slug":"leetcode-560","date":"2023-02-18T07:49:42.000Z","updated":"2023-02-18T08:04:17.660Z","comments":true,"path":"posts/40106.html","link":"","permalink":"https://kkkkkong.github.io/posts/40106.html","excerpt":"","text":"题目描述560. 和为 K 的子数组给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。 示例 1： 12输入：nums = [1,1,1], k = 2输出：2 解题思路 哈希表+前缀和：查找tmp[i]-k出现的次数 执行用时：17 ms, 在所有 Java 提交中击败了98.66%的用户 内存消耗：45.6 MB, 在所有 Java 提交中击败了39.34%的用户 通过测试用例：93 &#x2F; 93 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map &lt;Integer,Integer&gt; map=new HashMap(); int n=nums.length; int []tmp=new int[n]; int ans=0; tmp[0]=nums[0]; for(int i=1;i&lt;n;i++)&#123; tmp[i]=tmp[i-1]+nums[i]; &#125; // 查找tmp[i]-k出现的次数 for(int i=0;i&lt;n;i++)&#123; int q=tmp[i]-k; if(q==0)&#123; ans++; &#125; int value=map.getOrDefault(q,0); if(value!=0)&#123; ans+=value; &#125; map.put(tmp[i],map.getOrDefault(tmp[i],0)+1); &#125; return ans; &#125;&#125; 方法一的优化，笑死，优化完，时间翻倍了 执行用时：29 ms, 在所有 Java 提交中击败了40.76%的用户 内存消耗：44.9 MB, 在所有 Java 提交中击败了63.23%的用户 通过测试用例：93 &#x2F; 93 时间 O(N) 空间 O(N) 1234567891011121314151617class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map &lt;Integer,Integer&gt; map=new HashMap(); map.put(0,1); int ans=0,sum=0; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; int q=sum-k; int value=map.getOrDefault(q,0); if(value!=0)&#123; ans+=value; &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 528","slug":"leetcode-528","date":"2023-02-18T03:41:24.000Z","updated":"2023-02-18T08:04:17.656Z","comments":true,"path":"posts/39593.html","link":"","permalink":"https://kkkkkong.github.io/posts/39593.html","excerpt":"","text":"题目描述528. 按权重随机选择给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。 请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 示例 1： 12345678输入：[&quot;Solution&quot;,&quot;pickIndex&quot;][[[1]],[]]输出：[null,0]解释：Solution solution = new Solution([1]);solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 解题思路 前缀和+二分查找，重点是将权重数组以前缀和的形式表示出来，假设总权重和为sum，那么在[1,sum]上随机取数字，落在权重大的区间上的概率更大。二分查找只是更快的查到下标最大的小于x的区间在哪 int x&#x3D;(int)(Math.random()*sum)+1;的取值很重要，random返回的是[0,1)的数字，不加1永远取不到sum的右边界 执行用时：25 ms, 在所有 Java 提交中击败了45.06%的用户 内存消耗：45.8 MB, 在所有 Java 提交中击败了80.66%的用户 通过测试用例：57 &#x2F; 57 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; int []pre; int sum=0; public Solution(int[] w) &#123; pre=new int[w.length]; pre[0]=w[0]; for(int i=1;i&lt;w.length;i++)&#123; pre[i]=pre[i-1]+w[i]; &#125; sum=Arrays.stream(w).sum(); &#125; public int pickIndex() &#123; int x=(int)(Math.random()*sum)+1; return binarySearch(pre,x); &#125; public int binarySearch(int []pre,int x)&#123; int left=0,right=pre.length-1; while(left&lt;right)&#123; int mid=(left+right)/2; if(pre[mid]&lt;x)&#123; left=mid+1; &#125; else&#123; right=mid; &#125; &#125; return left; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(w); * int param_1 = obj.pickIndex(); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 525","slug":"leetcode-525","date":"2023-02-17T03:20:26.000Z","updated":"2023-02-17T07:15:50.902Z","comments":true,"path":"posts/24424.html","link":"","permalink":"https://kkkkkong.github.io/posts/24424.html","excerpt":"","text":"题目描述525. 连续数组给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 123输入: nums = [0,1]输出: 2说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。 解题思路 这里的变0为-1真的是神来之笔 前缀和+变0为-1，将0变为-1后，主要统计前缀和，将第一次出现的元素保存到map中。特殊的，和为0的表示天然符合题目要求 执行用时：13 ms, 在所有 Java 提交中击败了97.19%的用户 内存消耗：49.6 MB, 在所有 Java 提交中击败了95.36%的用户 通过测试用例：564 &#x2F; 564 时间 O(n) 空间 O(n) 123456789101112131415161718192021222324252627class Solution &#123; public int findMaxLength(int[] nums) &#123; int n=nums.length; int ans =0; for(int i=0;i&lt;n;i++)&#123; if(nums[i]==0)nums[i]=-1; &#125; int sum=0; // 存放第一个和为k的元素位置 HashMap&lt;Integer,Integer&gt; map=new HashMap(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(sum==0)&#123; ans=Math.max(ans,i+1); &#125; int tmp=map.getOrDefault(sum,-1); if(tmp==-1)&#123; map.put(sum,i); &#125; else&#123; ans=Math.max(ans,i-tmp); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 209","slug":"leetcode-209","date":"2023-02-17T02:14:09.000Z","updated":"2023-02-17T07:15:50.900Z","comments":true,"path":"posts/64472.html","link":"","permalink":"https://kkkkkong.github.io/posts/64472.html","excerpt":"","text":"题目描述209. 长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 解题思路 前缀和+二分查找 时空 O(NLogN) O(1) 前缀和作差+滑动窗口，这里的额外数组使用n+1长度更舒服，tmp[i]表示前i个元素的和 执行用时：2 ms, 在所有 Java 提交中击败了15.24%的用户 内存消耗：49.6 MB, 在所有 Java 提交中击败了7.48%的用户 通过测试用例：20 &#x2F; 20 时间 O(N) 空间 O(N) 123456789101112131415161718192021222324252627282930class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n=nums.length; // 数组计数，tmp[i]表示前i个元素的和 int []tmp=new int[n]; tmp[0]=nums[0]; for(int i=1;i&lt;n;i++)&#123; tmp[i]=tmp[i-1]+nums[i]; &#125; if(tmp[n-1]&lt;target)return 0; if(tmp[0]&gt;=target)return 1; int i=0,j=0,ans=Integer.MAX_VALUE; while(j&lt;n)&#123; if(tmp[j]&gt;=target)&#123; ans=Math.min(ans,j+1); &#125; if(tmp[j]-tmp[i]&lt;target)&#123; j++; &#125; else&#123; while(tmp[j]-tmp[i]&gt;=target)&#123; ans=Math.min(ans,j-i); i++; &#125; &#125; &#125; return ans; &#125;&#125; 前缀和+滑动窗口，改进版 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：49.2 MB, 在所有 Java 提交中击败了14.99%的用户 通过测试用例：20 &#x2F; 20 时间 O(N) 空间 O(1) 123456789101112131415class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n=nums.length; int ans=Integer.MAX_VALUE; int start=0,end=0,sum=0; while(end&lt;n)&#123; sum+=nums[end++]; while(sum&gt;=target)&#123; ans=Math.min(ans,end-start); sum-=nums[start++]; &#125; &#125; return ans==Integer.MAX_VALUE?0:ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2341","slug":"leetcode-2341","date":"2023-02-16T01:09:05.000Z","updated":"2023-02-16T02:35:57.104Z","comments":true,"path":"posts/7886.html","link":"","permalink":"https://kkkkkong.github.io/posts/7886.html","excerpt":"","text":"题目描述2341. 数组能形成多少数对给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤： 从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。 示例 1： 1234567输入：nums = [1,3,2,1,3,2,2]输出：[3,1]解释：nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 解题思路 排序+枚举：排序后遍历数组，如果一个数和他后面的数相等，那么说明这两个数需要移除，否则继续向后移动 时间 O(NLogN) 空间 O(N) 123456789101112131415class Solution &#123; public int[] numberOfPairs(int[] nums) &#123; int n=nums.length; int []ans=new int []&#123;0,n&#125;; Arrays.sort(nums); for(int i=0;i&lt;n-1;i++)&#123; if(nums[i]==nums[i+1])&#123; i++; ans[0]++; ans[1]-=2; &#125; &#125; return ans; &#125;&#125; 哈希+枚举 执行用时：1 ms, 在所有 Java 提交中击败了54.00%的用户 内存消耗：40.3 MB, 在所有 Java 提交中击败了40.80%的用户 通过测试用例：128 &#x2F; 128 时间 O(N) 空间 O(N) 1234567891011121314class Solution &#123; public int[] numberOfPairs(int[] nums) &#123; int n=nums.length; int ans=0; Map&lt;Integer,Boolean&gt; map=new HashMap(); for(int i:nums)&#123; map.put(i,!map.getOrDefault(i,true)); if(map.get(i))&#123; ans++; &#125; &#125; return new int[]&#123;ans,n-ans*2&#125;; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 647","slug":"leetcode-647","date":"2023-02-15T01:38:38.000Z","updated":"2023-02-16T02:35:57.106Z","comments":true,"path":"posts/15898.html","link":"","permalink":"https://kkkkkong.github.io/posts/15898.html","excerpt":"","text":"题目描述647. 回文子串给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 123输入：s = &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 解题思路 找规律+中心扩展法：参考题解，非常巧妙的应用了回文串的规律，将回文串的长度分为奇偶两种情况，枚举每一个回文中心，并用两个指针向左右两边扩展，两个指针指向相同的时候，就扩展，否则就返回 执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户 内存消耗：39.4 MB, 在所有 Java 提交中击败了84.78%的用户 通过测试用例：130 &#x2F; 130 时间 O(N*N) 空间 O(1) 12345678910111213141516171819class Solution &#123; int num=0; public int countSubstrings(String s) &#123; int n=s.length(); for(int i=0;i&lt;n;i++)&#123; count(s,i,i); count(s,i,i+1); &#125; return num; &#125; public void count(String s,int start,int end)&#123; while(start&gt;=0&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))&#123; num++; start--; end++; &#125; &#125;&#125; 马拉车算法，还没吃透 执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户 内存消耗：39.6 MB, 在所有 Java 提交中击败了75.45%的用户 通过测试用例：130 &#x2F; 130 时间 O(N) 空间 O(1) 1234567891011121314151617181920212223242526class Solution &#123; public int countSubstrings(String s) &#123; int n=s.length(); StringBuffer t=new StringBuffer(&quot;$#&quot;); for(int i=0;i&lt;n;i++)&#123; t.append(s.charAt(i)); t.append(&#x27;#&#x27;); &#125; n=t.length(); t.append(&#x27;!&#x27;); int []f=new int[n]; int iMax=0,rMax=0,ans=0; for(int i=1;i&lt;n;i++)&#123; f[i]=i&lt;=rMax?Math.min(rMax-i+1,f[2*iMax-i]):1; while(t.charAt(i+f[i])==t.charAt(i-f[i]))&#123; ++f[i]; &#125; if(i+f[i]-1&gt;rMax)&#123; iMax=i; rMax=i+f[i]-1; &#125; ans+=f[i]/2; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1124","slug":"leetcode-1124","date":"2023-02-14T12:29:10.000Z","updated":"2023-02-14T13:04:05.775Z","comments":true,"path":"posts/14764.html","link":"","permalink":"https://kkkkkong.github.io/posts/14764.html","excerpt":"","text":"题目描述1124. 表现良好的最长时间段给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1： 123输入：hours = [9,9,6,0,6,6,9]输出：3解释：最长的表现良好时间段是 [9,9,6]。 解题思路 哈希表+前缀和：将原问题转化为和大于0的最小子数组的问题，通过前缀和求解。 如果hours[i]&gt;8，则arr[i]为1，否则为-1，然后再用arr[i]表示前i个元素的和，要寻找i和j，使得在i&lt;j时，arr[i]-arr[j]&gt;0（也就意味着i到j之间的和大于0，也即问题的求解） 对于arr[i]，有两种情况 arr[i]&gt;0，表示前i+1个元素的和是表现良好的时间段 arr[i]&lt;&#x3D;0，则需要找到一个j，满足j&lt;i，arr[i]-arr[j]&gt;0，对于arr[j]来说，存在两种情况 j&lt;i时，不存在arr[i]-arr[j]&gt;0， j&lt;i时，存在arr[i]-arr[j]&gt;0，那么此时也一定存在arr[i]-arr[j]&#x3D;1，也即arr[j]&#x3D;arr[i]-1，使用哈希表存储第一次出现的arr[j]即可 执行用时：8 ms, 在所有 Java 提交中击败了70.25%的用户 内存消耗：42.1 MB, 在所有 Java 提交中击败了44.50%的用户 通过测试用例：98 &#x2F; 98 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526class Solution &#123; public int longestWPI(int[] hours) &#123; int n=hours.length; int [] arr=new int[n]; int ans=0; Map&lt;Integer,Integer&gt; map=new HashMap(); arr[0]=hours[0]&gt;8?1:-1; for(int i=1;i&lt;n;i++)&#123; arr[i]=arr[i-1]+(hours[i]&gt;8?1:-1); &#125; for(int i=0;i&lt;n;i++)&#123; if(arr[i]&gt;0)&#123; ans=Math.max(ans,i+1); &#125; else&#123; int tmp=map.getOrDefault(arr[i]-1,-1); if(tmp!=-1)&#123; ans=Math.max(ans,i-tmp); &#125; map.putIfAbsent(arr[i],i); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1234","slug":"leetcode-1234","date":"2023-02-13T09:30:25.000Z","updated":"2023-02-13T09:32:31.228Z","comments":true,"path":"posts/43357.html","link":"","permalink":"https://kkkkkong.github.io/posts/43357.html","excerpt":"","text":"题目描述1234. 替换子串得到平衡字符串有一个只含有 &#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39; 四种字符，且长度为 n 的字符串。 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。 给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。 请返回待替换子串的最小可能长度。 如果原字符串自身就是一个平衡字符串，则返回 0。 示例 1： 123输入：s = &quot;QWER&quot;输出：0解释：s 已经是平衡的了。 解题思路 暴力解法，超时了 滑动窗口，重要的是窗口左右移动的时机 执行用时：10 ms, 在所有 Java 提交中击败了22.95%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了43.44%的用户 通过测试用例：40 &#x2F; 40 时间 O(N) 空间 O(1) 1234567891011121314151617181920212223class Solution &#123; public int balancedString(String s) &#123; int []cnt=new int[4]; String t=&quot;QWER&quot;; int n=s.length(); for(int i=0;i&lt;n;i++)&#123; cnt[t.indexOf(s.charAt(i))]++; &#125; int m=n/4; if(cnt[0]==m&amp;&amp;cnt[1]==m&amp;&amp;cnt[2]==m&amp;&amp;cnt[3]==m)&#123; return 0; &#125; int ans=n; for(int i=0,j=0;j&lt;n;j++)&#123; cnt[t.indexOf(s.charAt(j))]--; while(i&lt;=j&amp;&amp;cnt[0]&lt;=m&amp;&amp;cnt[1]&lt;=m&amp;&amp;cnt[2]&lt;=m&amp;&amp;cnt[3]&lt;=m)&#123; ans=Math.min(ans,j-i+1); cnt[t.indexOf(s.charAt(i++))]++; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"CPU架构","slug":"CPU指令集","date":"2023-02-13T07:04:00.000Z","updated":"2023-02-13T09:32:31.225Z","comments":true,"path":"posts/27701.html","link":"","permalink":"https://kkkkkong.github.io/posts/27701.html","excerpt":"","text":"主流CPU指令集 架构 指令集位数 来源 x86 32 Intel开发，CPU架构习惯以86结尾，所以之后被称之为x86 AMD64 64 32位向64位演进时，AMD更早的开发除了兼容x86(32位)指令集的处理器 x86_64 64 Intel为了迈向64位，设计了IA-64（不兼容x86），但反响不好，因此采用了AMD64，并在此基础进行扩充，改名为x86_64，两种差别不大（现在用的intel&#x2F;amd的桌面级CPU基本上都是x86_64） ARM ARM-V8 x86是一种CISC的指令集 非x86，一般是RISC指令集","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"leetcode 39","slug":"leetcode-39","date":"2023-02-13T02:23:12.000Z","updated":"2023-03-06T09:37:55.101Z","comments":true,"path":"posts/4003.html","link":"","permalink":"https://kkkkkong.github.io/posts/4003.html","excerpt":"","text":"题目描述39. 组合总和给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 解题思路 回溯+深度优先搜索+递归 图片来源：题解 使用一个数字，target做减法，不断减少直到target&lt;&#x3D;0，但这样做会出现重复路径，因此需要去重 去重方法为：同一层的节点，已经使用过的数字不在考虑，也即 执行用时：2 ms, 在所有 Java 提交中击败了75.79%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了82.05%的用户 通过测试用例：160 &#x2F; 160 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList(); int len=candidates.length; ArrayDeque&lt;Integer&gt; path=new ArrayDeque(); dfs(candidates,0,len,path,target,ans); return ans; &#125; public void dfs(int [] candidates,int begin,int len,ArrayDeque&lt;Integer&gt; path,int target,List&lt;List&lt;Integer&gt;&gt; ans)&#123; if(target&lt;0)&#123; return ; &#125; if(target==0)&#123; ans.add(new ArrayList(path)); return ; &#125; for(int i=begin;i&lt;len;i++)&#123; path.addLast(candidates[i]); dfs(candidates,i,len,path,target-candidates[i],ans); path.removeLast(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728// 剪枝之后class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList(); int len=candidates.length; Arrays.sort(candidates); ArrayDeque&lt;Integer&gt; path=new ArrayDeque(); dfs(candidates,0,len,path,target,ans); return ans; &#125; public void dfs(int [] candidates,int begin,int len,ArrayDeque&lt;Integer&gt; path,int target,List&lt;List&lt;Integer&gt;&gt; ans)&#123; if(target==0)&#123; ans.add(new ArrayList(path)); return ; &#125; for(int i=begin;i&lt;len;i++)&#123; if(target-candidates[i]&lt;0)&#123; break; &#125; path.addLast(candidates[i]); dfs(candidates,i,len,path,target-candidates[i],ans); path.removeLast(); &#125; &#125;&#125; 回溯：元素无重复的可重复选的组合问题。重点在于start的位置 执行用时：2 ms, 在所有 Java 提交中击败了75.99%的用户 内存消耗：41.3 MB, 在所有 Java 提交中击败了98.76%的用户 通过测试用例：160 &#x2F; 160 时间 O(N) 空间 O(N) 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList(); List&lt;Integer&gt; list=new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; backTrack(candidates,target,0); return ans; &#125; public void backTrack(int []candidates,int target,int start)&#123; if(target==0)&#123; ans.add(new ArrayList(list)); return ; &#125; if(target&lt;0)return ; for(int i=start;i&lt;candidates.length;i++)&#123; list.add(candidates[i]); backTrack(candidates,target-candidates[i],i); list.remove(list.size()-1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"DragonOS 实时调度器相关API","slug":"DragonOS-实时调度器相关API","date":"2023-02-12T01:55:50.000Z","updated":"2023-02-12T12:20:33.233Z","comments":true,"path":"posts/56746.html","link":"","permalink":"https://kkkkkong.github.io/posts/56746.html","excerpt":"","text":"实时进程调度器相关的api&amp;emsp;&amp;emsp; RT（realtime scheduler），实时调度器。实时调度是为了完成实时处理任务而分配CPU的调度方法。 &amp;emsp;&amp;emsp;DragonOS的进程分为“实时进程”和“普通进程”两类；实时进程的优先级高于普通进程，如果当前的系统的执行队列中有“实时进程”，RT调度器会优先选择实时进程；如果队列中会有多个实时进程，调度器会选择优先级最高的实时进程来执行； 1. RTQueue 介绍&amp;emsp;&amp;emsp; RTQueue是用来存放state为running的实时进程的调度队列，每个CPU维护一个RTQueue，主要使用Vec作为主要存储结构来实现。 1.1 主要函数 enqueue(): 将pcb入队列 dequeue(): 将pcb出队列 2. SchedulerRT 介绍&amp;emsp;&amp;emsp; RT调度器类，主要实现了RT调度器类的初始化以及调度功能函数。 2.1 主要函数 pick_next_task_rt(): 获取当前CPU中的第一个需要执行的RT pcb sched(): 是对于Scheduler trait的sched()实现，是实时进程进行调度时的逻辑处理，该函数会返回接下来要执行的pcb，若没有符合要求的pcb，返回None enqueue(): 同样是对于Scheduler trait的sched()实现，将一个pcb加入调度器的调度队列 2.2 内核调度策略目前在DragonOS中，主要的调度策略有SCHED_NORMAL 策略 | SCHED_FIFO 策略 | SCHED_RT 策略，具体的调度策略为： SCHED_NORMAL 策略：SCHED_NORMAL 是“绝对公平调度策略”，该策略的进程使用CFS进行调度。 SCHED_FIFO 策略：SCHED_FIFO是“实时进程调度策略”，这是一种先进先出的调度策略，该策略不涉及到CPU时间片机制，在没有更高优先级进程的前提下，只能等待其他进程主动释放CPU资源；在SCHED_FIFO策略中，被调度器调度运行的进程，其运行时长不受限制，可以运行任意长的时间。 SCHED_RR 策略：SCHED_RR是“实时进程调度策略”，使用的是时间片轮转机制，对应进程的time_slice会在运行时减少，进程使用完CPU时间片后，会加入该CPU的与该进程优先级相同的执行队列中。同时，释放CPU资源，CPU的使用权会被分配给下一个执行的进程 3. Q&amp;A 如何创建实时进程 1struct process_control_block *pcb_name = kthread_run_rt(&amp;fn_name, NULL, &quot;test create rt pcb&quot;); 其中kthread_run_rt，是创建内核实时线程的宏 pcb中涉及到实时进程的字段含义 policy：实时进程的策略，目前有：SCHED_FIFO与SCHED_RR priority: 实时进程的优先级，范围为0-99，数字越大，表示优先级越高 rt_time_slice: 调度策略为 “RR” 的实时进程的时间片，默认为100，随着CPU运行而减少，在rt_time_slice为0时，将时间片赋初值并将该进程加入执行队列。 如何实时进程存储队列 目前是使用 Vec 来保存，因为具体实现的逻辑原因，目前的入队列和出队列都是对队尾的操作，因此会有如下现象：系统中有多个优先级相同的实时进程等待运行时，会出现饥饿现象，也即上一个因为时间片耗尽的进程会在下一个执行，造成同优先级等待的进程饥饿。 TODO 将存储实时进程的队列改为使用双向链表存储（或者其他办法解决上述的饥饿问题） 多核CPU的实时调度 目前的实时调度是针对单核CPU的，需要实现多核CPU的实时调度 RT进程带宽比 由于实时任务的优先级高于普通任务，因而为了防止cpu消耗型的实时任务一直占用cpu引发其他任务”饥饿”的情况发生，linux内核采用了带宽限制手段来抑制实时任务的运行时间 带宽限制：在任务调度中带宽限制就是指一定周期内一个队列上任务可运行的最大时间 多个CPU之间实现负载均衡 最开始linux采用跟踪每个CPU的运行队列的负载情况来进行负载计算和决策 之后linux引入PELT PELT, Per-entity load tracking ，通过跟踪每个调度实体的负载贡献来计算CPU负载，来进行调度决策 更远：组调度 要解决的问题：A和B两个用户使用同一台机器，A用户16个进程，B用户2个进程，如果按照进程的个数来分配CPU资源，显然A用户会占据大量的CPU时间，这对于B用户是不公平的。组调度就可以解决这个问题，分别将A、B用户进程划分成组，并将两组的权重设置成占比50%即可。（调度时不再以进程为单位，而是以进程组作为调度实体）","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"实时调度器","slug":"实时调度器","permalink":"https://kkkkkong.github.io/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"}]},{"title":"leetcode 148","slug":"leetcode-148","date":"2023-02-09T06:54:04.000Z","updated":"2023-02-10T01:31:29.277Z","comments":true,"path":"posts/64491.html","link":"","permalink":"https://kkkkkong.github.io/posts/64491.html","excerpt":"","text":"题目描述148. 排序链表给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： 12输入：head = [4,2,1,3]输出：[1,2,3,4] 解题思路 排序+链表：将链表存储在ArrayList中，使用库函数sort，然后在写入链表中，返回。自己没有写sort 执行用时：18 ms, 在所有 Java 提交中击败了14.19%的用户 内存消耗：52.4 MB, 在所有 Java 提交中击败了7.16%的用户 通过测试用例：30 &#x2F; 30 时间 O(NLogN) 空间O(N) 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; ListNode ans=new ListNode(); ListNode res=ans; ListNode tmp=head; List&lt;Integer&gt; list=new ArrayList(); while(head!=null)&#123; list.add(head.val); head=head.next; &#125; list.sort(Comparator.naturalOrder()); for(int i=0;i&lt;list.size();i++)&#123; ans.next=new ListNode(list.get(i)); ans=ans.next; &#125; return res.next; &#125;&#125; 递归+归并排序：首先将链表找到链表的中间节点一分为二进行排序，将排序后的两个链表合并，参考《两个有序链表的合并》，此方法由于使用了递归，所以空间复杂度为O(logN)，尚未达到常数级 执行用时：11 ms, 在所有 Java 提交中击败了55.92%的用户 内存消耗：49.8 MB, 在所有 Java 提交中击败了48.05%的用户 通过测试用例：30 &#x2F; 30 时间 O(NLogN) 空间 O(logN) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; return sortList(head,null); &#125; public ListNode sortList(ListNode head,ListNode tail)&#123; if(head==null)return null; if(head.next==tail)&#123; head.next=null; return head; &#125; ListNode low=head,fast=head; ListNode tmp=head; while(fast!=tail)&#123; low=low.next; fast=fast.next; if(fast!=tail)&#123; fast=fast.next; &#125; &#125; ListNode mid=low; ListNode left=sortList(tmp,mid); ListNode right=sortList(mid,tail); return merge(left,right); &#125; public ListNode merge(ListNode node1,ListNode node2)&#123; ListNode ans=new ListNode(); ListNode tmp=ans; while(node1!=null&amp;&amp;node2!=null)&#123; if(node1.val&lt;=node2.val)&#123; ans.next=node1; node1=node1.next; &#125; else&#123; ans.next=node2; node2=node2.next; &#125; ans=ans.next; &#125; if(node1!=null)&#123; ans.next=node1; &#125; else&#123; ans.next=node2; &#125; return tmp.next; &#125;&#125; 遍历，重度参考了官方题解 执行用时：15 ms, 在所有 Java 提交中击败了30.16%的用户 内存消耗：49.4 MB, 在所有 Java 提交中击败了64.19%的用户 通过测试用例：30 &#x2F; 30 时间 O(NLogN) 空间 O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; // 归并排序 // 首先获取链表长度 int length=0; ListNode tmp=head; while(tmp!=null)&#123; tmp=tmp.next; length++; &#125; ListNode ans=new ListNode(0,head); // 将链表分成slenth长的段，初始为1，合并 for(int slen=1;slen&lt;length;slen&lt;&lt;=1)&#123; ListNode curr=ans.next,prev=ans; while(curr!=null)&#123; // 需要排序的第一个元素 ListNode head1=curr; for(int i=1;i&lt;slen&amp;&amp;curr.next!=null;i++)&#123; curr=curr.next; &#125; // 需要排序的第二个元素 ListNode head2=curr.next; curr.next=null; curr=head2; for(int i=1;i&lt;slen&amp;&amp;curr!=null&amp;&amp;curr.next!=null;i++)&#123; curr=curr.next; &#125; // 保存后续未排序元素的头节点，并将排序的部分切分 // 这句话会导致超时 // ListNode next=new ListNode(); ListNode next=null; if(curr!=null)&#123; next=curr.next; curr.next=null; &#125; ListNode merged=merge(head1,head2); prev.next=merged; while(prev.next!=null)&#123; prev=prev.next; &#125; curr=next; &#125; &#125; return ans.next; &#125; public ListNode merge(ListNode node1,ListNode node2)&#123; ListNode ans=new ListNode(); ListNode tmp=ans; while(node1!=null&amp;&amp;node2!=null)&#123; if(node1.val&lt;=node2.val)&#123; ans.next=node1; node1=node1.next; &#125; else&#123; ans.next=node2; node2=node2.next; &#125; ans=ans.next; &#125; if(node1!=null)&#123; ans.next=node1; &#125; else&#123; ans.next=node2; &#125; return tmp.next; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1797","slug":"leetcode-1797","date":"2023-02-09T01:43:48.000Z","updated":"2023-02-10T01:31:29.279Z","comments":true,"path":"posts/2315.html","link":"","permalink":"https://kkkkkong.github.io/posts/2315.html","excerpt":"","text":"题目描述1797. 设计一个验证系统你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类： AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 示例 1： 123456789101112131415输入：[&quot;AuthenticationManager&quot;, &quot;renew&quot;, &quot;generate&quot;, &quot;countUnexpiredTokens&quot;, &quot;generate&quot;, &quot;renew&quot;, &quot;renew&quot;, &quot;countUnexpiredTokens&quot;][[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]输出：[null, null, null, 1, null, null, null, 0]解释：AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。authenticationManager.renew(&quot;aaa&quot;, 1); // 时刻 1 时，没有验证码的 tokenId 为 &quot;aaa&quot; ，没有验证码被更新。authenticationManager.generate(&quot;aaa&quot;, 2); // 时刻 2 时，生成一个 tokenId 为 &quot;aaa&quot; 的新验证码。authenticationManager.countUnexpiredTokens(6); // 时刻 6 时，只有 tokenId 为 &quot;aaa&quot; 的验证码未过期，所以返回 1 。authenticationManager.generate(&quot;bbb&quot;, 7); // 时刻 7 时，生成一个 tokenId 为 &quot;bbb&quot; 的新验证码。authenticationManager.renew(&quot;aaa&quot;, 8); // tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，且 8 &gt;= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。authenticationManager.renew(&quot;bbb&quot;, 10); // tokenId 为 &quot;bbb&quot; 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。authenticationManager.countUnexpiredTokens(15); // tokenId 为 &quot;bbb&quot; 的验证码在时刻 15 过期，tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。 解题思路 按部就班，主要就是看过期时间和当前时间的关系，没啥意思 执行用时：51 ms, 在所有 Java 提交中击败了68.23%的用户 内存消耗：42.6 MB, 在所有 Java 提交中击败了85.88%的用户 通过测试用例：90 &#x2F; 90 时间 O(N) 空间 O(N) 12345678910111213141516171819202122232425262728293031323334353637383940class AuthenticationManager &#123; public int myTimeToLive; public Map&lt;String,Integer&gt; map; public AuthenticationManager(int timeToLive) &#123; myTimeToLive=timeToLive; map=new HashMap(); &#125; public void generate(String tokenId, int currentTime) &#123; map.put(tokenId,currentTime+myTimeToLive); &#125; public void renew(String tokenId, int currentTime) &#123; int endTime=map.getOrDefault(tokenId,0); if(endTime&gt;currentTime)&#123; map.put(tokenId,currentTime+myTimeToLive); &#125; &#125; public int countUnexpiredTokens(int currentTime) &#123; int ans=0; for(int value:map.values())&#123; if(value&gt;currentTime)&#123; ans++; &#125; &#125; return ans; &#125;&#125;/** * Your AuthenticationManager object will be instantiated and called as such: * AuthenticationManager obj = new AuthenticationManager(timeToLive); * obj.generate(tokenId,currentTime); * obj.renew(tokenId,currentTime); * int param_3 = obj.countUnexpiredTokens(currentTime); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 105","slug":"leetcode-105","date":"2023-02-08T11:06:03.000Z","updated":"2023-02-08T11:38:19.970Z","comments":true,"path":"posts/65064.html","link":"","permalink":"https://kkkkkong.github.io/posts/65064.html","excerpt":"","text":"题目描述105. 从前序与中序遍历序列构造二叉树给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 12输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 解题思路 递归，根据前序和中序的特性，前序数组的第一个元素一定为根节点，那么在中序数组中找到该节点，在中序数组中，该节点左侧的都是left上的节点，对应数量在前序数组的root节点之后，以此将其分开 执行用时：9 ms, 在所有 Java 提交中击败了8.56%的用户 内存消耗：86.4 MB, 在所有 Java 提交中击败了5.00%的用户 通过测试用例：203 &#x2F; 203 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length==0)return null; TreeNode root=new TreeNode(preorder[0]); int tmp=preorder[0]; int i=0; while(inorder[i]!=tmp)&#123; i++; &#125; root.left=buildTree(Arrays.copyOfRange(preorder,1,i+1),Arrays.copyOfRange(inorder,0,i)); root.right=buildTree(Arrays.copyOfRange(preorder,i+1,preorder.length),Arrays.copyOfRange(inorder,i+1,inorder.length)); return root; &#125;&#125; 递归但不使用 Arrays.copyOfRange， 执行用时：3 ms, 在所有 Java 提交中击败了42.85%的用户 内存消耗：40.9 MB, 在所有 Java 提交中击败了97.12%的用户 通过测试用例：203 &#x2F; 203 时间 O(N) 空间 O(N) 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return myBuildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1); &#125; public TreeNode myBuildTree(int[] preorder,int preI,int preJ, int[] inorder,int inI,int inJ)&#123; if(preJ&lt;preI)return null; TreeNode root=new TreeNode(preorder[preI]); int i=inI; while(inorder[i]!=preorder[preI])&#123; i++; &#125; root.left=myBuildTree(preorder,preI+1,preI+i-inI,inorder,inI,i-1); root.right=myBuildTree(preorder,preI+1+i-inI,preJ,inorder,i+1,inJ ); return root; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1233","slug":"leetcode-1233","date":"2023-02-08T08:40:58.000Z","updated":"2023-02-08T11:38:19.972Z","comments":true,"path":"posts/27420.html","link":"","permalink":"https://kkkkkong.github.io/posts/27420.html","excerpt":"","text":"题目描述1233. 删除子文件夹你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。 例如，&quot;/leetcode&quot; 和 &quot;/leetcode/problems&quot; 都是有效的路径，而空字符串和 &quot;/&quot; 不是。 示例 1： 123输入：folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]输出：[&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]解释：&quot;/a/b/&quot; 是 &quot;/a&quot; 的子文件夹，而 &quot;/c/d/e&quot; 是 &quot;/c/d&quot; 的子文件夹。 解题思路 暴力求解 超时 时间 O(N*N) 空间 O(N) 123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; removeSubfolders(String[] folder) &#123; List&lt;String&gt; ans=new ArrayList(); for(int i=0;i&lt;folder.length;i++)&#123; boolean isChild=false; for(int j=0;j&lt;folder.length;j++)&#123; if(i!=j)&#123; if(isChildFolder(folder[i],folder[j]))&#123; isChild=true; &#125; &#125; &#125; if(!isChild)&#123; ans.add(folder[i]); &#125; &#125; return ans; &#125; // 判断a是否是b的子文件夹 public boolean isChildFolder(String a,String b)&#123; if(a.length()&lt;=b.length())return false; return a.startsWith(b)&amp;&amp;a.charAt(b.length())==&#x27;/&#x27;; &#125;&#125; 排序+规律，核心的规律为：在将字符串数组按照字典序排序之后，父子文件夹是相邻的，并且父在前，子在后。 执行用时：43 ms, 在所有 Java 提交中击败了82.84%的用户 内存消耗：51.5 MB, 在所有 Java 提交中击败了30.77%的用户 通过测试用例：32 &#x2F; 32 时间 O(NLogN)，排序算法复杂度 空间 O(N)，排序算法 1234567891011121314151617181920class Solution &#123; public List&lt;String&gt; removeSubfolders(String[] folder) &#123; List&lt;String&gt; ans=new ArrayList(); Arrays.sort(folder); String tmp=folder[0]; ans.add(tmp); for(int i=1;i&lt;folder.length;i++)&#123; if(!isChildFolder(folder[i],tmp))&#123; tmp=folder[i]; ans.add(tmp); &#125; &#125; return ans; &#125; // 判断a是否是b的子文件夹 public boolean isChildFolder(String a,String b)&#123; if(a.length()&lt;=b.length())return false; return a.startsWith(b)&amp;&amp;a.charAt(b.length())==&#x27;/&#x27;; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 287","slug":"leetcode-287","date":"2023-02-07T12:38:48.000Z","updated":"2023-02-08T11:38:19.973Z","comments":true,"path":"posts/65374.html","link":"","permalink":"https://kkkkkong.github.io/posts/65374.html","excerpt":"","text":"题目描述287. 寻找重复数给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： 12输入：nums = [1,3,4,2,2]输出：2 解题思路因题目要求不修改数组且空间复杂度为O(1)，因此有些思路不可用，如 排序+遍历 时间 O(NlogN)、空间 O(N) 哈希表 时间 O(N)、空间 O(N) 符合题目要求的思路 两层for，暴力求解 超时 时间 O(N*N) 空间 O(1) 参考题解，二进制法。核心思想：考虑数字的第 i 位，nums数组中的数字，第 i 位为1的数字个数为x；[1,n]中的数字，第 i 位为1的数字个数为y，x&gt;y是 &lt;&#x3D;&gt; 重复的数字第 i 位为1。 执行用时：48 ms, 在所有 Java 提交中击败了5.05%的用户 内存消耗：58.4 MB, 在所有 Java 提交中击败了84.90%的用户 通过测试用例：58 &#x2F; 58 时间 O(NlogN) 空间 O(1) 123456789101112131415161718192021222324252627class Solution &#123; public int findDuplicate(int[] nums) &#123; int res=0; int n=nums.length; // 记录n的最大位数 int bitMax=31; // 找到n-1的有效位数 while((n-1)&gt;&gt;bitMax==0)&#123; bitMax--; &#125; for(int bit=0;bit&lt;=bitMax;bit++)&#123; int x=0,y=0; for(int i=0;i&lt;n;i++)&#123; if((nums[i]&amp;(1&lt;&lt;bit))!=0)&#123; x++; &#125; if(i!=0&amp;&amp; (i&amp;(1&lt;&lt;bit))!=0)&#123; y++; &#125; &#125; if(x&gt;y)&#123; res|=1&lt;&lt;bit; &#125; &#125; return res; &#125;&#125; 双指针，将数组问题转换为环形链表问题 如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，其映射关系 n-&gt;f(n) 为：0-&gt;11-&gt;32-&gt;43-&gt;24-&gt;2同样的，我们从下标为 0 出发，根据f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;…… 评论区大神：（这应该是142题的解法证明，关键在于理解在找到环以后，为什么fast和从0开始向前移动，会同时到达环形开始点） low &#x3D; fast 时，快慢指针相遇，low 走过的距离是初始点（0）到环状开始的点 （x） 加上 环状开始的点（x） 到相遇点（y） 这段距离，而fast走过的距离是 初始点（0）到环状开始的点（x），点（x） 到点（y），点（y）到点（x），点（x）到点（y）。又因为fast走过的距离是low的两倍，设0到x长度为a，x到y长度为b,则有2*（a+b） &#x3D; a+ b+ (y到x的距离) + b，则y到x的距离就等于0到x的距离。所以当新的两个指针 一个从0出发，一个从相遇点y出发时，他们走到的相同的值就是环状开始的点，即x点。 执行用时：4 ms, 在所有 Java 提交中击败了93.31%的用户 内存消耗：59 MB, 在所有 Java 提交中击败了29.98%的用户 通过测试用例：58 &#x2F; 58 123456789101112131415class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow=nums[0],fast=nums[nums[0]]; while(slow!=fast)&#123; slow=nums[slow]; fast=nums[nums[fast]]; &#125; int pre1=0,pre2=fast; while(pre1!=pre2)&#123; pre1=nums[pre1]; pre2=nums[pre2]; &#125; return pre1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 102","slug":"leetcode-102","date":"2023-02-07T11:48:50.000Z","updated":"2023-02-08T11:38:19.968Z","comments":true,"path":"posts/15465.html","link":"","permalink":"https://kkkkkong.github.io/posts/15465.html","excerpt":"","text":"题目描述102. 二叉树的层序遍历给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 解题思路 使用list按顺序存储节点，由于返回值 List&lt;List&gt;，因此需要记录每层的节点数，获取一个节点，上层节点数减一，没添加一个节点，下层节点数加一；获取的节点值加入list，上层节点数为0时，将list加入结果队列并置空。 执行用时：1 ms, 在所有 Java 提交中击败了60.14%的用户 内存消耗：41.8 MB, 在所有 Java 提交中击败了26.37%的用户 通过测试用例：34 &#x2F; 34 时间 O(N) 空间 O(N) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null)return new ArrayList(); // 使用list存储子节点，从list头部访问一个节点时，将其子节点将入队尾 List&lt;List&lt;Integer&gt;&gt; res=new ArrayList(); List&lt;TreeNode&gt; tmp=new ArrayList(); // 使用num存储当前层和下一层的节点数 int numUp=1; int numLow=0; tmp.add(root); List&lt;Integer&gt; value=new ArrayList(); while(!tmp.isEmpty())&#123; TreeNode node=tmp.get(0); tmp.remove(0); value.add(node.val); numUp--; if(node.left!=null)&#123; tmp.add(node.left); numLow++; &#125; if(node.right!=null)&#123; tmp.add(node.right); numLow++; &#125; if(numUp==0)&#123; res.add(value); value=new ArrayList(); numUp=numLow; numLow=0; &#125; &#125; return res; &#125;&#125; 根据官方题解，使用ArrayDeque试了一下，效果差不多 执行用时：1 ms, 在所有 Java 提交中击败了60.14%的用户 内存消耗：41.4 MB, 在所有 Java 提交中击败了83.45%的用户 通过测试用例：34 &#x2F; 34 时间 O(N) 空间 O(N) 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null)return new ArrayList(); // 使用list存储子节点，从list头部访问一个节点时，将其子节点将入队尾 List&lt;List&lt;Integer&gt;&gt; res=new ArrayList(); Queue&lt;TreeNode&gt; queue=new ArrayDeque(); // 使用num存储当前层和下一层的节点数 if(root!=null)&#123; queue.add(root); &#125; while(!queue.isEmpty())&#123; List&lt;Integer&gt; value=new ArrayList(); int n=queue.size(); for(int i=0;i&lt;n;i++)&#123; TreeNode node =queue.poll(); value.add(node.val); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; &#125; res.add(value); &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 49","slug":"leetcode-49","date":"2023-02-07T10:33:57.000Z","updated":"2023-02-08T11:38:19.974Z","comments":true,"path":"posts/16289.html","link":"","permalink":"https://kkkkkong.github.io/posts/16289.html","excerpt":"","text":"题目描述49. 字母异位词分组给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 示例 1: 12输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 解题思路 哈希表+排序，首先将字符串按字母顺序排列，然后使用哈希表存储，添加原字符串到返回结果中 执行用时：6 ms, 在所有 Java 提交中击败了80.00%的用户 内存消耗：44.7 MB, 在所有 Java 提交中击败了37.70%的用户 通过测试用例：118 &#x2F; 118 时间 O(NlogN) 空间 O(N) 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res=new ArrayList(); Map&lt;String,List&lt;String&gt;&gt; map=new HashMap(); for(int i=0;i&lt;strs.length;i++)&#123; // 将字符串按字母顺序排列 char[] strToChar=strs[i].toCharArray(); Arrays.sort(strToChar); String tmp=new String(strToChar); // 使用哈希表存储，添加原字符串到返回结果中 List&lt;String&gt; value=map.getOrDefault(tmp,new ArrayList()); value.add(strs[i]); map.put(tmp,value); &#125; for(List&lt;String&gt; value:map.values())&#123; res.add(value); &#125; return res; &#125;&#125; 评论区：在美版leetcode上看到大神的思路，用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。（这个用质数表示真的很骚啊！！!）","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1604","slug":"leetcode-1604","date":"2023-02-07T02:27:38.000Z","updated":"2023-02-07T02:37:00.592Z","comments":true,"path":"posts/38940.html","link":"","permalink":"https://kkkkkong.github.io/posts/38940.html","excerpt":"","text":"题目描述1604. 警告一小时内使用相同员工卡大于等于三次的人力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。 给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。 使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 &quot;23:51&quot; 和 &quot;09:49&quot; 。 请你返回去重后的收到系统警告的员工名字，将它们按 字典序****升序 排序后返回。 请注意 &quot;10:00&quot; - &quot;11:00&quot; 视为一个小时时间范围内，而 &quot;23:51&quot; - &quot;00:10&quot; 不被视为一小时内，因为系统记录的是某一天内的使用情况。 示例 1： 123输入：keyName = [&quot;daniel&quot;,&quot;daniel&quot;,&quot;daniel&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;], keyTime = [&quot;10:00&quot;,&quot;10:40&quot;,&quot;11:00&quot;,&quot;09:00&quot;,&quot;11:00&quot;,&quot;13:00&quot;,&quot;15:00&quot;]输出：[&quot;daniel&quot;]解释：&quot;daniel&quot; 在一小时内使用了 3 次员工卡（&quot;10:00&quot;，&quot;10:40&quot;，&quot;11:00&quot;）。 解题思路 这个题题目示例给人的误导性很强，以为是时间是天然有序的，结果不然 哈希表+排序。按部就班，首先使用哈希表存储keyname和对应的set，然后遍历哈希表，找出一个小时内打卡次数&gt;&#x3D;3的人名，最后将人名按照字典序排序输出（这里的打卡时间是随机的，并非升序，因此需要排序后使用） 执行用时：65 ms, 在所有 Java 提交中击败了72.50%的用户 内存消耗：61.1 MB, 在所有 Java 提交中击败了67.50%的用户 通过测试用例：77 &#x2F; 77 时间 O(NlogN) 根据主要是排序时间 空间 O(N)，哈希表占用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public List&lt;String&gt; alertNames(String[] keyName, String[] keyTime) &#123; Map&lt;String,List&lt;String&gt;&gt; map=new HashMap(); List&lt;String&gt; res=new ArrayList(); int n=keyName.length; // 将数组使用哈希表存储 for(int i=0;i&lt;n;i++)&#123; List&lt;String&gt; tmp=map.getOrDefault(keyName[i],new ArrayList()); tmp.add(keyTime[i]); map.put(keyName[i],tmp); &#125; // 遍历哈希表，找出一个小时内打卡次数&gt;=3的人名 for(Map.Entry&lt;String,List&lt;String&gt;&gt; keyEntry:map.entrySet())&#123; String key=keyEntry.getKey(); List&lt;String&gt; value=keyEntry.getValue(); // value 需要经过排序 Collections.sort(value); if(isMore3(value))&#123; res.add(key); &#125; &#125; // 对结果进行字典序排序 Collections.sort(res); return res; &#125; public boolean isMore3(List&lt;String&gt; list)&#123; if(list.size()&lt;3)return false; for(int k=0;k&lt;list.size()-2;k++)&#123; String l=list.get(k); String r=list.get(k+2); String []lArray=l.split(&quot;:&quot;); String []rArray=r.split(&quot;:&quot;); int i=Integer.parseInt(lArray[0]); int j=Integer.parseInt(rArray[0]); if(i==j)&#123; return true; &#125; else if(j-i==1)&#123; int ir=Integer.parseInt(lArray[1]); int jr=Integer.parseInt(rArray[1]); if(jr&lt;=ir)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 在进行时间的比较时，可以将时间换算为分钟，这样可以减小比较逻辑，对于跨天问题天然有优势","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 739","slug":"leetcode-739","date":"2023-02-06T11:16:44.000Z","updated":"2023-02-06T12:28:11.225Z","comments":true,"path":"posts/2760.html","link":"","permalink":"https://kkkkkong.github.io/posts/2760.html","excerpt":"","text":"题目描述739. 每日温度给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 示例 1: 12输入: temperatures = [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0] 解题思路 暴力求解，两层for，超时 时间 O(N*N) 空间 O(1) 12345678910111213141516class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; // 两层for，向后遍历 int n=temperatures.length; int []res=new int [n]; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(temperatures[j]&gt;temperatures[i])&#123; res[i]=j-i; break; &#125; &#125; &#125; return res; &#125;&#125; 找规律，根据题意，从后向前推会比较方便，分为几种情况，用t[i]表示第i天的气温 t[i]&lt;t[i+1] res[i]为1 t[i]&gt;&#x3D;t[i+1] if t[i+1]&#x3D;&#x3D;0，那么t[i]&#x3D;0 否则比较t[i]与t[i+res[i+1]]的大小 将+1抽象为+j，那么有循环寻找下一个大值 执行用时：8 ms, 在所有 Java 提交中击败了99.06%的用户 内存消耗：51.4 MB, 在所有 Java 提交中击败了96.45%的用户 通过测试用例：48 &#x2F; 48 时间 O(N) 空间 O(1) 1234567891011121314151617181920class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; int n=temperatures.length; int []res=new int [n]; if(n==1)return res; for(int i=n-2;i&gt;=0;i--)&#123; for(int j=1;j&lt;=n-1-i;j+=res[i+j])&#123; if(temperatures[i]&lt;temperatures[i+j])&#123; res[i]=j; break; &#125; else if(res[i+j]==0)&#123; res[i]=0; break; &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2331","slug":"leetcode-2331","date":"2023-02-06T01:07:26.000Z","updated":"2023-02-06T01:15:12.683Z","comments":true,"path":"posts/11980.html","link":"","permalink":"https://kkkkkong.github.io/posts/11980.html","excerpt":"","text":"题目描述2331. 计算布尔二叉树的值给你一棵 完整二叉树 的根，这棵树有以下特征： 叶子节点 要么值为 0 要么值为 1 ，其中 0 表示 False ，1 表示 True 。 非叶子节点 要么值为 2 要么值为 3 ，其中 2 表示逻辑或 OR ，3 表示逻辑与 AND 。 计算 一个节点的值方式如下： 如果节点是个叶子节点，那么节点的 值 为它本身，即 True 或者 False 。 否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算 。 返回根节点 root 的布尔运算值。 完整二叉树 是每个节点有 0 个或者 2 个孩子的二叉树。 叶子节点 是没有孩子的节点。 示例 1： 123456输入：root = [2,1,3,null,null,0,1]输出：true解释：上图展示了计算过程。AND 与运算节点的值为 False AND True = False 。OR 运算节点的值为 True OR False = True 。根节点的值为 True ，所以我们返回 true 。 解题思路 递归，简单题我重拳出击 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.4 MB, 在所有 Java 提交中击败了70.42%的用户 通过测试用例：75 &#x2F; 75 时间 O(N) 空间 O(N)，到不了N，取决于二叉树层数 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean evaluateTree(TreeNode root) &#123; if(root.val&lt;=1)return root.val==1; return root.val==2?evaluateTree(root.left)||evaluateTree(root.right):evaluateTree(root.left)&amp;&amp;evaluateTree(root.right); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 538","slug":"leetcode-538","date":"2023-02-05T14:07:34.000Z","updated":"2023-02-05T14:15:06.871Z","comments":true,"path":"posts/2728.html","link":"","permalink":"https://kkkkkong.github.io/posts/2728.html","excerpt":"","text":"题目描述538. 把二叉搜索树转换为累加树给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 示例 1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 解题思路 这个题代码写起来简单，但是想了半天才想明白这个反向的中序遍历该怎么用，以及num的累计值的使用方式 中序遍历，递归，不难发现，题目要求结果的二叉树，如果按照中序遍历，返回的结果中，节点的val是严格递减的，因此采用中序遍历的方法，依次将val累加到节点中 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.8 MB, 在所有 Java 提交中击败了28.56%的用户 通过测试用例：215 &#x2F; 215 时间 O(N)，二叉树节点数 空间 O(N)，二叉搜索树的深度 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int num=0; public TreeNode convertBST(TreeNode root) &#123; if(root==null)return null; root.right=convertBST(root.right); root.val+= num; num=root.val; root.left=convertBST(root.left); return root; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 114","slug":"leetcode-114","date":"2023-02-05T13:19:25.000Z","updated":"2023-02-05T14:15:06.868Z","comments":true,"path":"posts/44776.html","link":"","permalink":"https://kkkkkong.github.io/posts/44776.html","excerpt":"","text":"题目描述114. 二叉树展开为链表给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1： 12输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6] 解题思路 递归 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：40.6 MB, 在所有 Java 提交中击败了99.52%的用户 通过测试用例：225 &#x2F; 225 时间 O(N) 空间 O(N) 树的深度 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; root=getDeep(root); &#125; public TreeNode getDeep(TreeNode root)&#123; if(root==null)return null; TreeNode res=root,tmp=root.right; // 将树的左子树展开后赋给右子树 root.right=getDeep(root.left); // 左子树置空 root.left=null; // 将右子树遍历到叶子节点 while(root.right!=null)&#123; root=root.right; &#125; // 将原来的右子树展开 root.right=getDeep(tmp); return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 238","slug":"leetcode-238","date":"2023-02-05T07:44:53.000Z","updated":"2023-02-05T14:15:06.870Z","comments":true,"path":"posts/51993.html","link":"","permalink":"https://kkkkkong.github.io/posts/51993.html","excerpt":"","text":"题目描述238. 除自身以外数组的乘积给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(*n*) 时间复杂度内完成此题。 示例 1: 12输入: nums = [1,2,3,4]输出: [24,12,8,6] 解题思路 使用除法，但空间不额外申请空间。使用变量保存当前的前缀积与后缀积，向后遍历，前缀积使用乘法扩大，后缀积使用除法缩小。如果遇到当前元素为0，需要重新计算后缀积。 时间 O(N*N)，为0的时候特殊情况，会导致时间复杂度到平方级 空间 O(1) 超时 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int n=nums.length; int []res=new int [n]; // 获取整个数组的乘积 int left_mut=1,right_mut=1; // 第一个元素特殊处理 for(int i=1;i&lt;n;i++)&#123; right_mut*=nums[i]; &#125; res[0]=left_mut*right_mut; for(int i=1;i&lt;n;i++)&#123; left_mut*=nums[i-1]; // 非0时，后缀积除元素 if(nums[i]!=0)&#123; right_mut/=nums[i]; &#125; // 0时，需要重新计算后缀积 else&#123; right_mut=1; for(int k=i=1;k&lt;n;k++)&#123; right_mut*=nums[k]; &#125; &#125; res[i]=left_mut*right_mut; &#125; return res; &#125;&#125; 辅助数组，使用两个数组分别保存前缀乘积和后缀乘积，然后某个数字的左右相乘。这里辅助数组的意义是left_mut[i]表示包含i的前缀积，如果表示不包含i的前缀积，那么代码量会更少。 执行用时：2 ms, 在所有 Java 提交中击败了28.31%的用户 内存消耗：49.4 MB, 在所有 Java 提交中击败了70.80%的用户 通过测试用例：22 &#x2F; 22 时间 O(N) 空间 O(N) 使用了辅助数组 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int n=nums.length; // 使用两个数组分别保存前缀和后缀的乘积 int []left_mut=new int[n]; int []right_mut=new int[n]; int []res=new int [n]; for(int i=0;i&lt;n;i++)&#123; // 前缀积 if(i==0)left_mut[i]=nums[i]; else&#123; left_mut[i]=left_mut[i-1]*nums[i]; &#125; // 后缀积 int j=n-1-i; if(j==n-1)right_mut[j]=nums[j]; else&#123; right_mut[j]=right_mut[j+1]*nums[j]; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(i==0)res[i]=right_mut[i+1]; else if(i==n-1)res[i]=left_mut[i-1]; else&#123; res[i]=left_mut[i-1]*right_mut[i+1]; &#125; &#125; return res; &#125;&#125; 使用返回数组代替后缀积，暂用返回数组暂时存储后缀积 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：49.2 MB, 在所有 Java 提交中击败了89.30%的用户 通过测试用例：22 &#x2F; 22 时间 O(N) 空间 O(1)，因为返回数组不算空间 123456789101112131415161718192021class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int n=nums.length; // 是返回数组，也是后缀积数组 int []res=new int[n]; for(int i=n-1;i&gt;=0;i--)&#123; if(i==n-1)res[i]=1; else&#123; // 后缀积不计算当前元素 res[i]=res[i+1]*nums[i+1]; &#125; &#125; int left_mut=1; // 计算res for(int i=0;i&lt;n;i++)&#123; res[i]=left_mut*res[i]; left_mut*=nums[i]; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 48","slug":"leetcode-48","date":"2023-02-05T03:15:13.000Z","updated":"2023-02-05T03:27:14.510Z","comments":true,"path":"posts/65376.html","link":"","permalink":"https://kkkkkong.github.io/posts/65376.html","excerpt":"","text":"题目描述48. 旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]] 解题思路 使用辅助矩阵：空间O(N) 原地旋转：找交换位置的规律，矩阵位置是对称的，因此每次交换的位置是有规律的，以最外圈的n个元素为例，前n-1个元素都会交换到对应的位置。将n-1个元素交换完，最外层也就结束了，接下来进入下一层交换元素。 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：40 MB, 在所有 Java 提交中击败了93.91%的用户 通过测试用例：21 &#x2F; 21 时间 O(N*N) 空间 O(1) 1234567891011121314151617181920212223242526272829303132class Solution &#123; public void rotate(int[][] matrix) &#123; int len=matrix[0].length; if(len==1)return; // n表示不重复的圈数 int n=len/2-1; // i 表示层数-1 int i=0; while(i&lt;=n)&#123; // 矩阵中每次交换的元素的横纵坐标 int rui=0+i,ruj=len-1-i,rli=len-1-i,rlj=len-1-i,lli=len-1-i,llj=0+i,lui=0+i,luj=0+i; // j 为单边的第几个元素 int j=i; // 小于当前圈的边长 len/(lu+1) while(j&lt;len-1-i)&#123; // 交换元素 int tmp=matrix[lui][luj]; matrix[lui][luj]=matrix[lli][llj]; matrix[lli][llj]=matrix[rli][rlj]; matrix[rli][rlj]=matrix[rui][ruj]; matrix[rui][ruj]=tmp; // 向后移动，移动j luj+=1; rui+=1; rlj-=1; lli-=1; j++; &#125; i++; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1798","slug":"leetcode-1798","date":"2023-02-04T15:02:30.000Z","updated":"2023-02-04T15:08:49.071Z","comments":true,"path":"posts/3403.html","link":"","permalink":"https://kkkkkong.github.io/posts/3403.html","excerpt":"","text":"题目描述1798. 你能构造出连续值的最大数目给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。 请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。 你可能有多个相同值的硬币。 示例 1： 123456输入：coins = [1,3]输出：2解释：你可以得到以下这些值：- 0：什么都不取 []- 1：取 [1]从 0 开始，你可以构造出 2 个连续整数。 解题思路 贪心，排序后，假设当前的表述范围为[0,n]，数组尾部每多一个数字v，其表示的范围为[0,n]&amp;[0+v,n+v]，那么需要考虑n与v的大小关系，如果v&lt;&#x3D;n+1，则两个范围可以连续上，否则返回结果（看了评论的想法） 执行用时：17 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：48.7 MB, 在所有 Java 提交中击败了92.31%的用户 通过测试用例：72 &#x2F; 72 时间 O(n*logn)，主要在排序的时间开销 空间 O(logn)，排序需要的栈空间 12345678910111213141516class Solution &#123; public int getMaximumConsecutive(int[] coins) &#123; Arrays.sort(coins); int res=0; for(int i:coins)&#123; // +1的目的是刚好i作为reshb的值 if(i&lt;=res+1)&#123; res=res+i; &#125; else&#123; return res+1; &#125; &#125; return res+1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2325","slug":"leetcode-2325","date":"2023-02-01T01:50:55.000Z","updated":"2023-02-01T11:37:22.042Z","comments":true,"path":"posts/32204.html","link":"","permalink":"https://kkkkkong.github.io/posts/32204.html","excerpt":"","text":"题目描述2325. 解密消息给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下： 使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。 将替换表与普通英文字母表对齐，形成对照表。 按照对照表 替换 message 中的每个字母。 空格 &#39; &#39; 保持不变。 例如，key = &quot;***hap***p***y*** ***bo***y&quot;（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（&#39;h&#39; -&gt; &#39;a&#39;、&#39;a&#39; -&gt; &#39;b&#39;、&#39;p&#39; -&gt; &#39;c&#39;、&#39;y&#39; -&gt; &#39;d&#39;、&#39;b&#39; -&gt; &#39;e&#39;、&#39;o&#39; -&gt; &#39;f&#39;）。 返回解密后的消息。 示例 1： 1234输入：key = &quot;the quick brown fox jumps over the lazy dog&quot;, message = &quot;vkbs bs t suepuv&quot;输出：&quot;this is a secret&quot;解释：对照表如上图所示。提取 &quot;the quick brown fox jumps over the lazy dog&quot; 中每个字母的首次出现可以得到替换表。 解题思路 哈希表 执行用时：6 ms, 在所有 Java 提交中击败了50.73%的用户 内存消耗：41.3 MB, 在所有 Java 提交中击败了62.04%的用户 通过测试用例：69 &#x2F; 69 时间 O(n) 空间 O(n) 1234567891011121314151617181920212223242526272829class Solution &#123; public String decodeMessage(String key, String message) &#123; // 使用HashMap存储密码的对应值 Map&lt;Character,Character&gt; map=new HashMap(); int num=0; for(int i=0;i&lt;key.length();i++)&#123; char c=key.charAt(i); if(c==&#x27; &#x27;)&#123; continue; &#125; else if(!map.containsKey(c))&#123; map.put(c,(char)(&#x27;a&#x27;+num)); num++; &#125; &#125; // 遍历message翻译 char[] res=new char[message.length()]; for(int i=0;i&lt;message.length();i++)&#123; char c=message.charAt(i); if(c==&#x27; &#x27;)&#123; res[i]=&#x27; &#x27;; &#125; else&#123; res[i]=map.get(c); &#125; &#125; return new String(res); &#125;&#125; 使用数组代替哈希表，对于以字母作为索引的操作，能用定长数组就不要用哈希，因为映射本身需要资源，而且无论分配空间还是寻址，堆区都不如栈区 执行用时：3 ms, 在所有 Java 提交中击败了77.37%的用户 内存消耗：40.2 MB, 在所有 Java 提交中击败了95.62%的用户 通过测试用例：69 &#x2F; 69 时间 O(n) 空间 O(n) 1234567891011121314151617181920212223242526272829class Solution &#123; public String decodeMessage(String key, String message) &#123; // 使用数组存储字典值 char[] map=new char[26]; int num=0; // 遍历key，存储密码值 for(int i=0;i&lt;key.length();i++)&#123; char c=key.charAt(i); if(c==&#x27; &#x27;)continue; if(!Character.isLowerCase(map[c-&#x27;a&#x27;]))&#123; map[c-&#x27;a&#x27;]=(char)(&#x27;a&#x27;+num); num++; &#125; &#125; // 翻译 char[] res=new char[message.length()]; for(int i=0;i&lt;message.length();i++)&#123; char c=message.charAt(i); if(c==&#x27; &#x27;)&#123; res[i]=&#x27; &#x27;; &#125; else&#123; res[i]=map[c-&#x27;a&#x27;]; &#125; &#125; return new String(res); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode  1669","slug":"leetcode-1669","date":"2023-01-30T14:02:15.000Z","updated":"2023-01-30T14:05:32.301Z","comments":true,"path":"posts/52549.html","link":"","permalink":"https://kkkkkong.github.io/posts/52549.html","excerpt":"","text":"题目描述1669. 合并两个链表给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。 请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。 下图中蓝色边和节点展示了操作后的结果： 请你返回结果链表的头指针。 示例 1： 123输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]输出：[0,1,2,1000000,1000001,1000002,5]解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。 解题思路 模拟，按流程办事 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：45.1 MB, 在所有 Java 提交中击败了15.14%的用户 通过测试用例：61 &#x2F; 61 时间 O(n) 空间 O(1) 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) &#123; ListNode res=list1; // 找到a节点 for(int i=0;i&lt;a-1;i++)&#123; list1=list1.next; &#125; // 将a以后的暂存在tmp ListNode tmp=list1.next; // 将list2的拼接上 list1.next=list2; // 访问到list2的末尾 while(list1!=null&amp;&amp;list1.next!=null)&#123; list1=list1.next; &#125; // 移除a到b的中间元素 for(int i=0;i&lt;b-a;i++)&#123; tmp=tmp.next; &#125; list1.next=tmp.next; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2315","slug":"leetcode-2315","date":"2023-01-29T06:34:08.000Z","updated":"2023-01-29T06:49:26.318Z","comments":true,"path":"posts/36300.html","link":"","permalink":"https://kkkkkong.github.io/posts/36300.html","excerpt":"","text":"题目描述2315. 统计星号给你一个字符串 s ，每 两个 连续竖线 &#39;|&#39; 为 一对 。换言之，第一个和第二个 &#39;|&#39; 为一对，第三个和第四个 &#39;|&#39; 为一对，以此类推。 请你返回 不在 竖线对之间，s 中 &#39;*&#39; 的数目。 注意，每个竖线 &#39;|&#39; 都会 恰好 属于一个对。 示例 1： 123456输入：s = &quot;l|*e*et|c**o|*de|&quot;输出：2解释：不在竖线对之间的字符加粗加斜体后，得到字符串：&quot;l|*e*et|c**o|*de|&quot; 。第一和第二条竖线 &#x27;|&#x27; 之间的字符不计入答案。同时，第三条和第四条竖线 &#x27;|&#x27; 之间的字符也不计入答案。不在竖线对之间总共有 2 个星号，所以我们返回 2 。 解题思路 遍历模拟：使用一个bool位作为是否为竖线中间的标记，如果不在竖线中间并且为*时，进行统计，如果遇到|，则将标记位取反 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：39.7 MB, 在所有 Java 提交中击败了53.58%的用户 通过测试用例：69 &#x2F; 69 时间 O(n) 空间O(1) 1234567891011121314151617class Solution &#123; public int countAsterisks(String s) &#123; int res=0; int n=s.length(); boolean isEven=true; for(int i=0;i&lt;n;i++)&#123; char c=s.charAt(i); if(c==&#x27;*&#x27;&amp;&amp;isEven)&#123; res++; &#125; else if(c==&#x27;|&#x27;)&#123; isEven=!isEven; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1664","slug":"leetcode-1664","date":"2023-01-28T03:42:28.000Z","updated":"2023-01-28T03:50:13.685Z","comments":true,"path":"posts/14367.html","link":"","permalink":"https://kkkkkong.github.io/posts/14367.html","excerpt":"","text":"题目描述1664. 生成平衡数组的方案数给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。 比方说，如果 nums = [6,1,7,4,1] ，那么： 选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。 选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。 选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。 如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。 请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。 示例 1： 12345678输入：nums = [2,1,6,4]输出：1解释：删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。只有一种让剩余数组成为平衡数组的方案。 解题思路 奇偶前缀和：四个变量模拟计算结果，从后往前依次移除元素，因为题目设定每次只移除一个元素，因此在从后向前移动的过程中，right元素的奇偶性是变换的 执行用时：5 ms, 在所有 Java 提交中击败了85.71%的用户 内存消耗：51.9 MB, 在所有 Java 提交中击败了21.80%的用户 通过测试用例：105 &#x2F; 105 时间 O(n) 空间 O(1) 竟然和官方题解是一样的 12345678910111213141516171819202122232425262728293031class Solution &#123; public int waysToMakeFair(int[] nums) &#123; // 分别新建变量表示奇数和与偶数和，并将其分为左右两部分表示 int odd_sum_left=0,odd_sum_right=0,even_sum_left=0,even_sum_right=0; int n=nums.length; int res=0; for(int i=0;i&lt;n;i++)&#123; if((i&amp;1)!=0) odd_sum_left+=nums[i]; else even_sum_left+=nums[i]; &#125; for(int i=n-1;i&gt;=0;i--)&#123; if((i&amp;1)!=0)&#123; odd_sum_left-=nums[i]; &#125; else&#123; even_sum_left-=nums[i]; &#125; // 将两个right交换相加到left中 if(odd_sum_left+even_sum_right==even_sum_left+odd_sum_right)&#123; res++; &#125; if((i&amp;1)!=0)&#123; odd_sum_right+=nums[i]; &#125; else&#123; even_sum_right+=nums[i]; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2309","slug":"leetcode-2309","date":"2023-01-27T03:15:47.000Z","updated":"2023-01-27T03:18:48.837Z","comments":true,"path":"posts/6349.html","link":"","permalink":"https://kkkkkong.github.io/posts/6349.html","excerpt":"","text":"题目描述2309. 兼具大小写的最好英文字母给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。 最好 英文字母的大写和小写形式必须 都 在 s 中出现。 英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。 示例 1： 1234输入：s = &quot;lEeTcOdE&quot;输出：&quot;E&quot;解释：字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。 解题思路 通过数组存储状态，遍历访问数组，获取状态，并存取最大值 执行用时：6 ms, 在所有 Java 提交中击败了36.94%的用户 内存消耗：40.1 MB, 在所有 Java 提交中击败了75.37%的用户 通过测试用例：113 &#x2F; 113 时间 O(n) 空间 O(1) 1234567891011121314151617181920212223class Solution &#123; public String greatestLetter(String s) &#123; int max=-1; // 数组值为1，表示有小写字母；数组值为2，表示有大写字母 int []tmp=new int[26]; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(Character.isUpperCase(c))&#123; if(tmp[c-&#x27;A&#x27;]==1)&#123; max=Math.max(max,c-&#x27;A&#x27;); &#125; tmp[c-&#x27;A&#x27;]=2; &#125; else if(Character.isLowerCase(c))&#123; if(tmp[c-&#x27;a&#x27;]==2)&#123; max=Math.max(max,c-&#x27;a&#x27;); &#125; tmp[c-&#x27;a&#x27;]=1; &#125; &#125; return max==-1?&quot;&quot;:String.valueOf((char)(&#x27;A&#x27;+max)); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1663","slug":"leetcode-1663","date":"2023-01-26T13:15:59.000Z","updated":"2023-01-27T03:18:48.835Z","comments":true,"path":"posts/64094.html","link":"","permalink":"https://kkkkkong.github.io/posts/64094.html","excerpt":"","text":"题目描述1663. 具有给定数值的最小字符串小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。 字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 &quot;abe&quot; 的数值等于 1 + 2 + 5 = 8 。 给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。 注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况： x 是 y 的一个前缀； 如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。 示例 1： 123输入：n = 3, k = 27输出：&quot;aay&quot;解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。 解题思路 迭代模拟，根据题目描述，要找的字符串是严格非递减的，我们默认字符串都是a组成；从后向前模拟，根据剩余值大小进行修改 执行用时：9 ms, 在所有 Java 提交中击败了86.29%的用户 内存消耗：41.5 MB, 在所有 Java 提交中击败了74.19%的用户 通过测试用例：94 &#x2F; 94 时间 O(n) 空间 O(1) 123456789101112131415161718192021class Solution &#123; public String getSmallestString(int n, int k) &#123; char []res_char=new char[n]; // 全部赋初值 for(int i=0;i&lt;n;i++)&#123; res_char[i]=&#x27;a&#x27;; &#125; k-=n; for(int i=n-1;i&gt;=0;i--)&#123; if(k&gt;25)&#123; res_char[i]=&#x27;z&#x27;; k-=25; &#125; else if(k&lt;=25)&#123; res_char[i]+=k; break; &#125; &#125; return String.valueOf(res_char); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1828","slug":"leetcode-1828","date":"2023-01-24T02:12:47.000Z","updated":"2023-01-24T02:15:54.207Z","comments":true,"path":"posts/15996.html","link":"","permalink":"https://kkkkkong.github.io/posts/15996.html","excerpt":"","text":"题目描述1828. 统计一个圆中点的数目给你一个数组 points ，其中 points[i] = [xi, yi] ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。 同时给你一个数组 queries ，其中 queries[j] = [xj, yj, rj] ，表示一个圆心在 (xj, yj) 且半径为 rj 的圆。 对于每一个查询 queries[j] ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。 请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。 示例 1： 1234输入：points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]输出：[3,2,2]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。 解题思路 两层遍历，枚举 执行用时：35 ms, 在所有 Java 提交中击败了51.59%的用户 内存消耗：42.2 MB, 在所有 Java 提交中击败了37.70%的用户 通过测试用例：66 &#x2F; 66 时间 O(n*m) 空间 O(1) 1234567891011121314151617181920class Solution &#123; public int[] countPoints(int[][] points, int[][] queries) &#123; int []res=new int[queries.length]; for(int i=0;i&lt;queries.length;i++)&#123; int []query=queries[i]; for(int []point:points)&#123; int query_x=query[0]; int query_y=query[1]; int r=query[2]; int point_x=point[0]; int point_y=point[1]; // 判断是否在圆内，点到圆心距离是否小于等于半径 x*x+y*y&lt;=r*r if((Math.pow((query_x-point_x),2)+Math.pow((query_y-point_y),2))&lt;=(r*r))&#123; res[i]++; &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2303","slug":"leetcode-2303","date":"2023-01-23T05:39:22.000Z","updated":"2023-01-23T05:45:51.135Z","comments":true,"path":"posts/8013.html","link":"","permalink":"https://kkkkkong.github.io/posts/8013.html","excerpt":"","text":"题目描述2303. 计算应缴税款总额给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 &lt; i &lt; brackets.length 的前提下，upperi-1 &lt; upperi）。 税款计算方式如下： 不超过 upper0 的收入按税率 percent0 缴纳 接着 upper1 - upper0 的部分按税率 percent1 缴纳 然后 upper2 - upper1 的部分按税率 percent2 缴纳 以此类推 给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。 示例 1： 1234567输入：brackets = [[3,50],[7,10],[12,25]], income = 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。 解题思路 模拟，从前到后遍历数组，如果income大于upper，计算upper以前的税收；否则，income小于等于upper，计算income以前的税收，遍历终止 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了22.05%的用户 通过测试用例：227 &#x2F; 227 时间 O(n) 空间 O(1) 1234567891011121314151617class Solution &#123; public double calculateTax(int[][] brackets, int income) &#123; int pre=0; double res=0; for(int []get:brackets)&#123; if(income&gt;get[0])&#123; res+=((get[0]-pre)*get[1])/100.0; &#125; else&#123; res+=((income-pre)*get[1])/100.0; break; &#125; pre=get[0]; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1817","slug":"leetcode-1817","date":"2023-01-20T11:56:30.000Z","updated":"2023-01-20T12:06:15.365Z","comments":true,"path":"posts/51772.html","link":"","permalink":"https://kkkkkong.github.io/posts/51772.html","excerpt":"","text":"题目描述1817. 查找用户活跃分钟数给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDi, timei] 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。 多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。 指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。 请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 &lt;= j &lt;= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。 返回上面描述的答案数组 answer 。 示例 1： 123456输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5输出：[0,2,0,0,0]解释：ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 22 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 解题思路 哈希表存储：使用HashMap &lt;Integer,HashSet&lt;Integer&gt;&gt;储存信息 执行用时：16 ms, 在所有 Java 提交中击败了86.21%的用户 内存消耗：52.4 MB, 在所有 Java 提交中击败了9.20%的用户 通过测试用例：38 &#x2F; 38 时间 O(n) 空间 O(n) 1234567891011121314151617class Solution &#123; public int[] findingUsersActiveMinutes(int[][] logs, int k) &#123; int []res=new int [k]; HashMap &lt;Integer,HashSet&lt;Integer&gt;&gt; map=new HashMap(); for(int i=0;i&lt;logs.length;i++)&#123; int key=logs[i][0]; int value=logs[i][1]; HashSet set=map.getOrDefault(key,new HashSet()); set.add(value); map.put(key,set); &#125; for(HashSet set:map.values())&#123; res[set.size()-1]++; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2299","slug":"leetcode-2299","date":"2023-01-19T01:57:11.000Z","updated":"2023-01-20T12:06:15.368Z","comments":true,"path":"posts/34970.html","link":"","permalink":"https://kkkkkong.github.io/posts/34970.html","excerpt":"","text":"题目描述2299. 强密码检验器 II如果一个密码满足以下所有条件，我们称它是一个 强 密码： 它有至少 8 个字符。 至少包含 一个小写英文 字母。 至少包含 一个大写英文 字母。 至少包含 一个数字 。 至少包含 一个特殊字符 。特殊字符为：&quot;!@#$%^&amp;*()-+&quot; 中的一个。 它 不 包含 2 个连续相同的字符（比方说 &quot;aab&quot; 不符合该条件，但是 &quot;aba&quot; 符合该条件）。 给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。 示例 1： 123输入：password = &quot;IloveLe3tcode!&quot;输出：true解释：密码满足所有的要求，所以我们返回 true 。 解题思路 模拟，这里的判断方法可以用Character里的现有方法替代 执行用时：1 ms, 在所有 Java 提交中击败了69.57%的用户 内存消耗：39.5 MB, 在所有 Java 提交中击败了53.26%的用户 通过测试用例：148 &#x2F; 148 时间 O(n) 空间 O(1) 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean strongPasswordCheckerII(String password) &#123; int n=password.length(); if(n&lt;8)return false; boolean have_big=false,have_small=false,have_num=false,have_sp=false; char pre=&#x27;\\n&#x27;; String sp=&quot;!@#$%^&amp;*()-+&quot;; for(int i=0;i&lt;n;i++)&#123; char c=password.charAt(i); if(c==pre)&#123; return false; &#125; pre=c; if(sp.contains(String.valueOf(c)))&#123; have_sp=true; &#125; // 大写字母 else if(c-&#x27;A&#x27;&gt;=0&amp;&amp;c-&#x27;A&#x27;&lt;26)&#123; have_big=true; &#125; else if(c-&#x27;a&#x27;&gt;=0&amp;&amp;c-&#x27;a&#x27;&lt;26)&#123; have_small=true; &#125; else if(c-&#x27;0&#x27;&gt;=0&amp;&amp;c-&#x27;0&#x27;&lt;10)&#123; have_num=true; &#125; &#125; return have_big&amp;&amp;have_num&amp;&amp;have_small&amp;&amp;have_sp; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 461","slug":"leetcode-461","date":"2023-01-18T01:54:22.000Z","updated":"2023-01-18T01:57:02.365Z","comments":true,"path":"posts/39994.html","link":"","permalink":"https://kkkkkong.github.io/posts/39994.html","excerpt":"","text":"题目描述461. 汉明距离两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。 给你两个整数 x 和 y，计算并返回它们之间的汉明距离。 示例 1： 1234567输入：x = 1, y = 4输出：2解释：1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 解题思路 位运算 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：38.6 MB, 在所有 Java 提交中击败了31.43%的用户 通过测试用例：149 &#x2F; 149 时间 O(n) 空间 O(1) 1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int res=0; while(x!=0||y!=0)&#123; // 如果末尾不同 if((x&amp;1)!=(y&amp;1))&#123; res++; &#125; x&gt;&gt;=1; y&gt;&gt;=1; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 338","slug":"leetcode-338","date":"2023-01-18T01:16:15.000Z","updated":"2023-01-18T01:57:02.364Z","comments":true,"path":"posts/2888.html","link":"","permalink":"https://kkkkkong.github.io/posts/2888.html","excerpt":"","text":"题目描述338. 比特位计数给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。 示例 1： 123456输入：n = 2输出：[0,1,1]解释：0 --&gt; 01 --&gt; 12 --&gt; 10 解题思路 迭代，遍历每个元素，依次获取 执行用时：12 ms, 在所有 Java 提交中击败了6.33%的用户 内存消耗：45.1 MB, 在所有 Java 提交中击败了96.57%的用户 通过测试用例：15 &#x2F; 15 将除法和取余运算修改为位运算 执行用时：5 ms, 在所有 Java 提交中击败了18.58%的用户 内存消耗：45.6 MB, 在所有 Java 提交中击败了37.43%的用户 通过测试用例：15 &#x2F; 15 时间 O(n*logn) 空间 O(1) 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int[] countBits(int n) &#123; int []res=new int[n+1]; for(int i=0;i&lt;=n;i++)&#123; int num=i; while(num!=0)&#123; if(num%2!=0)&#123; res[i]++; &#125; num/=2; &#125; &#125; return res; &#125;&#125;// -------------------------------------------class Solution &#123; public int[] countBits(int n) &#123; int []res=new int[n+1]; for(int i=0;i&lt;=n;i++)&#123; int num=i; while(num!=0)&#123; if((num&amp;1)==1)&#123; res[i]++; &#125; num=num&gt;&gt;1; &#125; &#125; return res; &#125;&#125; 找规律：可以发现，把数字分为两种情况，奇数和偶数 奇数：n中1的个数为n-1的个数+1 偶数：末尾一定为0，对应的1的个数为去掉末尾0的个数 执行用时：1 ms, 在所有 Java 提交中击败了99.98%的用户 内存消耗：45.5 MB, 在所有 Java 提交中击败了52.85%的用户 通过测试用例：15 &#x2F; 15 时间 O(n) 空间 O(1) 123456789101112131415class Solution &#123; public int[] countBits(int n) &#123; int []res=new int[n+1]; for(int i=0;i&lt;=n;i++)&#123; // 如果是偶数 if((i&amp;1)==0)&#123; res[i]=res[i&gt;&gt;1]; &#125; else&#123; res[i]=res[i-1]+1; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1814","slug":"leetcode-1814","date":"2023-01-17T09:22:52.000Z","updated":"2023-01-18T01:57:02.361Z","comments":true,"path":"posts/52092.html","link":"","permalink":"https://kkkkkong.github.io/posts/52092.html","excerpt":"","text":"题目描述1814. 统计一个数组中好对子的数目给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ： 0 &lt;= i &lt; j &lt; nums.length nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。 示例 1： 12345输入：nums = [42,11,1,97]输出：2解释：两个坐标对为： - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。 - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。 解题思路 暴力解法，两层for循环 超时 时间 O(n*n) 空间 O(1) 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int countNicePairs(int[] nums) &#123; int n=nums.length; int res=0; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(isGood(nums[i],nums[j]))&#123; res++; res=res%1000000007; &#125; &#125; &#125; return res; &#125; public int getRevert(int num)&#123; int res=0; while(num!=0)&#123; res=res*10+num%10; num=num/10; &#125; return res; &#125; public boolean isGood(int i,int j)&#123; int iRevert=getRevert(i); int jRevert=getRevert(j); if(i+jRevert==j+iRevert)&#123; return true; &#125; return false; &#125;&#125; 哈希表，将等式nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])转换为：nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]) ，那么只需对nums[i] - rev(nums[i])做哈希表计数，然后进行统计，排列组合的结果输出；需要注意的是，计算排列组合结果时，乘法会超出int的范围，需要用long来转换 执行用时：34 ms, 在所有 Java 提交中击败了53.15%的用户 内存消耗：57.7 MB, 在所有 Java 提交中击败了26.13%的用户 通过测试用例：84 &#x2F; 84 时间 O(n) 空间 O(n) 1234567891011121314151617181920212223242526class Solution &#123; public int countNicePairs(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); System.out.println((long)(100000*99999/2)); int res=0; for(int i=0;i&lt;nums.length;i++)&#123; int key=nums[i]-getRevert(nums[i]); map.put(key,map.getOrDefault(key,0)+1); &#125; for(int num:map.values())&#123; long tmp=((long)num*((long)num-1)/2)%1000000007; res+=(int)tmp; res%=1000000007; &#125; return res; &#125; public int getRevert(int num)&#123; int res=0; while(num!=0)&#123; res=res*10+num%10; num=num/10; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 169","slug":"leetcode-169","date":"2023-01-16T15:04:04.000Z","updated":"2023-01-16T15:12:36.499Z","comments":true,"path":"posts/23339.html","link":"","permalink":"https://kkkkkong.github.io/posts/23339.html","excerpt":"","text":"题目描述169. 多数元素给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 12输入：nums = [3,2,3]输出：3 解题思路 使用HashMap存储，遍历 执行用时：21 ms, 在所有 Java 提交中击败了6.60%的用户 内存消耗：46.6 MB, 在所有 Java 提交中击败了16.36%的用户 通过测试用例：45 &#x2F; 45 时间 O(n) 空间 O(n) 使用了一个HashMap存储 123456789101112class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); int n=nums.length; for(int i=0;i&lt;n;i++)&#123; int key=nums[i]; if(map.getOrDefault(key,0)==n/2)return nums[i]; map.put(key,map.getOrDefault(key,0)+1); &#125; return 0; &#125;&#125; 时空 O(n) O(1)的还没看懂","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 121","slug":"leetcode-121","date":"2023-01-16T11:56:55.000Z","updated":"2023-01-16T15:12:36.497Z","comments":true,"path":"posts/23848.html","link":"","permalink":"https://kkkkkong.github.io/posts/23848.html","excerpt":"","text":"题目描述121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 解题思路 一次遍历，查找当前的最小元素与现在元素的差值，该差值与当前最大值比较，最后结果返回 执行用时：2 ms, 在所有 Java 提交中击败了54.61%的用户 内存消耗：57.9 MB, 在所有 Java 提交中击败了24.49%的用户 通过测试用例：211 &#x2F; 211 时间 O(n) 空间 O(1) 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; int res=0; int pre_min=prices[0]; for(int i=1;i&lt;prices.length;i++)&#123; res=Math.max(res,prices[i]-pre_min); pre_min=Math.min(pre_min,prices[i]); &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 104","slug":"leetcode-104","date":"2023-01-15T14:56:59.000Z","updated":"2023-01-15T15:00:53.847Z","comments":true,"path":"posts/16105.html","link":"","permalink":"https://kkkkkong.github.io/posts/16105.html","excerpt":"","text":"题目描述104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 解题思路 递归，深度优先搜索 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.1 MB, 在所有 Java 提交中击败了69.57%的用户 通过测试用例：39 &#x2F; 39 时间 O(n) 空间 O(n) 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null)return 0; int left_len=maxDepth(root.left); int right_len=maxDepth(root.right); return Math.max(left_len,right_len)+1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 101","slug":"leetcode-101","date":"2023-01-15T12:04:58.000Z","updated":"2023-01-15T15:00:53.845Z","comments":true,"path":"posts/15657.html","link":"","permalink":"https://kkkkkong.github.io/posts/15657.html","excerpt":"","text":"题目描述101. 对称二叉树给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 解题思路 递归 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：39.4 MB, 在所有 Java 提交中击败了92.19%的用户 通过测试用例：199 &#x2F; 199 时间 O(n) 空间 O(n) 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return isTrue(root.left,root.right); &#125; public boolean isTrue(TreeNode left,TreeNode right)&#123; // 两个节点都为null，显然为true if(left==null&amp;&amp;right==null)return true; // 两个节点都不为null，那么需要继续比较其子节点 else if(left!=null&amp;&amp;right!=null)&#123; if(left.val!=right.val)return false; return isTrue(left.left,right.right)&amp;&amp;isTrue(left.right,right.left); &#125; // 两个节点一个为null，另一个不为null，那么一定是false else&#123; return false; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 70","slug":"leetcode-70","date":"2023-01-15T11:22:06.000Z","updated":"2023-01-15T15:00:53.850Z","comments":true,"path":"posts/51553.html","link":"","permalink":"https://kkkkkong.github.io/posts/51553.html","excerpt":"","text":"题目描述70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 12345输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 解题思路 递归 超时 123456class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3)return n; return climbStairs(n-1)+climbStairs(n-2); &#125;&#125; 迭代，f(n)&#x3D;f(n-1)+f(n-2) 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：38.7 MB, 在所有 Java 提交中击败了5.07%的用户 通过测试用例：45 &#x2F; 45 时间 O(n) 空间 O(1) 123456789101112class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3)return n; int a=1,b=2; for(int i=3;i&lt;=n;i++)&#123; int tmp=a; a=b; b+=tmp; &#125; return b; &#125;&#125; 题解还有用到矩阵快速幂、通项公式，没看","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 21","slug":"leetcode-21","date":"2023-01-15T10:53:35.000Z","updated":"2023-01-15T15:00:53.849Z","comments":true,"path":"posts/22947.html","link":"","permalink":"https://kkkkkong.github.io/posts/22947.html","excerpt":"","text":"题目描述21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 12输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 解题思路 模拟，模拟同时访问两个链表的头，将较小的元素加入结果中 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41 MB, 在所有 Java 提交中击败了51.93%的用户 通过测试用例：208 &#x2F; 208 时间 O(n) 为两个链表长度 空间 O(1) 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode res=new ListNode(); ListNode tmp=res; while(list1!=null&amp;&amp;list2!=null)&#123; if(list1.val&gt;list2.val)&#123; res.next=list2; list2=list2.next; &#125; else&#123; res.next=list1; list1=list1.next; &#125; res=res.next; &#125; if(list1!=null)&#123; res.next=list1; &#125; else if(list2!=null)&#123; res.next=list2; &#125; return tmp.next; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2293","slug":"leetcode-2293","date":"2023-01-15T02:59:12.000Z","updated":"2023-01-15T03:10:38.206Z","comments":true,"path":"posts/36634.html","link":"","permalink":"https://kkkkkong.github.io/posts/36634.html","excerpt":"","text":"题目描述2293. 极大极小游戏给你一个下标从 0 开始的整数数组 nums ，其长度是 2 的幂。 对 nums 执行下述算法： 设 n 等于 nums 的长度，如果 n == 1 ，终止 算法过程。否则，创建 一个新的整数数组 newNums ，新数组长度为 n / 2 ，下标从 0 开始。 对于满足 0 &lt;= i &lt; n / 2 的每个 偶数 下标 i ，将 newNums[i] 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。 对于满足 0 &lt;= i &lt; n / 2 的每个 奇数 下标 i ，将 newNums[i] 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。 用 newNums 替换 nums 。 从步骤 1 开始 重复 整个过程。 执行算法后，返回 nums 中剩下的那个数字。 示例 1： 1234567输入：nums = [1,3,5,2,4,8,2,2]输出：1解释：重复执行算法会得到下述数组。第一轮：nums = [1,5,4,2]第二轮：nums = [1,4]第三轮：nums = [1]1 是最后剩下的那个数字，返回 1 。 解题思路 迭代，除了个别行，和官方题解竟然一模一样，变量名都一样 执行用时：1 ms, 在所有 Java 提交中击败了71.01%的用户 内存消耗：40.8 MB, 在所有 Java 提交中击败了92.02%的用户 通过测试用例：96 &#x2F; 96 时间 O(n) 空间 O(n) 1234567891011121314151617181920class Solution &#123; public int minMaxGame(int[] nums) &#123; // 迭代 int n=nums.length; while(n!=1)&#123; int []newNums=new int[n/2]; for(int i=0;i&lt;n/2;i++)&#123; if(i%2==0)&#123; newNums[i]=Math.min(nums[2*i],nums[2*i+1]); &#125; else&#123; newNums[i]=Math.max(nums[2*i],nums[2*i+1]); &#125; &#125; n=newNums.length; nums=newNums; &#125; return nums[0]; &#125;&#125; 原地操作：在顺序遍历的情况下，newNums[i]的结果可以直接存在nums[i]中，因为，nums[i]的值在本次循环中不会再使用了，之前在计算nums[i&#x2F;2]的时候已经被使用过了。但不只为何，内存消耗不降反增。 执行用时：1 ms, 在所有 Java 提交中击败了71.01%的用户 内存消耗：41.1 MB, 在所有 Java 提交中击败了47.06%的用户 通过测试用例：96 &#x2F; 96 时间 O(n) 空间 O(1) 12345678910111213141516171819class Solution &#123; public int minMaxGame(int[] nums) &#123; // 原地操作 int n=nums.length; while(n!=1)&#123; int m=n/2; for(int i=0;i&lt;n/2;i++)&#123; if(i%2==0)&#123; nums[i]=Math.min(nums[2*i],nums[2*i+1]); &#125; else&#123; nums[i]=Math.max(nums[2*i],nums[2*i+1]); &#125; &#125; n=m; &#125; return nums[0]; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2","slug":"leetcode-2","date":"2023-01-14T12:56:23.000Z","updated":"2023-01-14T14:23:50.703Z","comments":true,"path":"posts/25580.html","link":"","permalink":"https://kkkkkong.github.io/posts/25580.html","excerpt":"","text":"题目描述2. 两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 解题思路 模拟：由于都是逆序存储，因此可以直接相加，大于10的情况进位，直到一个链表为null，那么只计算剩余链表和进位情况。都为空则停止。此外，如果最后的进位仍为1，那么结果尾部需要新加一个节点1。 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.8 MB, 在所有 Java 提交中击败了23.99%的用户 通过测试用例：1568 &#x2F; 1568 时间 O(n) 空间 O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; // 统计链表长度，加和进位，返回结果 ListNode res=new ListNode(); ListNode tmp=res; // next 表示进位 int next=0,sum=0; while(l1!=null||l2!=null)&#123; if(l1==null)&#123; sum = l2.val+next; l2=l2.next; &#125; else if(l2==null)&#123; sum = l1.val+next; l1=l1.next; &#125; else&#123; sum=l1.val+l2.val+next; l1=l1.next; l2=l2.next; &#125; next=sum&gt;9?1:0; int num=sum&gt;9?sum-10:sum; tmp.next=new ListNode(num); tmp=tmp.next; &#125; // 进位不为0，则表示需要进位，末尾添加1 if(next!=0)&#123; tmp.next=new ListNode(1); &#125; return res.next; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2283","slug":"leetcode-2283","date":"2023-01-13T02:04:48.000Z","updated":"2023-01-13T07:46:39.743Z","comments":true,"path":"posts/7963.html","link":"","permalink":"https://kkkkkong.github.io/posts/7963.html","excerpt":"","text":"题目描述2283. 判断一个数的数字计数是否等于数位的值给你一个下标从 0 开始长度为 n 的字符串 num ，它只包含数字。 如果对于 每个 0 &lt;= i &lt; n 的下标 i ，都满足数位 i 在 num 中出现了 num[i]次，那么请你返回 true ，否则返回 false 。 示例 1： 12345678输入：num = &quot;1210&quot;输出：true解释：num[0] = &#x27;1&#x27; 。数字 0 在 num 中出现了一次。num[1] = &#x27;2&#x27; 。数字 1 在 num 中出现了两次。num[2] = &#x27;1&#x27; 。数字 2 在 num 中出现了一次。num[3] = &#x27;0&#x27; 。数字 3 在 num 中出现了零次。&quot;1210&quot; 满足题目要求条件，所以返回 true 。 解题思路 哈希表计数 433 &#x2F; 433 个通过测试用例 执行用时: 1 ms 内存消耗: 40.1 MB 1234567891011121314class Solution &#123; public boolean digitCount(String num) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); for(int i=0;i&lt;num.length();i++)&#123; int k=num.charAt(i)-&#x27;0&#x27;; map.put(k,map.getOrDefault(k,0)+1); &#125; for(int i=0;i&lt;num.length();i++)&#123; int k=num.charAt(i)-&#x27;0&#x27;; if(map.getOrDefault(i,0)!=k)return false; &#125; return true; &#125;&#125; 使用数组计数 433 &#x2F; 433 个通过测试用例 执行用时: 0 ms 内存消耗: 39.6 MB 123456789101112class Solution &#123; public boolean digitCount(String num) &#123; int[] count=new int[10]; for(int i=0;i&lt;num.length();i++)&#123; count[num.charAt(i)-&#x27;0&#x27;]++; &#125; for(int i=0;i&lt;num.length();i++)&#123; if(count[i]!=num.charAt(i)-&#x27;0&#x27;)return false; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2287","slug":"leetcode-2287","date":"2023-01-13T02:03:53.000Z","updated":"2023-01-13T07:46:39.745Z","comments":true,"path":"posts/56346.html","link":"","permalink":"https://kkkkkong.github.io/posts/56346.html","excerpt":"","text":"题目描述2287. 重排字符形成目标字符串给你两个下标从 0 开始的字符串 s 和 target 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。 从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。 示例 1： 1234567输入：s = &quot;ilovecodingonleetcode&quot;, target = &quot;code&quot;输出：2解释：对于 &quot;code&quot; 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。对于 &quot;code&quot; 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。形成的字符串分别是 &quot;ecod&quot; 和 &quot;code&quot; ，都可以重排为 &quot;code&quot; 。可以形成最多 2 个 &quot;code&quot; 的副本，所以返回 2 。 解题思路 哈希表计数，使用HashMap分别存储在两个字符串中出现的字符数量，然后做除法，求最小值 执行用时：1 ms, 在所有 Java 提交中击败了40.21%的用户 内存消耗：39.7 MB, 在所有 Java 提交中击败了33.86%的用户 通过测试用例：115 &#x2F; 115 时间 O(n+m) 两个字符串长度 空间 O(m) target的长度为m，空间占用不超过m 123456789101112131415161718192021222324252627282930class Solution &#123; public int rearrangeCharacters(String s, String target) &#123; Map &lt;Character,Integer&gt; targetMap=new HashMap(); Map &lt;Character,Integer&gt; sMap=new HashMap(); int res=Integer.MAX_VALUE; // 将target字符串出现次数存储 for(int i=0;i&lt;target.length();i++)&#123; char c=target.charAt(i); targetMap.put(c,targetMap.getOrDefault(c,0)+1); &#125; // 将s与target中重复出现的字符串统计个数 for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(targetMap.containsKey(c))&#123; sMap.put(c,sMap.getOrDefault(c,0)+1); &#125; &#125; // 遍历map查找最小倍数，此处需要遍历targetMap，因为存在着出现a，ab这种测试情况 for(Map.Entry&lt;Character,Integer&gt; entry:targetMap.entrySet())&#123; char key=entry.getKey(); int targetValue=entry.getValue(); int sValue=sMap.getOrDefault(key,0); // 优化，某个字符串为0，直接返回0 if(sValue==0)return 0; res=Math.min(res,sValue/targetValue); &#125; return res; &#125;&#125; 不使用map存储，使用数组实现，与2283题类似","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 543","slug":"leetcode-543","date":"2023-01-10T00:37:00.000Z","updated":"2023-01-10T00:44:37.654Z","comments":true,"path":"posts/65003.html","link":"","permalink":"https://kkkkkong.github.io/posts/65003.html","excerpt":"","text":"题目描述543. 二叉树的直径给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例 :给定二叉树 12345 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 解题思路 深度优先搜索，使用一个全局变量统计最大半径，递归时获取分别获取左右子树的高度，同时更新最大半径。递归返回的条件是root为null，需要理解清楚叶子结点作为长度为1的存在 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41 MB, 在所有 Java 提交中击败了70.54%的用户 通过测试用例：104 &#x2F; 104 时间 O(n) 空间 O(1) 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int res=0; public int diameterOfBinaryTree(TreeNode root) &#123; getMaxDeep(root); return res; &#125; public int getMaxDeep(TreeNode root)&#123; if(root==null)return 0; int len_l=getMaxDeep(root.left); int len_r=getMaxDeep(root.right); res=Math.max(res,len_l+len_r); return Math.max(len_l,len_r)+1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 234","slug":"leetcode-234","date":"2023-01-09T02:44:53.000Z","updated":"2023-01-09T03:33:30.334Z","comments":true,"path":"posts/52761.html","link":"","permalink":"https://kkkkkong.github.io/posts/52761.html","excerpt":"","text":"题目描述234. 回文链表给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 示例 1： 12输入：head = [1,2,2,1]输出：true 解题思路 使用栈遍历 执行用时：36 ms, 在所有 Java 提交中击败了5.73%的用户 内存消耗：58.2 MB, 在所有 Java 提交中击败了21.65%的用户 通过测试用例：88 &#x2F; 88 时间 O(2n) 空间 O(n) 使用了栈存储数据 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; // 使用stack存储val，第一次遍历入栈，二次遍历出栈对比 Stack&lt;Integer&gt; s=new Stack(); ListNode tmp=head,tmp2=head; while(tmp!=null)&#123; s.push(tmp.val); tmp=tmp.next; &#125; while(tmp2!=null)&#123; if(tmp2.val!=s.pop())&#123; return false; &#125; tmp2=tmp2.next; &#125; return true; &#125;&#125; 要想使得空间为O(1)，就需要改变输入，主要步骤为 找到前半部分链表的尾结点 翻转后半部分链表 双指针同时向后移动，比较，判断是否为回文 &#x2F;&#x2F; 恢复链表 返回结果 执行用时：8 ms, 在所有 Java 提交中击败了39.41%的用户 内存消耗：51.4 MB, 在所有 Java 提交中击败了96.77%的用户 通过测试用例：88 &#x2F; 88 时间 O(n) 空间 O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; int num=0; ListNode tmp=head; while(tmp!=null)&#123; num++; tmp=tmp.next; &#125; tmp = head; // 前半部分取较短的部分 for(int i=0;i&lt;num/2;i++)&#123; tmp=tmp.next; &#125; // 这里有个问题，翻转后的链表，对原来的链表有影响，对于例子[1,2,3,2,1]左半部分的应该为[1,2]，右半部分为[3,2,1],翻转后为[1,2,1,2,3] ListNode right=reverseList(tmp); while (right!=null)&#123; if(head.val!=right.val)&#123; return false; &#125; head=head.next; right=right.next; &#125; return true; &#125; public ListNode reverseList(ListNode head) &#123; ListNode res=new ListNode(); while(head!=null)&#123; ListNode tmp=head.next; head.next=res.next; res.next=head; head=tmp; &#125; return res.next; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 141","slug":"leetcode-141","date":"2023-01-09T01:25:27.000Z","updated":"2023-01-09T03:33:30.330Z","comments":true,"path":"posts/64811.html","link":"","permalink":"https://kkkkkong.github.io/posts/64811.html","excerpt":"","text":"题目描述141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 解题思路 快慢指针，使用两个指针遍历链表，快指针每次都向前，慢指针逢二向前。如果链表无环，那么快指针总是跑到null；如果链表有环，那么两个指针会相遇 执行用时：1 ms, 在所有 Java 提交中击败了23.59%的用户 内存消耗：43 MB, 在所有 Java 提交中击败了9.25%的用户 通过测试用例：23 &#x2F; 23 时间 O(n) 空间 O(1) 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null||head.next==null)return false; ListNode low=head,fast=head.next; int num=0; while(fast!=null)&#123; if(fast==low)return true; fast=fast.next; if(num++%2==0)&#123; low=low.next; &#125; &#125; return false; &#125;&#125; 快慢指针，但是快指针每次向前2，慢指针每次向前1 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：42.5 MB, 在所有 Java 提交中击败了63.94%的用户 通过测试用例：23 &#x2F; 23 时间 O(n) 空间 O(1) 123456789101112131415161718192021222324/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null||head.next==null)return false; ListNode low=head,fast=head.next; while(fast!=null)&#123; if(fast==low)return true; if(fast.next==null)return false; fast=fast.next.next; low=low.next; &#125; return false; &#125;&#125; （官方题解）哈希表，使用哈希表存储访问过的节点，每次判断是否访问过 123456789101112public class Solution &#123; public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;(); while (head != null) &#123; if (!seen.add(head)) &#123; return true; &#125; head = head.next; &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 94","slug":"leetcode-94","date":"2023-01-09T01:01:51.000Z","updated":"2023-01-09T03:33:30.336Z","comments":true,"path":"posts/27236.html","link":"","permalink":"https://kkkkkong.github.io/posts/27236.html","excerpt":"","text":"题目描述94. 二叉树的中序遍历给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[1,3,2] 解题思路 中序遍历，递归 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：39.7 MB, 在所有 Java 提交中击败了44.46%的用户 通过测试用例：70 &#x2F; 70 时间 O(n) 空间 O(h) h是树高 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList(); if(root==null)return res; List&lt;Integer&gt; left=inorderTraversal(root.left); List&lt;Integer&gt; right=inorderTraversal(root.right); res.addAll(left); res.add(root.val); res.addAll(right); return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 160","slug":"leetcode-160","date":"2023-01-08T10:54:04.000Z","updated":"2023-01-08T11:01:45.678Z","comments":true,"path":"posts/24043.html","link":"","permalink":"https://kkkkkong.github.io/posts/24043.html","excerpt":"","text":"题目描述160. 相交链表难度简单1931收藏分享切换为英文接收动态反馈 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 自定义评测： 评测系统 的输入如下（你设计的程序 不适用 此输入）： intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0 listA - 第一个链表 listB - 第二个链表 skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数 skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。 解题思路 迭代，先遍历获取m n，较长的向后移动abs(m-n)，然后同时向后移动，记录最后一个不相等元素的next node 执行用时：1 ms, 在所有 Java 提交中击败了97.99%的用户 内存消耗：44.2 MB, 在所有 Java 提交中击败了70.32%的用户 通过测试用例：39 &#x2F; 39 时间 O(2m+2n) 空间 O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // 先遍历获取m n，较长的向后移动abs(m-n)，然后同时向后移动 ListNode tmpA=headA,tmpB=headB; int lenA=0,lenB=0; while(tmpA!=null)&#123; lenA++; tmpA=tmpA.next; &#125; while(tmpB!=null)&#123; lenB++; tmpB=tmpB.next; &#125; tmpA=headA; tmpB=headB; if(lenA&gt;lenB)&#123; for(int i=0;i&lt;lenA-lenB;i++)&#123; tmpA=tmpA.next; &#125; &#125; else&#123; for(int i=0;i&lt;lenB-lenA;i++)&#123; tmpB=tmpB.next; &#125; &#125; ListNode res=tmpA; while(tmpA!=null)&#123; if(tmpA!=tmpB)&#123; if(tmpA.next!=null)&#123; res=tmpA.next; &#125; else&#123; return null; &#125; &#125; tmpA=tmpA.next; tmpB=tmpB.next; &#125; return res; &#125;&#125; 大神题解 123456789public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 206","slug":"leetcode-206","date":"2023-01-08T10:17:01.000Z","updated":"2023-01-08T10:27:39.891Z","comments":true,"path":"posts/65432.html","link":"","permalink":"https://kkkkkong.github.io/posts/65432.html","excerpt":"","text":"题目描述206. 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 解题思路 迭代，原地翻转，将待翻转链表头部的node摘出来；遍历链表时，将当前head.next存储起来，然后将head插入res和res.next 之间 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了9.12%的用户 通过测试用例：28 &#x2F; 28 时间 O(n) 空间 O(1) 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode res=new ListNode(); while(head!=null)&#123; ListNode tmp=head.next; head.next=res.next; res.next=head; head=tmp; &#125; return res.next; &#125;&#125; 递归","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 226","slug":"leetcode-226","date":"2023-01-08T09:01:50.000Z","updated":"2023-01-08T10:27:45.439Z","comments":true,"path":"posts/40857.html","link":"","permalink":"https://kkkkkong.github.io/posts/40857.html","excerpt":"","text":"题目描述226. 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 解题思路 深度优先(递归) 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：39.4 MB, 在所有 Java 提交中击败了8.65%的用户 通过测试用例：77 &#x2F; 77 时间 O(n) 空间 O(h)，h是树的高度 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null)return null; TreeNode tmp=root.right; root.right=invertTree(root.left); root.left=invertTree(tmp); return root; &#125;&#125; 广度优先（迭代），懒得写","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2185","slug":"leetcode-2185","date":"2023-01-08T08:49:27.000Z","updated":"2023-01-08T10:27:51.244Z","comments":true,"path":"posts/7531.html","link":"","permalink":"https://kkkkkong.github.io/posts/7531.html","excerpt":"","text":"题目描述2185. 统计包含给定前缀的字符串给你一个字符串数组 words 和一个字符串 pref 。 返回 words 中以 pref 作为 前缀 的字符串的数目。 字符串 s 的 前缀 就是 s 的任一前导连续字符串。 解题思路 直接模拟，从前到后判断 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了20.10%的用户 通过测试用例：95 &#x2F; 95 时间 O(n) 空间 O(1) 1234567891011121314151617181920class Solution &#123; public int prefixCount(String[] words, String pref) &#123; int res=0; for(int i=0;i&lt;words.length;i++)&#123; if(isTrue(words[i],pref))&#123; res++; &#125; &#125; return res; &#125; public boolean isTrue(String words, String pref)&#123; if(words.length()&lt;pref.length())return false; for(int i=0;i&lt;pref.length();i++)&#123; if(pref.charAt(i)!=words.charAt(i))&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1658","slug":"leetcode-1658","date":"2023-01-07T11:14:27.000Z","updated":"2023-01-08T10:27:56.773Z","comments":true,"path":"posts/52511.html","link":"","permalink":"https://kkkkkong.github.io/posts/52511.html","excerpt":"","text":"题目描述1658. 将 x 减到 0 的最小操作数给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。 解题思路 滑动窗口：前后指针分别表示前缀和和后缀和，后缀和从整个数组开始，前缀和从-1开始， 如果lsum+rsum&#x3D;x，说明找到了一组答案 如果lsum+rsum&gt;x，说明过大，把right向右移动 如果lsum+rsum&lt;x，说明过小，把left向左移动 执行用时：11 ms, 在所有 Java 提交中击败了27.04%的用户 内存消耗：50.3 MB, 在所有 Java 提交中击败了85.29%的用户 通过测试用例：94 &#x2F; 94 时间：O(n) 空间：O(1) 123456789101112131415161718192021222324class Solution &#123; public int minOperations(int[] nums, int x) &#123; int n=nums.length; int res=n+1; int right=0; int lsum=0,rsum=Arrays.stream(nums).sum(); if(rsum&lt;x)return -1; for(int left=-1;left&lt;n;left++)&#123; if(left!=-1)&#123; lsum+=nums[left]; &#125; // 和大于n时，r向右移动 while(lsum+rsum&gt;x&amp;&amp;right&lt;n)&#123; rsum-=nums[right]; right++; &#125; if(lsum+rsum==x)&#123; res=Math.min(res,left+1+n-right); &#125; &#125; return res&gt;n?-1:res; &#125;&#125; 逆向思维，考虑找到一个最长的子数组，使得子数组的和为sum-x","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 617","slug":"leetcode-617","date":"2023-01-06T12:38:05.000Z","updated":"2023-01-06T12:56:03.236Z","comments":true,"path":"posts/28185.html","link":"","permalink":"https://kkkkkong.github.io/posts/28185.html","excerpt":"","text":"题目描述617. 合并二叉树给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 解题思路 深度优先搜索，从根节点开始，依次合并两个树的节点，将合并后的节点存在root1中，合并时有几种情况： 两个节点都为null，那么返回null 两个节点有一个为null，返回非空节点 两个节点都不为空，合并两个节点，并将左右孩子节点递归调用合并 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.4 MB, 在所有 Java 提交中击败了73.39%的用户 通过测试用例：182 &#x2F; 182 时间复杂度：O(min(m,n))，m n分别是两个二叉树的层数 空间复杂度：O(min(m,n))，m n分别是两个二叉树的层数，取决于递归层数，层数不会超过最矮的二叉树的高度；最差情况等于节点数 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if(root1!=null&amp;&amp;root2!=null)&#123; root1.val+=root2.val; root1.left=mergeTrees(root1.left,root2.left); root1.right=mergeTrees(root1.right,root2.right); return root1; &#125; else if(root1!=null||root2!=null)&#123; return root1==null?root2:root1; &#125; else&#123; return null; &#125; &#125;&#125; 官方题解更优雅 1234567891011121314class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null) &#123; return t2; &#125; if (t2 == null) &#123; return t1; &#125; TreeNode merged = new TreeNode(t1.val + t2.val); merged.left = mergeTrees(t1.left, t2.left); merged.right = mergeTrees(t1.right, t2.right); return merged; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2180","slug":"leetcode-2180","date":"2023-01-06T02:26:25.000Z","updated":"2023-01-08T10:28:11.588Z","comments":true,"path":"posts/7851.html","link":"","permalink":"https://kkkkkong.github.io/posts/7851.html","excerpt":"","text":"题目描述2180. 统计各位数字之和为偶数的整数个数给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。 正整数的 各位数字之和 是其所有位上的对应数字相加的结果。 解题思路 暴力求解，依次判断每个数字是否符合要求 执行用时：1 ms, 在所有 Java 提交中击败了83.26%的用户 内存消耗：38.4 MB, 在所有 Java 提交中击败了45.61%的用户 通过测试用例：71 &#x2F; 71 时间 O(n*logn) 空间 O(1) 123456789101112131415161718192021222324class Solution &#123; public int countEven(int num) &#123; int res=0; for(int i=2;i&lt;=num;i++)&#123; if(isTrue(i))&#123; res++; &#125; &#125; return res; &#125; public boolean isTrue(int num)&#123; int res=0; int tmp=0; while(num!=0)&#123; tmp=num%10; num=num/10; res+=tmp; &#125; if(res%2==0)&#123; return true; &#125; return false; &#125;&#125; 数学推导方法 将num分成10×y+x的表达形式，分成两个区间[0,10×y) 和[10×y+0,10×y+x] 在区间[10×y+0,10×y+x]区间内，符合条件的个数为（上下取整这里最开始理解错了，改了半天） ： 如果y是偶数，那么个数为 x&#x2F;2(向下取整)+1 如果y是奇数，那么个数为 x&#x2F;2 (向上取整) 在区间[0,10×y+0) 内，符合条件的个数为5×y 因为从0开始，每个个位数都是0-9，对应的奇偶都是5个，因此无论非个位数字的是奇是偶，总体都是5个 最后由于计算时包含了0，因此返回结果将其 -1 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：38.5 MB, 在所有 Java 提交中击败了29.29%的用户 通过测试用例：71 &#x2F; 71 时间 O(logn) 空间 O(1) 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int countEven(int num) &#123; int y=num/10,x=num%10; int res=y*5; if(isTrue(y))&#123; // 查找有多少个偶数。包含0 res+=x/2+1; &#125; else&#123; // 查找有多少个奇数 if(x%2==0)&#123; res+=x/2; &#125; else&#123; res+=x/2+1; &#125; &#125; return res-1; &#125; public boolean isTrue(int num)&#123; int res=0; int tmp=0; while(num!=0)&#123; tmp=num%10; num=num/10; res+=tmp; &#125; if(res%2==0)&#123; return true; &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 448","slug":"leetcode-448","date":"2023-01-05T03:02:02.000Z","updated":"2023-01-05T03:40:56.014Z","comments":true,"path":"posts/64251.html","link":"","permalink":"https://kkkkkong.github.io/posts/64251.html","excerpt":"","text":"题目描述448. 找到所有数组中消失的数字给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 解题思路 首先想到使用一个数组下标记录数组中出现的数字，tmp[i]&#x3D;1表示在nums中出现了i，否则表示没出现 执行用时：3 ms, 在所有 Java 提交中击败了99.62%的用户 内存消耗：49.1 MB, 在所有 Java 提交中击败了87.39%的用户 通过测试用例：33 &#x2F; 33 时间复杂度 O(n) 空间复杂度O(n)使用了一个数组来记录 123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res=new ArrayList(); int []tmp=new int[nums.length]; for(int num:nums)&#123; tmp[num-1]=1; &#125; for(int i=0;i&lt;tmp.length;i++)&#123; if(tmp[i]!=1)&#123; res.add(i+1); &#125; &#125; return res; &#125;&#125; 考虑不使用额外的空间存储，在原数组的基础上修改（莫名其妙，内存消耗不降反增） 执行用时：3 ms, 在所有 Java 提交中击败了99.62%的用户 内存消耗：49.6 MB, 在所有 Java 提交中击败了29.89%的用户 通过测试用例：33 &#x2F; 33 时间复杂度 O(n) 空间复杂度O(1) 123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; int n=nums.length; List&lt;Integer&gt; res=new ArrayList(); for(int num:nums)&#123; nums[(num-1)%n]+=n; &#125; for(int i=0;i&lt;n;i++)&#123; if(nums[i]-1&lt;n)&#123; res.add(i+1); &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 283","slug":"leetcode-283","date":"2023-01-04T02:36:12.000Z","updated":"2023-01-04T09:54:44.756Z","comments":true,"path":"posts/15455.html","link":"","permalink":"https://kkkkkong.github.io/posts/15455.html","excerpt":"","text":"题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 283. 移动零 - 力扣（LeetCode） 解题思路 暴力解法，既然要求原地操作，那么我直接两层for循环 执行用时：565 ms, 在所有 Java 提交中击败了5.03%的用户 内存消耗：43.1 MB, 在所有 Java 提交中击败了20.29%的用户 通过测试用例：74 &#x2F; 74 123456789101112131415161718class Solution &#123; public void moveZeroes(int[] nums) &#123; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=0;j&lt;nums.length-1;j++)&#123; if(nums[j]==0)&#123; swap(nums,j,j+1); &#125; &#125; &#125; &#125; public int[] swap(int [] nums,int i,int j)&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; return nums; &#125;&#125; 能不能用O(n)的实现呢，想到了双指针实现，但是一时间没有捋顺代码，卡了半天，借鉴了别人的代码实现 1234567891011121314151617181920class Solution &#123; public void moveZeroes(int[] nums) &#123; int n=nums.length; int pre=0,next=0; // 快慢指针,pre指向当前的0，next指向当前0后的第一个非零 while(next&lt;n)&#123; if(nums[next]!=0)&#123; swap(nums,pre,next); pre++; &#125; next++; &#125; &#125; public int[] swap(int [] nums,int i,int j)&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; return nums; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1802","slug":"leetcode-1802","date":"2023-01-04T02:11:30.000Z","updated":"2023-01-08T10:28:27.476Z","comments":true,"path":"posts/23037.html","link":"","permalink":"https://kkkkkong.github.io/posts/23037.html","excerpt":"","text":"题目描述给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）： nums.length &#x3D;&#x3D; nnums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; nabs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1nums 中所有元素之和不超过 maxSumnums[index] 的值被 最大化返回你所构造的数组中的 nums[index] 。 注意：abs(x) 等于 x 的前提是 x &gt;&#x3D; 0 ；否则，abs(x) 等于 -x 。 1802. 有界数组中指定下标处的最大值 - 力扣（LeetCode） 解题思路 自己想的，没有什么章法 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxValue(int n, int index, int maxSum) &#123; if(n==maxSum)return 1; int res; int nowSum=0; int num=1; // 一个较小值，通过平均值计算，比平均值小n的数字一定是小于结果值的，因此设置所有数字都是rev int rev=maxSum/n-n; if(rev&gt;0)&#123; // 当maxsum较大时，设置一个基值，相当于剪枝 nowSum+=rev*n+1; res=rev+1; &#125; // rev小于0，表示maxsum不是很大 else&#123; res=2; nowSum=n+1; &#125; while(nowSum&lt;maxSum)&#123; int left=index&gt;num?num:index; int right=(index+num)&gt;(n-1)?(n-1-index):(num); nowSum+=left+right+1; if(nowSum&gt;maxSum)&#123; return res; &#125; res++; num++; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 136","slug":"leetcode-136","date":"2023-01-03T10:58:44.000Z","updated":"2023-01-08T10:28:35.648Z","comments":true,"path":"posts/3944.html","link":"","permalink":"https://kkkkkong.github.io/posts/3944.html","excerpt":"","text":"题目描述给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 136. 只出现一次的数字 - 力扣（LeetCode） 解题思路刚好最近写项目用到了异或运算，一下子就想到了妙解，不然这个题要费一阵子劲 异或运算：各个位上，相同为0，不同为1 123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int result=0; for (int a:nums)&#123; result^=a; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2042","slug":"leetcode-2042","date":"2023-01-03T10:39:19.000Z","updated":"2023-01-08T10:28:41.036Z","comments":true,"path":"posts/8062.html","link":"","permalink":"https://kkkkkong.github.io/posts/8062.html","excerpt":"","text":"题目描述句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。 示例，”a puppy has 2 eyes 4 legs” 是一个由 7 个 token 组成的句子：”2” 和 “4” 是数字，其他像 “puppy” 这样的 tokens 属于单词。给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。 如果满足题目要求，返回 true ，否则，返回 false 。 2042. 检查句子中的数字是否递增 - 力扣（LeetCode） 解题思路 以后要仔细读题了，把简单题做复杂了 这题没有看到数字的限制，自然而然的想到有些数字会超出int的范围（如 &gt;2147483647的数字），然后就写了个比较的函数，后来看见了题目后面的条件 使用split的方式 98 &#x2F; 98 个通过测试用例 状态：通过 执行用时: 4 ms 内存消耗: 39.6 MB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public boolean areNumbersAscending(String s) &#123; String [] array=s.split(&quot; &quot;); int len=0; String tmp=&quot;0&quot;; for(String a:array)&#123; if(isNum(a))&#123; if(!isBig(a,tmp))&#123; return false; &#125; tmp=a; &#125; &#125; return true; &#125; public boolean isNum(String s)&#123; if(s.charAt(0)&gt;&#x27;0&#x27;&amp;&amp;s.charAt(0)&lt;=&#x27;9&#x27;)&#123; return true; &#125; return false; &#125; // 如果a大于b，返回true，否则返回false public boolean isBig(String a,String b)&#123; int a_len=a.length(),b_len=b.length(); System.out.println(a_len); if(a_len&gt;b_len)&#123; return true; &#125; else if(a_len&lt;b_len)&#123; return false; &#125; else&#123; for(int i=0;i&lt;a_len;i++)&#123; if(a.charAt(i)&gt;b.charAt(i))&#123; return true; &#125; else if(a.charAt(i)&lt;b.charAt(i))&#123; return false; &#125; &#125; // 相等返回false return false; &#125; &#125;&#125; 2. 执行用时：1 ms, 在所有 Java 提交中击败了89.21%的用户 内存消耗：39.6 MB, 在所有 Java 提交中击败了56.43%的用户 通过测试用例：98 &#x2F; 98 123456789101112131415161718192021222324class Solution &#123; public boolean areNumbersAscending(String s) &#123; String [] array=s.split(&quot; &quot;); int pre=0; String tmp=&quot;0&quot;; for(String a:array)&#123; if(isNum(a))&#123; int now=Integer.parseInt(a); if(now&lt;=pre)&#123; return false; &#125; pre=now; &#125; &#125; return true; &#125; public boolean isNum(String s)&#123; if(s.charAt(0)&gt;&#x27;0&#x27;&amp;&amp;s.charAt(0)&lt;=&#x27;9&#x27;)&#123; return true; &#125; return false; &#125;&#125; 自己切分字符串，更快","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 20","slug":"leetcode-20","date":"2023-01-02T12:29:57.000Z","updated":"2023-01-08T10:28:46.256Z","comments":true,"path":"posts/39266.html","link":"","permalink":"https://kkkkkong.github.io/posts/39266.html","excerpt":"","text":"题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。 20. 有效的括号 - 力扣（LeetCode） 解题思路使用栈辅助存储左括号，来进行匹配 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isValid(String s) &#123; if(s.length()%2!=0)return false; Stack&lt;Character&gt; stack=new Stack(); for(int i=0;i&lt;s.length();i++)&#123; char a=s.charAt(i); if(a==&#x27;&#123;&#x27;||a==&#x27;[&#x27;||a==&#x27;(&#x27;)&#123; stack.push(a); &#125; else&#123; if(stack.isEmpty())&#123; return false; &#125; if(a==&#x27;&#125;&#x27;)&#123; if(stack.pop()!=&#x27;&#123;&#x27;)&#123; return false; &#125; &#125; else if(a==&#x27;]&#x27;)&#123; if(stack.pop()!=&#x27;[&#x27;)&#123; return false; &#125; &#125; else if(a==&#x27;)&#x27;)&#123; if(stack.pop()!=&#x27;(&#x27;)&#123; return false; &#125; &#125; &#125; &#125; if(!stack.isEmpty())&#123; return false; &#125; return true; &#125;&#125; 写完通过后，看了别人的解法，可以说是相当简洁 123456789101112class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt;stack = new Stack&lt;Character&gt;(); for(char c: s.toCharArray())&#123; if(c==&#x27;(&#x27;)stack.push(&#x27;)&#x27;); else if(c==&#x27;[&#x27;)stack.push(&#x27;]&#x27;); else if(c==&#x27;&#123;&#x27;)stack.push(&#x27;&#125;&#x27;); else if(stack.isEmpty()||c!=stack.pop())return false; &#125; return stack.isEmpty(); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 1801","slug":"leetcode-1801","date":"2023-01-02T12:01:58.000Z","updated":"2023-01-08T10:28:51.582Z","comments":true,"path":"posts/22717.html","link":"","permalink":"https://kkkkkong.github.io/posts/22717.html","excerpt":"","text":"题目描述给你一个二维整数数组 orders ，其中每个 orders[i] &#x3D; [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。 订单类型 orderTypei 可以分为两种： 0 表示这是一批采购订单 buy1 表示这是一批销售订单 sell注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。 存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况： 如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。 1801. 积压订单中的订单总数 - 力扣（LeetCode） 解题思路 采用优先级队列解决，但由于对于这里不太熟，所以参考了解析 按照题目描述的思路，主要是捋顺了比较的逻辑，加上清楚优先级队列的使用；这题可以做出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int getNumberOfBacklogOrders(int[][] orders) &#123; PriorityQueue&lt;int[]&gt; buyOrders=new PriorityQueue&lt;&gt;((a,b)-&gt;b[0]-a[0]); PriorityQueue&lt;int[]&gt; sellOrders=new PriorityQueue&lt;&gt;((a,b)-&gt;a[0]-b[0]); for(int [] order:orders)&#123; int price=order[0],amount=order[1],orderType=order[2]; // 采购订单 if(orderType==0)&#123; while(amount&gt;0&amp;&amp;!sellOrders.isEmpty()&amp;&amp;sellOrders.peek()[0]&lt;=price)&#123; // 取出销售订单中的最低销售订单 int[] sellOrder=sellOrders.poll(); int dellAmount=amount&gt;sellOrder[1]?sellOrder[1]:amount; amount-=dellAmount; sellOrder[1]-=dellAmount; // 如果最低销售订单未耗尽 if(sellOrder[1]&gt;0)&#123; sellOrders.offer(sellOrder); &#125; &#125; // 如果耗尽了所有的低价订单，仍有部分未采购，则加入购买的积压订单 if(amount&gt;0)&#123; buyOrders.offer(new int[]&#123;price,amount&#125;); &#125; &#125; // 销售订单 else&#123; while(amount&gt;0&amp;&amp;!buyOrders.isEmpty()&amp;&amp;buyOrders.peek()[0]&gt;=price)&#123; // 取出采购订单中的最高订单 int[] buyOrder=buyOrders.poll(); int dellAmount=amount&gt;buyOrder[1]?buyOrder[1]:amount; amount-=dellAmount; buyOrder[1]-=dellAmount; if(buyOrder[1]&gt;0)&#123; buyOrders.offer(buyOrder); &#125; &#125; if(amount&gt;0)&#123; sellOrders.offer(new int[]&#123;price,amount&#125;); &#125; &#125; &#125; int res=0; for(PriorityQueue&lt;int[]&gt; pq: Arrays.asList(buyOrders,sellOrders))&#123; while(!pq.isEmpty())&#123; int[] order=pq.poll(); res=(res+order[1])%1000000007; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 2351","slug":"leetcode-2351","date":"2023-01-01T00:52:11.000Z","updated":"2023-01-08T10:28:56.481Z","comments":true,"path":"posts/36559.html","link":"","permalink":"https://kkkkkong.github.io/posts/36559.html","excerpt":"","text":"题目描述简单题不简单 给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。 注意： 如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。s 包含至少一个出现两次的字母。 2351. 第一个出现两次的字母 - 力扣（LeetCode） 解题思路 最开始想用hashmap解决，因为用的比较熟悉了 12345678910111213class Solution &#123; public char repeatedCharacter(String s) &#123; HashMap map=new HashMap(); for(int i=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; return s.charAt(i); &#125; map.put(s.charAt(i),1); &#125; return s.charAt(0); &#125;&#125; 后来发现，这东西用hashset更合适，因为只需要存key，value没有实际意义 1234567891011class Solution &#123; public char repeatedCharacter(String s) &#123; HashSet set=new HashSet(); for(int i=0;i&lt;s.length();i++)&#123; if(!set.add(s.charAt(i)))&#123; return s.charAt(i); &#125; &#125; return &#x27; &#x27;; &#125;&#125; 看了解析之后，发现可以用位运算，通过int类型的后26位，模拟26个字母，对应某位为1则 &amp;的结果不为0，因此可以找到第一个元素；否则将该元素 | 运算后将对应位置为1 12345678910111213141516class Solution &#123; public char repeatedCharacter(String s) &#123; int letter=0; for(int i=0;i&lt;s.length();i++)&#123; int l=s.charAt(i)-&#x27;a&#x27;; if((letter&amp;(1&lt;&lt;l))!=0)&#123; return s.charAt(i); &#125; else&#123; letter=letter|1&lt;&lt;l; &#125; &#125; return &#x27; &#x27;; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"leetcode 11","slug":"leetcode-11","date":"2022-12-31T11:11:30.000Z","updated":"2023-01-08T10:29:01.296Z","comments":true,"path":"posts/43427.html","link":"","permalink":"https://kkkkkong.github.io/posts/43427.html","excerpt":"","text":"题目描述给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 题目链接11. 盛最多水的容器 - 力扣（LeetCode） 解决思路 拿过来一看，最先想到的就是暴力解法，两层for循环遍历，寻找最大元素，但作为中等题，果然是超时的 123456789101112class Solution &#123; public int maxArea(int[] height) &#123; int max=0; for(int left=0;left&lt;height.length-1;left++)&#123; for(int right=left+1;right&lt;height.length;right++)&#123; int tmp =(height[right]&gt;height[left]?height[left]:height[right])*(right-left); max=max&gt;tmp?max:tmp; &#125; &#125; return max; &#125;&#125; 暴力不行，然后考虑采用其他方式，按照提示，考虑采用双指针，分别指向开头和结尾，从两边向中间缩，但怎么移动指针是关键，面积是容器底[1]*两边中较小的一方[2]，底随着移动不断缩小，因此只有增大[2]，短板效应，需要将[2]中较小的一方扩大，才能扩大，因此较小的一方移动 1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int max=0; int left=0,right=height.length-1; while(left&lt;right)&#123; int tmp=(height[right]&gt;height[left]?height[left]:height[right])*(right-left); max=max&gt;tmp?max:tmp; if(height[right]&gt;height[left])&#123; left++; &#125; else&#123; right--; &#125; &#125; return max; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"坦格利安家族人物关系","slug":"坦格利安家族人物关系","date":"2022-12-11T13:27:04.000Z","updated":"2022-12-11T13:56:34.053Z","comments":true,"path":"posts/9659.html","link":"","permalink":"https://kkkkkong.github.io/posts/9659.html","excerpt":"","text":"龙之家族人物关系 最近在追剧权游前传-《龙之家族》，看了第一季之后意犹未尽，索性找来原著小说，原著中龙家的关系比较复杂，所以画个个图方便自己屡清关系（hh，看小说还记笔记） 图为截止坦格利安王朝史·第一卷的坦格利安家族的主要人物关系 其中人物名字上方为其所御之龙的名字 红色箭头代表七大王国的王位继承顺序 放几张剧照吧 阅读链接血与火：坦格利安王朝史·第一卷（HBO 热播剧《龙之家族》影视原著小说，奇幻巨著冰与火之歌前传）》乔治·R.R.马丁","categories":[],"tags":[{"name":"小说","slug":"小说","permalink":"https://kkkkkong.github.io/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2022-11-28T11:21:24.000Z","updated":"2023-02-23T09:35:40.114Z","comments":true,"path":"posts/953.html","link":"","permalink":"https://kkkkkong.github.io/posts/953.html","excerpt":"","text":"git常用命令总结 总结我常用的git命令，不然每次想不起来了还要去找 持续更新… git add ：添加文件到缓存，常用git add . 添加所有文件夹 git status ：查看项目内文件的状态 git stash : 暂存当前的修改（不能保存为追踪文件，如新建文件） git stash pop : 将暂存文件恢复，与git stash 配合使用 git diff ：查看未缓存的更改 git commit ：提交命令， 常用git commit -m “update内容” 偷懒可以git commit -am “update内容”，这样不需要每次都add git push originname a:b ：将本地的a分支推送到originname 的b上去 git pull originname a ：将远程originname分支的a拉取到本地当前分支上 git reset –hard “commitID” ：回退到某个版本 git reset HEAD test.txt ：取消已缓存的test.txt文件 git branch ：查看本地的分支 git branch newbranch ：创建分支newbranch git checkout branchname：切换到branchname 分支 git merge branchname ：将任意分支合并到到当前分支中 git branch -d branchname)：删除某个分支 git remote add urlname urllink：添加新的远程仓库地址，一般一个项目托管到不同平台用得到 git remote：查看当前的远程仓库 git merge –abort ：取消merging状态 git checkout -b newbranch origin&#x2F;abranch ：从远程分支abranch创建本地新分支newbranch git fetch –all : 拉取远程仓库的所有数据，包括更新的分支和提交 git fetch : 只想更新特定的远程仓库 git push origin_name -d branch_name：删除远程分支 git branch -d branch_name： 删除本地分支 未完待续","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kkkkkong.github.io/tags/git/"}]},{"title":"酒香归纳","slug":"酒香归纳","date":"2022-11-27T10:23:39.000Z","updated":"2022-12-15T01:34:58.742Z","comments":true,"path":"posts/57461.html","link":"","permalink":"https://kkkkkong.github.io/posts/57461.html","excerpt":"","text":"酒香归纳 偶尔会接触一些酒，但总是听说各种香型，但都没太深的了解，这里先记录一下，以后有机会都尝一尝 香型及其特征 各香型代表酒 酱香型 茅台 清香型 汾酒 42度的汾酒喝了半斤，入口微微辣，第二天上午也迷瞪的 浓香型 五粮液、泸州老窖、剑南春 泸州老窖52度喝了塑料杯一杯半，入口比较辣，晚上感觉浑身暖和，第二天毫无感觉 凤香型 西凤酒 45度西凤酒喝了三两，过了太久，记不得啥情况了 董香型&#x2F;药香型 董酒 米香型&#x2F;蜜香型 桂林三花 芝麻香型 景芝酒 豉香型 佛山石湾玉冰烧 兼香型也叫浓酱兼香型白酒 白云边 喝了两塑料杯53度白云边，酒比较好入口，第二天早上起来微微有点头疼 老白干 衡水老白干 馥郁香 酒鬼酒 特香型","categories":[],"tags":[{"name":"非技术","slug":"非技术","permalink":"https://kkkkkong.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"}]},{"title":"自动部署hexo博客","slug":"自动部署hexo博客","date":"2022-11-26T13:30:25.000Z","updated":"2022-11-27T03:06:05.188Z","comments":true,"path":"posts/32022.html","link":"","permalink":"https://kkkkkong.github.io/posts/32022.html","excerpt":"","text":"懒人脚本每次写完博客，都要输入一串机械化的命令，很无聊，索性写个bat脚本，具体内容如下： 12@echo offhexo clean&amp;&amp;hexo g&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source&amp;&amp;pause 然后以bat的格式保存在博客目录下，点击执行即可（比如这篇博客就是这么发布的） 指令解释： @echo off ：关闭cmd指令的回显 hexo clean&amp;&amp;hexo g&amp;&amp;hexo d ：hexo的指令，分别是： hexo clean：清除缓存文件 db.json 和已生成的静态文件 public hexo g：生成网站静态文件到默认设置的 public 文件夹 hexo d：自动生成网站静态文件，并部署到设定的仓库 git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source，是git指令 pause：暂停执行的语句 其中的远程仓库分支source是github的项目分支之一，hexo里设置在hexo d后将代码部署到master分支中，我设置了source分支用来保存其他代码（当然不包括一些静态代码和node的代码），防止换了设备之后会丢失内容 方便好用，强烈推荐","categories":[],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://kkkkkong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"实时调度器","slug":"实时调度器","date":"2022-11-26T12:30:23.000Z","updated":"2022-11-27T03:16:04.046Z","comments":true,"path":"posts/46423.html","link":"","permalink":"https://kkkkkong.github.io/posts/46423.html","excerpt":"","text":"LINUX调度器关系图 所谓调度，就是按照某种调度的算法，从进程的就绪队列中选取进程分配CPU，主要是协调对CPU等的资源使用。进程调度的目标是最大限度利用CPU时间 linux里的调度器 RT调度器， rt_sched_class：实时调度器，为每个优先级维护一个队列 CFS调度器， cfs_sched_class：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念，采用红黑树实现进程实体的存放； 调度策略FIFO、RRlinux的进程分为两大类：实施进程和普通进程 二者的根本不同在于：如果系统中有一个实时进程可以运行，那么调度器总是会选择它，除非另有一个优先级更高的实时进程 实时进程分为两种策略进行调度： SCHED_FIFO：没有时间片，在被调度器选择之后，可以运行任意长时间。 SCHED_RR：有时间片，其值在进程运行时会减少。在所有的时间段都到期后，则该值重置为初始值，而进程则置于队列末尾。这确保了在有几个优先级相同的SCHED_RR进程的情况下，它们总是依次执行。 runqueue 运行队列 每个CPU都有一个运行队列，每个调度器都作用于运行队列； 分配给CPU的task，作为调度实体加入到运行队列中； rt_rq的结构 这里每一个CPU的运行队列rq内都有一个实时进程运行队列rt_rq，制定了优先级链表，链表个数为优先级个数，每个链表存放对应就绪状态的进程实体 调度程序 enqueue_task_rt(struct rq *rq, struct process_control_block *p, int flags) 将进程添加到对应rt_rq的优先级的队列中去 dequeue_task_rt(struct rq *rq, struct process_control_block *p, int flags) 从rt_rq的优先级队列中取出某一个进程 pick_next_task_rt() 从优先级队列中取出当前优先级最高的进程 sched_rt() 此函数是进程调度的核心函数 核心逻辑：选择另一个进程来替换掉当前的运行进程。具体替换进程的选择是通过pick_next_task_rt()函数来实现的 参考链接sched(7) - Linux manual page (man7.org) 【原创】（一）Linux进程调度器-基础 - LoyenWang - 博客园 (cnblogs.com) Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验 - ArnoldLu - 博客园 (cnblogs.com) RT调度学习笔记（1） - Hello-World3 - 博客园 (cnblogs.com) (15条消息) Kernel Scheduler学习之五：RT 调度器_sucjhwaxp的博客-CSDN博客","categories":[],"tags":[{"name":"实时调度器","slug":"实时调度器","permalink":"https://kkkkkong.github.io/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"},{"name":"linux","slug":"linux","permalink":"https://kkkkkong.github.io/tags/linux/"}]},{"title":"市场体制下企业定价方法","slug":"市场经济定价机制","date":"2022-11-23T11:01:59.000Z","updated":"2022-11-27T03:06:05.187Z","comments":true,"path":"posts/25422.html","link":"","permalink":"https://kkkkkong.github.io/posts/25422.html","excerpt":"","text":"在市场经济中，卖方才有定价权，因此需要考虑主要价格制定与变动的是卖方 现有的企业定价方式有三类：成本导向、需求导向和竞争导向 一、成本导向定价法 以营销产品的成本为主要依据制定价格的方法统称为成本导向定价法,这是最简单、应用相当广泛的一种定价方法。 **总成本定价法:**成本加成,目标利润 成本加成定价法（cost-plus pricing），即按产品单位成本加上一定比例的毛利定出销售价。 其计算公式为：P&#x3D;c×(1+r) P—商品的单价 c—商品的单位总成本 r—商品的加成率 目标利润定价法，是根据企业总成本和预期销售量，确定一个目标利润率，并以次作为定价的标准。 其计算公式为：单位商品价格&#x3D;总成本×（1+目标利润率）&#x2F; 预计销量 边际成本定价法：边际成本是企业每增以单位产品所必须支付的成本，采用这种方式暂不考虑固定成本，以边际成本加一定的利润作为最终价格，可以帮助企业迅速打开市场。 盈亏平衡定价：考虑到销售额变化后，成本也在发生变化，这种方法是运用损益平衡原理实行的一种保本定价法。 其公式是： 盈亏平衡点销售量&#x3D;固定成本&#x2F;单位—单位变动成本 盈亏平衡点销售额&#x3D;固定成本&#x2F;1—单位变动成本率 二、需求导向定价法 需求导向定价法是指根据市场需求状况和消费者对产品的感觉差异来确定价格的定价方法。 它包括以下三种 认知导向定价法：是根据消费者对企业提供的产品价值的主观评判来制定价格的一种定价方法。 逆向定价法：它是指依据消费者能够接受的最终销售价格，考虑中间商的成本及正常利润后，逆向推算出中间商的批发价和生产企业的出产价格。 可通过公式计算价格：出厂价格&#x3D;市场可零售价格×（1—批零差率）×（1—进销差率） 习惯定价法：是按照市场长期以来行成的习惯价格定价。 三、竞争导向定价法 竞争导向定价法是企业通过研究竞争对手的生产条件、服务状况、价格水平等因素，依据自身的竞争实力，参考成本和供求状况来确定商品价格。以市场上竞争者的类似产品的价格作为本企业产品定价的参照系的一种定价方法 这种定价方法主要有3方面特点。竞争导向定价主要包括随行就市定价法、产品差别定价法和密封投标定价法。 **随行就市定价法:**在垄断竞争和完全竞争的市场结构条件下，任何一家企业都无法凭借自己的实力而在市场上取得绝对的优势，为了避免竞争特别是价格竞争带来的损失，大多数企业都采用随行就市定价法，即将本企业某产品价格保持在市场平均价格水平上，利用这样的价格来获得平均报酬。此外，采用随行就市定价法，企业就不必去全面了解消费者对不同价差的反应，也不会引起价格波动。 **产品差别定价法:**产品差别定价法是指企业通过不同营销努力，使同种同质的产品在消费者心目中树立起不同的产品形象，进而根据自身特点，选取低于或高于竞争者的价格作为本企业产品价格。因此，产品差别定价法是一种进攻性的定价方法。 **密封投标定价法:**在国内外，许多大宗商品、原材料、成套设备和建筑工程项目的买卖和承包、以及出售小型企业等，往往采用发包人招标、承包人投标的方式来选择承包者，确定最终承包价格。一般来说，招标方只有一个，处于相对垄断地位，而投标方有多个，处于相互竞争地位。标的物的价格由参与投标的各个企业在相互独立的条件下来确定。在买方招标的所有投标者中，报价最低的投标者通常中标，它的报价就是承包价格。这样一种竞争性的定价方法就称密封投标定价法。","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"市场经济","slug":"市场经济","permalink":"https://kkkkkong.github.io/tags/%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E/"},{"name":"定价方法","slug":"定价方法","permalink":"https://kkkkkong.github.io/tags/%E5%AE%9A%E4%BB%B7%E6%96%B9%E6%B3%95/"}]},{"title":"最优化问题","slug":"最优化问题","date":"2022-11-21T01:05:25.000Z","updated":"2022-11-27T03:06:05.184Z","comments":true,"path":"posts/31098.html","link":"","permalink":"https://kkkkkong.github.io/posts/31098.html","excerpt":"","text":"最优化问题定义：在给定的约束条件下，选择最优的参数和方案，使得目标函数最大化&#x2F;最小化的问题 分类： 根据约束条件不同，分为 无约束问题 约束最优问题 等式约束最优问题 不等式约束最优问题 混合约束优化问题 根据目标函数的状态，分为 连续最优化问题：决策变量取值连续 光滑最优化问题：函数连续可微 线性规划 非线性规划 非光滑优化 离散最优化问题：决策标量取值离散 整数规划、资源配置、油路问题生产安排等","categories":[],"tags":[{"name":"最优化问题","slug":"最优化问题","permalink":"https://kkkkkong.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"}]},{"title":"Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks","slug":"Coding based Distributed Data Shuffling for Low Communication Cost in Data","date":"2022-07-24T04:00:00.000Z","updated":"2022-11-27T03:06:05.169Z","comments":true,"path":"posts/40422.html","link":"","permalink":"https://kkkkkong.github.io/posts/40422.html","excerpt":"","text":"Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌背景分布式机器学习框架在实际使用中依然存在许多挑战与问题，训练数据样本分布和训练数据样本输入顺序是影响机器学习模型收敛效果的重要因素。全局数据重排能够为分布式机器学习提供更接近于单机的机器学习的数据重排效果。然而其会带来巨大的网络开销 为了让全局数据重排能够应用到实际的分布式机器学习中，目前存在一些使用编码的方法来降低其网络资源开销。 但目前的基于编码的网络传输优化方法都假设存在一台拥有无限存储能力的机器存储了整个训练样本集中的所有样本，并且由这台机器负责所有样本数据的发送工作，而其他机器不具备发送数据的功能。 系统模型和问题制定 基于上述模型优化 方法制定Distributed Coded Shuffling（DCS算法）","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"}],"author":"kong"},{"title":"摩斯电码快速记忆","slug":"摩斯电码快速记忆","date":"2022-07-24T04:00:00.000Z","updated":"2022-11-27T03:06:05.183Z","comments":true,"path":"posts/58667.html","link":"","permalink":"https://kkkkkong.github.io/posts/58667.html","excerpt":"","text":"摩斯电码快速记忆之前无聊的时候翻知乎，看到一个有关摩斯电码的讨论，感觉其中一个回答对记忆莫斯电码十分有帮助，在这里分享下 原电码表 通过图像记忆 有那么两天我甚至感觉自己精通了，勤加练习不难","categories":[{"name":"学习","slug":"学习","permalink":"https://kkkkkong.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"摩斯电码","slug":"摩斯电码","permalink":"https://kkkkkong.github.io/tags/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81/"}]},{"title":"Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments","slug":"Partitioning Stateful Data Stream Applications in","date":"2022-07-22T04:00:00.000Z","updated":"2022-11-27T03:06:05.176Z","comments":true,"path":"posts/37834.html","link":"","permalink":"https://kkkkkong.github.io/posts/37834.html","excerpt":"","text":"Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments动态边缘云环境下的有状态数据流应用的划分摘要计算分区是一种通过选择性地将一些计算从移动设备卸载到附近的边缘云来提高应用程序性能的重要技术。在动态环境中，边缘云的网络带宽可能会频繁变化，计算的划分需要相应地更新。分区的频繁更新导致了移动端和边缘云之间的高状态迁移成本。但是，现有的工作没有考虑状态迁移开销。因此，分区决策可能会导致重大的拥塞控制，并极大地增加整体完成时间。本文在考虑状态迁移开销的基础上，提出了一套基于网络带宽变化的分区更新算法。据我们所知，这是第一个针对动态环境中的有状态数据流应用程序进行计算分区的工作。这些算法旨在通过在动态边缘云环境中选择性迁移状态来减轻拥塞控制和最小化制造跨度。大量的仿真结果表明，该算法不仅可以选择性地迁移状态，而且在生成时间方面优于其他经典的基准算法。所提出的模型和算法将丰富有状态任务的调度理论，这是以前从未有过的研究。 介绍边缘计算是使云计算技术能够从传统的互联网数据中心到网络边缘进行低延迟数据访问和实时数据处理[7]。作为边缘计算资源的抽象，边缘云通常分布在离终端用户较近的地方，如蜂窝基站和无线局域网。边缘计算的一般形式包括 Cloudlets [9]和 Foglets [10] ，甚至还有一小群有限的设备[8]。与传统的云数据中心相比，边缘云更轻量级，资源受限[11]。随着边缘云在当今网络基础设施中的部署越来越多，计算分区被认为是一种有效的技术，通过选择性地将一些计算从移动设备卸载到附近的边缘云[4][12][18]来提高移动应用程序的性能 为了达到不同的目的，在计算分区方面存在许多相关的工作，比如减少执行时间，节省终端设备的能源消耗，以及云的数据传输开销。这些工作对应用程序有不同的建模方法。典型的应用程序模型包括面向过程程序的方法调用树、面向服务应用程序的服务调用图和面向数据流应用程序的数据流图。&#x2F;n在这些类型的应用程序中，数据流应用程序越来越受到关注，例如扩增实境和目标跟踪。应用程序由一组功能模块组成，数据流通过这些模块。数据流应用程序的分区旨在为每个传入的数据帧决定哪些函数在本地执行，哪些函数在边缘云中执行[4][12]。但是，现有的工作不考虑有状态数据流应用程序的分区。如果数据流应用程序包含有状态函数模块，我们将其定义为有状态应用程序。通过状态函数模块，如果一个数据帧流经它，那么在处理该模块的设备上将留下一个“足迹”。这个“内存占用”(也由状态命名)是下一个数据帧的处理所需要的。许多应用程序(如对象跟踪)都属于有状态应用程序。 对有状态数据流应用程序进行分区非常具有挑战性，尤其是在动态边缘云环境中，在这种环境中，到边缘云的网络连接经常发生变化，甚至可能发生断开连接。由于网络连接的动态性，应用程序的划分需要相应地更新，这将导致移动设备和边缘云之间的状态迁移。因此，我们需要通过选择性迁移状态来划分计算，以减轻网络拥塞。现有的计算划分工作考虑了应用程序的无状态功能模块。当它们应用于有状态应用程序的分区时，网络中会出现较高的状态迁移开销，这可能导致拥塞控制和应用程序的长时间完成。这就是为什么我们需要为有状态应用程序的分区特别设计新的方法，旨在平衡良好的分区和低完成时间以及网络上额外的状态迁移时间。 在本文中，我们开发了一套有效的算法来解决有状态数据流应用程序的划分问题，目的是通过选择性迁移 ing 状态来减少拥塞控制和最小化使用时间。特别地，我们设计了一种新的算法，即基于得分矩阵的启发式算法(SM-H)来解决一次性问题，该算法在边缘网络环境改变时更新当前到达数据帧的划分。SM-H 采用矩阵形式记录调整各模块执行位置的效益得分，然后始终选择得分最大的模块进行调整。调整是迭代进行的，直到没有一个模块得到正分，这意味着调整任何一个模块将导致完成时间的增加。在一次性 SM-H 算法的基础上，进一步推广到解决多步骤的分区问题。 我们通过大量的仿真对提出的算法进行评估，并将它们与几种基准方法进行比较，包括顺序调整(一种幼稚的贪婪启发式方法)、列表调度(一种经典的并行和分布式计算调度方法)、遗传算法等。结果表明，所提出的算法在制作跨度方面优于基准算法。我们将本文的贡献总结如下。 •据我们所知，我们是第一个研究有状态数据流应用程序分区问题的人。这些问题模型可以推广到分布式处理器上的有状态任务调度，这是目前在任务调度领域尚未研究的问题。&#x2F;n •我们开发了一种新算法来划分有状态数据流应用程序。该算法丰富了有状态应用任务的调度理论和方法。&#x2F;n •我们通过广泛的仿真对提出的算法进行了评估，结果表明，提出的 SM-H 算法在制作跨度方面优于基准算法。 系统模型和问题制定定义决策变量表示分配给状态迁移、网络传输的网络带宽，将最小化make-span制定为目标并表示，限制模块之间的依赖性定义，从而定义对状态迁移的限制、对网络带宽的限制 最终形成有状态的数据流应用程序计算分区问题(SCPP)，","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"}],"author":"kong"},{"title":"基于博弈论的云/边缘计算资源分配与优化算法及应用","slug":"论文阅读","date":"2022-07-22T04:00:00.000Z","updated":"2022-11-27T03:06:05.189Z","comments":true,"path":"posts/23505.html","link":"","permalink":"https://kkkkkong.github.io/posts/23505.html","excerpt":"","text":"基于博弈论的云&#x2F;边缘计算资源分配与优化算法及应用 作者：胡俊艳 湖南大学 博士毕业论文 论文创新点 基于非合作博弈的多属性云计算资源竞价算法 时间约束感知的云计算资源联合采购博弈论方法 基于博弈论的边缘计算任务卸载算法 背景用户在意的是QoS，最小成本和最大收益问题，比如响应时间、可靠性、任务的完成时间、资源定价等， 云提供商的主要效益 需要考虑节约能耗、负载均衡等因素，这对减小开销、合理配置资源、提高资源利用率和服务质量有重要意义 无论是云环境还是边环境，都存在资源配置和资源优化问题、尽最大努力改善用户的服务质量和用户体验，降低系统的运行成本问题。因此本文采用了博弈论方法来研究在云&#x2F;边环境下的计算资源的分配优化配置方法 由于文章其他内容与我的研究点“算力网络的多方利益均衡”不同，所以没做记录 基于非合作博弈的多属性云计算资源竞价算法主要贡献针对云计算中多属性资源供应问题，提出一种基于非合作博弈关于云用户和提供商组成的利润最大化的价格竞价算法，提出一种新颖的关于服务质量和竞价的激励性资源购买模型。 然后结合用户的资源购买模型，将提供商的价格竞价问题转化为一个博弈模型来为每个云提供商找到合适的价格。 通过假设每个提供商提供的资源的数量函数是连续的，证明了针对已制定的博弈模型的纳什均衡解集的存在。 为了找到纳什均衡解，提出了一种均衡迭代算法，该算法被证明可以收敛到纳什均衡。 最后提出了一种近均衡价格竞价算法，对获得的纳什均衡解进行修正 多属性云资源价格竞价系统模型云资源供应的参与者将多用户和多提供商的情况并行化为一个用户和多个提供商的情况 3个CPs（提供商）构成一个资源组，2的3次方个方案（这里的方案只是确定CPi是否提供资源，具体提供多少未知） 云用户对多属性云资源的评估用户的属性偏好 其中 用户的资源属性偏好 云用户的云资源购买机制 文章题目：移动边缘计算中基于博弈论的资源分配技术研究算法 基于不完全合同的资源所有权分配算法设计 有关不同所有权分配下的最优投资，最大化运营商部门效用函数（针对运营商） 基于匹配理论的基站资源分配算法设计 添加考虑基站，将基站作为边缘节点，优化系统整体资源分配效益，用户希望选择损失最小的基站（基站分为欠载基站、满载基站、过载基站）。考虑了小基站网络中用户到基站的任务迁移以及基站共同协作处理任务量的模型 基于联合博弈的动态资源分配算法设计 针对边缘计算节点的租用（基于匹配理论）以及计算服务提供商与用户之间的节点拍卖问题（拍卖理论与强化学习理论结合） 网络模型 文章题目：基于任务特性的公有云资源交易机制算法 缓解资源需求峰值的任务调度策略和计价机制 综述 MEC中的资源分配问题主要有： 通信资源分配，根据无线系统环境，高效地分配通信资源，优化传输效率，降低用户间的干扰； 计算资源分配，根据用户的任务需求，有效地分配计算资源，最小化任务时延和能耗，提高卸载效率； 存储资源分配，根据用户的存储需求，分配对应的存储资源，避免用户存储空间不足引发的设备卡顿，提升用户 QoE。 当前对 MEC 资源分配方法的研究大致从两个方面进行：技术层面和经济层面 技术：计算卸载 经济：而经济层面不仅需要考虑如何分配资源，更需要考虑市场竞争性。用户不仅需要评估资源出价，更需要考虑向哪个服务器购买资源，以使自身效益最大化。因此，经济层面的资源分配问题计算复杂度大，综合管理更加复杂。对此，研究者一般采用&#x3D;&#x3D;动态分布式算法、拍卖、博弈&#x3D;&#x3D;等经济分析方法求解","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"}],"author":"kong"},{"title":"git merge与git pull的区别","slug":"git merge与git pull的区别","date":"2022-07-18T04:00:00.000Z","updated":"2022-11-27T03:06:05.177Z","comments":true,"path":"posts/23828.html","link":"","permalink":"https://kkkkkong.github.io/posts/23828.html","excerpt":"","text":"使用GitHubPages+jekyll搭建博客平台git merge与git pull的区别前言最近做项目的时候使用git，遇到一个情形： 在本地自己的分支开发的时候，主分支合并了其他人的工作，此时需要将主分支的代码合并过来，一直使用的是git pull origin main命令，如果有他人合并的工作与我本地工作有冲突，需要自己处理对应冲突 今天偶然看到其他的做法是git pull origin main main，然后git merge main mybranch，发现这也是种实现方式 于是乎开始查这两种做法的区别 git pull直接将origin的分支与本地当前分支合并，会将过程都隐藏起来， 遇到冲突解决 git fetch+ git mergegit fetch origin main 将远程仓库中的最新代码拉回， git merge origin&#x2F;main 把本地代码和已取得的main代码合并 遇到冲突去解决 对比网上很多文章都推荐使用fetch+merge，因为pull会直接更改你的工作，你不了解具体更改了什么 但如果使用了IDE，现在的IDE都集成了冲突处理功能，所以我觉着使用pull也问题不大","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kkkkkong.github.io/tags/git/"},{"name":"merge","slug":"merge","permalink":"https://kkkkkong.github.io/tags/merge/"},{"name":"pull","slug":"pull","permalink":"https://kkkkkong.github.io/tags/pull/"}],"author":"kong"},{"title":"JDBC学习笔记","slug":"JDBC","date":"2022-05-25T04:00:00.000Z","updated":"2022-11-27T03:06:05.175Z","comments":true,"path":"posts/60381.html","link":"","permalink":"https://kkkkkong.github.io/posts/60381.html","excerpt":"","text":"JDBC技术体系 一、概述 JDBC由java官方定义的一组标准：接口；对应各个数据库厂商实现对应的方法即驱动 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 在使用JDBC情况下访问数据库 JDBC程序编写步骤 二、获取数据库连接 方式一到五，1-4作为过程存在，了解即可 方式五 &#96;&#96;&#96;java&#x2F;** * 获取数据库连接 * @return * @throws Exception *&#x2F;public static Connection getConnection() throws Exception {&#x2F;&#x2F; 读取配置文件信息 InputStream ips &#x3D; ClassLoader.getSystemClassLoader().getResourceAsStream(“jdbc.properties”); Properties pros&#x3D;new Properties(); pros.load(ips); String user &#x3D; pros.getProperty(“user”); String password &#x3D; pros.getProperty(“password”); String url &#x3D; pros.getProperty(“url”); String driverClass &#x3D; pros.getProperty(“driverClass”);&#x2F;&#x2F; 2.加载驱动 Class.forName(driverClass);&#x2F;&#x2F; 3.连接 Connection conn &#x3D; DriverManager.getConnection(url, user, password); System.out.println(conn); return conn;}123456789- 配置文件jdbc.properties存放在src下 - ```xml user=root password=123456 url=jdbc:mysql://localhost:3306/test?serverTimezone=GMT driverClass=com.mysql.cj.jdbc.Driver 三、JDBCUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package utils;/** * * 操作数据库的工具类 * */public class JDBCUtils &#123; /** * 获取数据库连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123;// 读取配置文件信息 InputStream ips = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros=new Properties(); pros.load(ips); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;);// 2.加载驱动 Class.forName(driverClass);// 3.连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); return conn; &#125; /** * 关闭连接和statement操作 * @param conn * @param ps */ public static void closeResource(Connection conn, Statement ps)&#123; // 资源关闭 try &#123; if(ps!=null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void closeResource(Connection conn, Statement ps, ResultSet rs)&#123; // 资源关闭 try &#123; if(ps!=null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(rs!=null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;// 使用dbutils提供的close关闭数据库资源 public static void closeResource1(Connection conn, Statement ps, ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs); &#125;&#125; 四、使用preparedStatement实现CRUD4.1 使用statement的问题 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 无法操作Blob类型数据 实现批量插入时，效率较低 4.2 使用preparestatement 介绍 是statement的子接口 使用预编译sql语句 可以解决sql注入问题，实现高效的批量操作 通用增删改操作（V1.0） &#96;&#96;&#96;javapublic void update(String sql,Object …args) { Connection conn &#x3D; null; PreparedStatement ps &#x3D; null; try {&#x2F;&#x2F; 占位符的个数等于可变形参的个数 conn &#x3D; JDBCUtils.getConnection(); ps &#x3D; conn.prepareStatement(sql); for(int i&#x3D;0;i&lt;args.length;i++){ ps.setObject(i+1,args[i]); }&#x2F;&#x2F; 方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false&#x2F;&#x2F; ps.execute();&#x2F;&#x2F; 方式二： ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); }}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 - 通用查询操作（V1.0） - ```java /** * *@author Kong *@Description 针对不同表的通用查询操作，返回表中的一组记录 *@Date 22:12 2022/5/19 *@Param *@Return **/ public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz, String sql, Object ...args)&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; public &lt;T&gt;T getForInstance(Class&lt;T&gt; clazz,String sql,Object ...args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); if(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 过程图示 查询操作的流程 五、操作Blob类型的变量 具体的insert &#96;&#96;&#96;java&#x2F;****@author Kong*@Description 向数据表中插入blob信息*@Date 13:59 2022&#x2F;5&#x2F;20*@Param*@Return**&#x2F;@Testpublic void testInsert() throws Exception { Connection conn &#x3D; JDBCUtils.getConnection(); String sql &#x3D; “insert into customers(name,email,birth,photo) values(?,?,?,?)”; PreparedStatement ps &#x3D; conn.prepareStatement(sql); ps.setObject(1, “孙悟空”); ps.setObject(2, “&#115;&#x75;&#110;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;“); ps.setObject(3, “500-01-01”); FileInputStream is &#x3D; new FileInputStream(new File(“src&#x2F;sun.jpg”)); ps.setBlob(4, is); ps.execute(); JDBCUtils.closeResource(conn,ps);}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- 具体的查询 - ```java /** * *@author Kong *@Description 从数据表中查询blob信息 *@Date 14:00 2022/5/20 *@Param *@Return **/ @Test public void testQuery() throws Exception &#123; Connection conn = null; PreparedStatement ps = null; InputStream is=null; FileOutputStream fos=null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth,photo from customers where id =?&quot; ; ps = conn.prepareStatement(sql); ps.setObject(1, 20); ResultSet rs = ps.executeQuery(); if(rs.next())&#123; // 方式一 // int id = rs.getInt(1); // String name = rs.getString(2); // String email = rs.getString(3); // Date birth = rs.getDate(4); // 方式二：更易读，不易出错 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); Customer customer = new Customer(id, name, email, birth); System.out.println(customer); // 将文件下载到本地 Blob photo = rs.getBlob(&quot;photo&quot;); is = photo.getBinaryStream(); fos = new FileOutputStream(&quot;wukong.jpg&quot;); byte[] bytes = new byte[1024]; int len; while((len=is.read(bytes))!=-1)&#123; fos.write(bytes,0,len); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps); is.close(); fos.close(); &#125; &#125; 六、批量插入 层次一：使用statement实现 层次二：使用preparestatement实现 层次三： 修改1： 使用 addBatch() &#x2F; executeBatch() &#x2F; clearBatch() 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。?rewriteBatchedStatements&#x3D;true 写在配置文件的url后面 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar 层次四： 在层次三的基础上操作使用Connection 的 setAutoCommit(false) &#x2F; commit() 最终代码 12345678910111213141516171819202122232425262728293031323334// 方式四 :设置不允许自动提交数据 @Test public void testInsert3() &#123; Connection conn = null; PreparedStatement ps = null; try &#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection();// 设置不自动提交数据 conn.setAutoCommit(false); String sql = &quot;insert into goods(name) values(?)&quot;; ps = conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++)&#123; ps.setObject(1,&quot;name_&quot;+i);// 攒batch ps.addBatch(); if(i%500==0)&#123;// 执行batch ps.executeBatch();// 清空batch ps.clearBatch(); &#125; &#125;// 提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;时间为：&quot;+(end-start)); //13174 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps); &#125; &#125; 面试题：Preparestatement和statement的异同 接口与子接口的关系 开发中多数使用前者 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 七、事务事务简介 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）的原则：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 避免数据自动提交 执行DML语句会自动提交 设置autocommit无效 执行DDL语句也会自动提交 需要设置autocommit为false 数据库连接关闭也会自动提交 事物的ACID属性 多数的只解决了脏读问题就解决了 mysql支持四种隔离级别，Oracle只支持两种 一般情况保证 read commit就可以 代码体现 &#96;&#96;&#96;java@Testpublic void testUpdateTx() { Connection conn &#x3D; null; try { conn &#x3D; JDBCUtils.getConnection();&#x2F;&#x2F; 取消自动提交 conn.setAutoCommit(false); String sql1&#x3D;”update user_table set balance&#x3D;balance-100 where user&#x3D;?”; update(conn,sql1,”AA”);&#x2F;&#x2F; 模拟错误&#x2F;&#x2F; System.out.println(1&#x2F;0); String sql2=&quot;update user_table set balance=balance+100 where user=?&quot;; update(conn,sql2,&quot;BB&quot;); System.out.println(&quot;成功&quot;); conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; conn.rollback(); &#125; catch (SQLException ex) &#123; e.printStackTrace(); &#125; &#125; finally &#123; &#x2F;&#x2F; 恢复默认值，在设置数据库连接池时使用 try { conn.setAutoCommit(true); } catch (SQLException e) { e.printStackTrace(); } JDBCUtils.closeResource(conn,null); }} 12345678910111213141516171819202122232425- 使用事务后的增删改（V2.0） - ```java // 通用的增删改操作 v2.0（考虑到事务） public int update(Connection conn,String sql,Object ...args) &#123; PreparedStatement ps = null; try &#123; // 占位符的个数等于可变形参的个数 ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; // 方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false // ps.execute(); // 方式二： return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps); &#125; return 0; &#125; 使用事务后的查询（V2.0） 略 事物的四大属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 四种隔离级别（隔离性越好，并发性越差） 查看并设置隔离级别 八、DAOBaseDAO.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package dao2;/** * 功能描述 通用的数据库操作 * * @author Kong * @date 2022/05/23 14:17 */public abstract class BaseDAO&lt;T&gt; &#123; private Class&lt;T&gt; clazz=null; &#123;//此处为子类调用，正常声明在子类更好理解，但是为了避免新添加类就要重复写这段代码，所以放在父类中，在调用时，比如customerDAO类调用，此处的this指的是customerDAO类的对象// 获取当前BaseDAO的子类继承的父类（即为BaseDAO）的泛型 Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType paramType= (ParameterizedType) genericSuperclass; Type[] types = paramType.getActualTypeArguments();//获取父类的泛型 clazz = (Class&lt;T&gt;) types[0];//泛型的第一个参数 &#125; // 通用的增删改操作 v2.0（考虑到事务） public int update(Connection conn, String sql, Object ...args) &#123; PreparedStatement ps = null; try &#123;// 占位符的个数等于可变形参的个数 ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125;// 方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false// ps.execute();// 方式二： return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps); &#125; return 0; &#125; /** * *@author Kong *@Description 针对不同表的通用查询操作，返回表中的一条记录 *@Date 22:06 2022/5/19 *@Param *@Return **/ public T getForInstance(Connection conn,String sql,Object ...args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); if(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125; /** * *@author Kong *@Description 针对不同表的通用查询操作，返回表中的一组记录 *@Date 22:12 2022/5/19 *@Param *@Return **/ public List&lt;T&gt; getForList(Connection conn, String sql, Object ...args)&#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;// 查找特殊值的方法 public &lt;E&gt;E getValue(Connection conn,String sql,Object ...args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); if(rs.next())&#123; return (E) rs.getObject(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;&#125; CustomerDAO12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package dao2;/** * 功能描述 * * @author Kong * @date 2022/05/23 14:35 */public interface CustomerDAO &#123; /** * *@author Kong *@Description 插入指定数据 *@Date 14:35 2022/5/23 *@Param *@Return **/ void insert(Connection conn, Customer cust); /** * *@author Kong *@Description 更新用户数据 *@Date 14:36 2022/5/23 *@Param *@Return **/ void update(Connection conn,Customer cust); /** * *@author Kong *@Description 根据id删除指定用户 *@Date 14:37 2022/5/23 *@Param *@Return **/ void deleteById(Connection conn,int id); /** * *@author Kong *@Description 根据ID获得对应的customer对象 *@Date 14:38 2022/5/23 *@Param *@Return **/ Customer getCustomerById(Connection conn,int id); /** * *@author Kong *@Description 获取所有记录构成的记录 *@Date 14:40 2022/5/23 *@Param *@Return **/ List&lt;Customer&gt; getAll(Connection conn); /** * *@author Kong *@Description 返回数据表中数据的条目数量 *@Date 14:42 2022/5/23 *@Param *@Return **/ long getCount(Connection conn); /** * *@author Kong *@Description 获取数据库表中最大的生日 *@Date 14:43 2022/5/23 *@Param *@Return **/ Date getMaxBirth(Connection conn);&#125; CuscomerDAOImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package dao2;/** * 功能描述 * * @author Kong * @date 2022/05/23 14:45 */public class CustomerDAOImpl extends BaseDAO&lt;Customer&gt; implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth) values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getId()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id = ?&quot;; update(conn,sql,id); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id =?&quot;; Customer customer = getForInstance(conn, sql, id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list = getForList(conn, sql); return list; &#125; @Override public long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn, sql); &#125;&#125; 小结 九、数据库连接池必要性 几种连接池 数据库连接池技术的优点1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 几种连接池的使用十、dbutils的使用","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://kkkkkong.github.io/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://kkkkkong.github.io/tags/JDBC/"}],"author":"kong"},{"title":"5.22leetcode周赛","slug":"leetcode周赛","date":"2022-05-22T04:00:00.000Z","updated":"2023-01-08T10:29:27.425Z","comments":true,"path":"posts/42691.html","link":"","permalink":"https://kkkkkong.github.io/posts/42691.html","excerpt":"","text":"5.22leetcode周赛 第一次参加这个周赛，很菜，过了两个题，稍微复盘一下 题目一：6074. 字母在字符串中的百分比难度简单0收藏分享切换为英文接收动态反馈 给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。 示例 1： 1234输入：s = &quot;foobar&quot;, letter = &quot;o&quot;输出：33解释：等于字母 &#x27;o&#x27; 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。 示例 2： 1234输入：s = &quot;jjjj&quot;, letter = &quot;k&quot;输出：0解释：等于字母 &#x27;k&#x27; 的字符在 s 中占到的百分比是 0% ，所以返回 0 。 提示： 1 &lt;= s.length &lt;= 100 s 由小写英文字母组成 letter 是一个小写英文字母 解答 这道题是签到题，但是因为有关浮点数精度相关信息忘了，最开始使用float存储的，导致有测试用例不通过，浪费了十多分钟，还被罚时了10分钟 代码 123456789101112131415class Solution &#123; public int percentageLetter(String s, char letter) &#123; int count=0; //计算字符出现的次数 for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==letter)&#123; count++; &#125; &#125; //题目给出s的length最大100，所以使用double不会损失精度，但float不可以，测试用例(float)59/100=58 double res=(double)count/s.length(); return (int)(res*100); &#125;&#125; 题目二：6075. 装满石头的背包的最大数量现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。 请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。 示例 1： 123456789输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2输出：3解释：1 块石头放入背包 0 ，1 块石头放入背包 1 。每个背包中的石头总数是 [2,3,4,4] 。背包 0 、背包 1 和 背包 2 都装满石头。总计 3 个背包装满石头，所以返回 3 。可以证明不存在超过 3 个背包装满石头的情况。注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 示例 2： 123456789输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100输出：3解释：8 块石头放入背包 0 ，2 块石头放入背包 2 。每个背包中的石头总数是 [10,2,2] 。背包 0 、背包 1 和背包 2 都装满石头。总计 3 个背包装满石头，所以返回 3 。可以证明不存在超过 3 个背包装满石头的情况。注意，不必用完所有的额外石头。 提示： n == capacity.length == rocks.length 1 &lt;= n &lt;= 5 * 104 1 &lt;= capacity[i] &lt;= 109 0 &lt;= rocks[i] &lt;= capacity[i] 1 &lt;= additionalRocks &lt;= 109 代码 时空O(n)O(n) 123456789101112131415161718192021222324252627282930class Solution &#123; public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) &#123; int len=capacity.length; int []tmp=new int [len]; //计算每个背包的剩余空间 for(int i=0;i&lt;len;i++)&#123; tmp[i]=capacity[i]-rocks[i]; &#125; //按照剩余空间大小排序 Arrays.sort(tmp); int res=0; for(int i=0;i&lt;len;i++)&#123; //如果空间为0，则满，直接增加 if(tmp[i]==0)&#123; res++; continue; &#125; //剩余空间小于额外的石子数 if(tmp[i]&lt;=additionalRocks)&#123; additionalRocks-=tmp[i]; res++; &#125; //剩余空间大于额外石子数，不满条件，直接结束循环 else&#123; break; &#125; &#125; return res; &#125;&#125; 题目三：6076. 表示一个折线图的最少线段数给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子： 请你返回要表示一个折线图所需要的 最少线段数 。 示例 1： 123456789输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]输出：3解释：上图为输入对应的图，横坐标表示日期，纵坐标表示价格。以下 3 个线段可以表示折线图：- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。可以证明，无法用少于 3 条线段表示这个折线图。 示例 2： 1234输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]输出：1解释：如上图所示，折线图可以用一条线段表示。 提示： 1 &lt;= stockPrices.length &lt;= 105 stockPrices[i].length == 2 1 &lt;= dayi, pricei &lt;= 109 所有 dayi 互不相同 。 解答这道题是没有AC的，卡在了一个隐藏测试用例上，没想到还是因为精度问题，这次我虽然用的是double类型，但是测试用例给到了10的10次方，导致精度丢失，WA 这里判断三个点在不在同一条直线上不能使用斜率判断，需要使用直线方程的一般式判断 在这里我们只需要用到直线方程的部分性质直线方程的一般式为：ax+by+c&#x3D;0在平面直角坐标系中，我们知道任意两个点的坐标就可求出经过这两个点的直线方程可得： 1234a=y2-y1b=x1-x2//注意别写反了c=-(ax1+by1) 显然只需要代入其他点判断是否满足一般式即可 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minimumLines(int[][] stockPrices) &#123; if(stockPrices.length==1)return 0; if(stockPrices.length==2)return 1; int len=stockPrices.length; HashMap&lt;Integer,Integer&gt; hashmap=new HashMap(); int []tmpStock=new int[len]; for(int i=0;i&lt;len;i++)&#123; hashmap.put(stockPrices[i][0],stockPrices[i][1]); tmpStock[i]=stockPrices[i][0]; &#125; Arrays.sort(tmpStock);// 排序后的二维数组 int[][] stockPricesSort=stockPrices; for(int i=0;i&lt;len;i++)&#123; stockPricesSort[i][0]=tmpStock[i]; stockPricesSort[i][1]=hashmap.get(tmpStock[i]); &#125; int res=1; int a=stockPricesSort[1][1]-stockPricesSort[0][1];//y2-y1 int b=stockPricesSort[0][0]-stockPricesSort[1][0];//x1-x2 int c=-(a*stockPricesSort[0][0]+b*stockPricesSort[0][1]);//-(ax1+by1) for(int i=2;i&lt;len;i++)&#123; if(a*stockPricesSort[i][0]+b*stockPricesSort[i][1]+c!=0)&#123; res++; a=stockPricesSort[i][1]-stockPricesSort[i-1][1]; b=stockPricesSort[i-1][0]-stockPricesSort[i][0]; c=-(a*stockPricesSort[i-1][0]+b*stockPricesSort[i-1][1]); &#125; &#125;// 使用浮点数精度会丢失// double k=(double)(stockPricesSort[1][1]-stockPricesSort[0][1])/(stockPricesSort[1][0]-stockPricesSort[0][0]);// for(int i=2;i&lt;len;i++)&#123;// double tmp=(double)(stockPricesSort[i][1]-stockPricesSort[i-1][1])/(stockPricesSort[i][0]-stockPricesSort[i-1][0]);// if(tmp!=k)&#123;// res++;// k=tmp;// &#125;// &#125; return res; &#125;&#125; 第四题：尝试解答，直接超时参考链接(5条消息) 判断几个点是否在同一条直线上（计算几何）_bbbblzy的博客-CSDN博客_判断两点在一条直线上","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/tags/leetcode/"},{"name":"浮点数精度","slug":"浮点数精度","permalink":"https://kkkkkong.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"}],"author":"kong"},{"title":"使用GitHubPages+jekyll搭建博客平台","slug":"GitHubPages+jekyll","date":"2022-05-18T04:00:00.000Z","updated":"2022-11-27T03:06:05.172Z","comments":true,"path":"posts/61277.html","link":"","permalink":"https://kkkkkong.github.io/posts/61277.html","excerpt":"","text":"使用GitHubPages+jekyll搭建博客平台遇到问题 cannot load such file – webrick (LoadError) (4条消息) jekyll 安装遇到的问题（cannot load such file – webrick (LoadError)）_阿gua的博客-CSDN博客 参考文章可能是最全面的github pages搭建个人博客教程 - 云+社区 - 腾讯云 (tencent.com) (4条消息) 使用github pages+Jekyll模板搭建博客（网页小白）_Yan_wd的博客-CSDN博客_github pages模板","categories":[{"name":"学习","slug":"学习","permalink":"https://kkkkkong.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"githubpags","slug":"githubpags","permalink":"https://kkkkkong.github.io/tags/githubpags/"},{"name":"jekyll","slug":"jekyll","permalink":"https://kkkkkong.github.io/tags/jekyll/"}],"author":"kong"},{"title":"Java 二维数组排序","slug":"Java 二维数组的排序","date":"2021-11-26T13:30:25.000Z","updated":"2022-11-28T12:48:59.681Z","comments":true,"path":"posts/1218.html","link":"","permalink":"https://kkkkkong.github.io/posts/1218.html","excerpt":"","text":"Java 二维数组排序按照第一个元素升序排序，如果第一个元素相同，则按照第二个元素升序排序 12345678int [][]people=new int[4][2];Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; if (o1[0]==o2[0]) return o1[1]-o2[1]; return o1[0]-o2[0]; &#125;&#125;); 如果需要降序排序，将返回值加负号","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://kkkkkong.github.io/tags/java/"},{"name":"排序","slug":"排序","permalink":"https://kkkkkong.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"kong"},{"title":"使用typora+github实现图床","slug":"typora+github实现图床","date":"2021-10-18T04:00:00.000Z","updated":"2022-11-27T03:06:05.182Z","comments":true,"path":"posts/20962.html","link":"","permalink":"https://kkkkkong.github.io/posts/20962.html","excerpt":"","text":"使用typora+github实现图床[TOC] 需求 在使用typora的时候，有时需要放图片，但截图之类的只能保存在本地，如果换了电脑或者将正篇文档给别人，就无法打开，因此使用图床，方便使用typora 解决方式下载PicGo-Core首先保证有nodejs环境 然后安装picgo 1npm install picgo -g 安装后查看版本，检查是否安装成功 1picgo -v 安装github-plus官方给的github上传不好用，安装github-plus 1picgo install github-plus Typora设置 使用typora的PicGo-Core（不需要下载APP）+ github实现 github上创建一个仓库，填写readme，拿到对应的拥有仓库读写权限的token typora上打开偏好设置，图像栏选择如下图 修改picgo配置打开配置文件更改 &#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;githubPlus&quot;, &quot;current&quot;: &quot;githubPlus&quot;, &quot;githubPlus&quot;: &#123; &quot;branch&quot;: &quot;master&quot;, // 仓库的分支 &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest&quot;, // 访问的自定义url &quot;origin&quot;: &quot;github&quot;, // 存放的图片类型 &quot;repo&quot;: &quot;Kong-PR/Typora-picture&quot;, // 存放图片的仓库 &quot;path&quot;: &quot;img&quot;, // 仓库中存放图片的文件夹，也可以不填 &quot;token&quot;: &quot;&quot; // 访问github的仓库的token，就是一开始生成的 &#125; &#125;, &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-github-plus&quot;: true//启动github-plus插件 &#125;, &quot;picgo-plugin-github-plus&quot;: &#123; &quot;lastSync&quot;: &quot;2021-10-03 02:44:04&quot; &#125; &#125; 对应的插件一栏是在PicGo-Core的安装目录下安装的,有的没用上 picgo install smms-user picgo install gitee-uploader picgo install github-plus 上面的 customUrl，在这里我是使用了 jsdeliver cdn 进行加速访问.比正常要上传快很多 token填写github的对应token 然后就可以使用了,图片放上去就自动上传了 有一个疑问 在我github账户改名后，我仍然可以通过原用户名访问，这是什么原因呢 参考 [使用jsdelivr + GitHub + PicGo搭建免费图床 - 啸歌 - 博客园 (cnblogs.com)](https://www.cnblogs.com/SeanYoung/p/13407250.html#:~:text=由于GitHub国内访问速度慢，所以可以考虑使用CDN优化加速进行访问，这里选择免费的jsdeliver进行CDN优化。 jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。 包含,JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。) Typora + PicGo-Core + Github 实现图片上传到Github - 码农教程 (manongjc.com)","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/tags/github/"},{"name":"typora","slug":"typora","permalink":"https://kkkkkong.github.io/tags/typora/"}],"author":"kong"},{"title":"鸟哥linux私房菜琐碎知识点","slug":"鸟哥linux私房菜琐碎知识点整理","date":"2021-10-08T04:00:00.000Z","updated":"2022-11-27T03:06:05.234Z","comments":true,"path":"posts/52308.html","link":"","permalink":"https://kkkkkong.github.io/posts/52308.html","excerpt":"","text":"鸟哥linux私房菜琐碎知识点 看懂了在整理，这样子整理的才有意义； 切记不要为了整理而整理！！！ 0. 计算机基础知识固态硬盘（solid state disk，ssd）​ 优点：马达不需要转动，所以速度快； ​ 缺点：写入次数限制，所以寿命短； 数据表示方式文字编码系统 每个符号（英文数字或符号）都占用1bytes，所以有2^8^&#x3D;256种变化； 每个汉字占用2bytes，所以用216&#x3D;65536种变化，即可表示6w多个中文字； big5码的中文字编码仅仅定义了一万三千多个中文字，所以有些中文使用big5无法实现； big5中某些字码像是【许、盖、功】等字，由于这几个字的内部编码会误判为单双引号，所以常常出现乱码。（不仅中文字，其他非英语系国家也会有这样的问题出现）。 为解决上面的问题，国际组织ISO&#x2F;IEC制定了所谓的Unicode编码系统，我们常称为utf-8或者万国码。该编码打破了所有国家的不同编码，因此大多用户选择这个编码系统。 软件程序运作机器程序与编译程序机器语言：全部由0和1组成，人类识别起来相当难！ 高级语言：计算机科学家大牛们为了推动人类计算机事业的发展，设计了一种人类能看得懂的语言，然后创造一种【编译程序】来将这些人类写的语言转译成机器能够看懂的机器码。 操作系统本质：也是一组程序，程序的终点在于管理计算机的所有活动以及驱动系统中的所有硬件。 1.linux是什么？、如何学习？是什么 简单定义：操作系统。 历史：主要原因是一些大牛为了完成自己的兴趣主键开发形成的一款操作系统，非常重要的一点是open source。 知识点 GNU&#x3D;GNU‘s Not Unix，:smile:大佬的脑子搞不懂。 GCC&#x3D;GNU Compiler Collection，是linux下的编译器，目前支持C、C++、Java、Objective-C、Fortran、Ada。 GPL&#x3D;GNU General Public License，自由软件的版权。 open source 协议说明 linux发展 重要人物：Linus Torvalds（托瓦兹），早期的Unix系统只提供运算功能，terminal仅负责IO，他想自己搞一个Unix，首先找到了minix。 386硬件的多任务测试：理论上一个CPU在一个时间段内只能处理一个任务，具有多任务能力的CPU可以在不同程序之间切换，eg：一个CPU频率为1GHz，表示他一秒钟可进行10^9^次运算，假设每个程序以1000次作为运作周期，则CPU一秒钟就能切换106次，如此快的运算速度，人为感觉两个程序是同时运行的了。 linux0.02：托瓦兹参考minux的设计理念，写出的操作系统，早期的linux。 linux虚拟团队的发展： 单人维护：最开始托瓦兹将linux核心放置在FTP上，用户下载使用发现问题主动汇给他； 广大黑客加入：托瓦兹总是有解决不了的问题，像是硬件驱动程序的撰写，这是就有人提出可以帮忙写相关程序。托瓦兹的务实态度是linux发展迅速的重要原因。 核心功能逐渐完善：托瓦兹一个人精力有限，所以有一些朋友跳出来帮忙做这些工作，1994年终于完成了linux的核心正式版1.0，94年完成2.0，而这些人其实都没见过面。 linux的核心版本： 奇偶版本分类： 2.6版本以前两股分类： 主次版本为奇数：发展中版本（development）eg：2.5.xx 主次版本为偶数：稳定版本（stable）eg：2.6.xx 主线版本、长期维护版本： 3.0后开始使用 linux核心版本与linux发布商版本 linux核心版本与distribution版本不同 linux核心最新版本4.0.0（2015&#x2F;04）、centos的distribution版本7.x。 linux distributions 出现了诸多版本像是：Red Hat,Ubuntu,Debian等等，但它们使用的核心（kernel）都是官方提供的，各种标准都相同，基本上除了开发商自家开发出的软件外，不同版本的差异并不大。 鸟哥的分类： 使用RPM方式安装软件的系统：Red HAT、Fedora、SUSE等； 使用dpkg方式安装软件的系统：Debian、Ubuntu、B2D等； 鸟哥的选择建议： linux当前的应用角色主要分为企业应用于个人应用，这几年非常流行的云端运算机制中，linux似乎更有着力点。 企业应用 网络服务器：继承了Unix高稳定性的良好传统，linux上面的网络功能非常稳定，又有GNU计划于GPL授权模式，很多优秀的软件都在linux上发展。–15年为止，广泛流传的distribution仍旧是Red Hat和SUSE两个大厂。 关键人物的应用：金融数据库、大型企业网管环境，像是金融业将存储数据的任务交给了linux。 学术机构的高效能运算任务：服务器的CPU可以增加许多，而且linux的创造者本身就是一个性能癖，所以拥有强大的运算能力，加上linux具有支持范围广泛的GCC编译器，因此在这方面的优势相当明显。 个人环境的使用平时接触的电子产品中，好多东西都有linux的存在，没看之前我还真不知道是linux提供的支持。 桌面计算机：在个人使用的计算机下，大多是办公学习之类的，desktop环境最需要的就是窗口，但最开始linux的设计者是一大堆工程师大牛，大牛们对于窗口并不是很需要，所以早期的linux并受众面并不是特别广泛；后来为了强化桌面计算机的使用率，linux与X Window System结合了 X Windows System相当于在linux上运行的软件，就算他挂了，对linux也可能不会有直接的影响呢！ 手持系统：手机、pda；Google推出的Android手机专用操作系统，其实就是linux核心的一支，专门针对手机、平板这类的ARM机器所设计的。 观察了我的手机，Android系统9.0，linux kernel4.9.148 嵌入式系统： 理解：直接嵌入到产品当中的操作系统，理论上用户不会更动这个操作系统，所以叫嵌入式系统。 产品例子：路由器、防火墙、手机、机器人控制芯片、家电用品的微电脑控制器等，都有linux的身影。 不过嵌入式开发需要很熟悉linux kernel与驱动程序的结合才行，我准备在接下来尝试一些学习。 云端使用 分久必合，合久必分：早期贼贵的大型主机分配终端的集中运算，到2010年前个人计算机运算能力增强，大部分运算在桌机或者笔电上进行，到现在人类活动的发达，产生庞大的数据需要集中处理，从而产生云端系统的需求，将信息集中管理。 数据集中在云端，企业员工无时无地都可以办公，不知对于员工来说是喜是忧:smile: 云程序：公司内部私有云、大型因特网供货商等等 端设备：连接上面的云程序，很多时候使用智能手机、平板，连接到某云就可以使用了；还有像是更迷你的端点设备树莓派、香蕉派，网上售价百十块钱的样子。 linux该如何学习 拒绝X Window的环境，因为它只算是一个linux的一个应用，对于某些深入级别的知识学习没有帮助。 站在要让linux成为自己的好用的工具为出发点学习。 从头学起。vi文本编辑器、shell scripts 、软件管理员（安装方式） 讨论地址 http://phorum.study-area.org/ https://phorum.vbird.org/ 好习惯 兴趣、成就感 不同的环境下，解决问题的办法有很多种，只要行得通，就是好办法！ 2.主机规划与磁盘划分linux与硬件搭配1.计算机硬件配备 游戏or工作：一般的三位计算机游戏所需要的3D光影运算很多，显示适配器与CPU资源被耗用的就回很多，所以需要比较高的配置。而工作大多需要的是办公软件，所以多数入门级的极端及都能拍的非常流畅了。 效能与与价格：个人用户似乎不太考虑这个，但是对于一些企业，就不得不考虑用电带来的经济账。 支援度：有些极端及的硬件设计可能不支持某些操作系统，及时自己可以会搞编译程序，也要弄清楚硬件是否支持呐！ 2.linux搭配主机日常个人使用做个小服务器不需要太高的性能，CPU i3的够用，但是做一些重要的功能，还是需要高档一些的计算机配备了。 个人服务器的基本要求： CPU：Intel i3的CPU不算太久，够用。 RAM：主存越大越好，因为如果主存不够用，就会用到硬盘的内存置换空间，而硬盘的速度要比内存速度慢得多，所以主存太小会影响整体系统的性能，如果再加上有X Window的话，主存太小会炸掉；一般的小型服务器，至少也要512MB以上的主存储器。 Hard Disk：硬盘容量取决于个人用途，小型服务器20G基本够用。 VGA：如果你不使用X Window，显示适配器可有可无，如果使用，显示器最好拥有32MB以上的内存。 NetWork InterFace Card：服务器上最重要的组件之一，但没看懂，后面会讲吧。 光盘，软盘、键盘and鼠标：能用就行，做服务器可能多数情况下不怎么用，通过网络管控，类似云服务器。 3.各硬件装置在linux文件夹中的命名 在linux中，每个装置都被当成一个文件夹来对待 使用虚拟机学习 Windows：VMware、VirtualBox linux：KVM 磁盘分区磁盘连接方式与装置文件名的关系正常实体机大概使用的都是&#x2F;dev&#x2F;sd[a-]磁盘文件名，但是在虚拟环境下，为了加速可能就会有&#x2F;dev&#x2F;vd[a-p]这种装置文件名。 我的阿里云服务器，centos7.4，对应的文件名称为&#x2F;dec&#x2F;vda、&#x2F;dev&#x2F;vda1 MSDOS（MBR）与GPT磁盘分区表 MSDOS：早期的linux系统为了兼容Windows的磁盘，使用的是Windows支持的MBR（Master Boot Record，主要开机记录区）的方式处理开机管理程序与分区表。 吧啦吧啦，脑子不够用，看不懂了，总之这里出现了文件名称后面的对应数字。&#x2F;dev&#x2F;sda2 GUID partition table，GPT磁盘分区表 也看不懂，容我歇歇，叫脑子起床 开机流程中的BIOS与UEFI开机检测BIOS搭配MBR&#x2F;GPT的开机流程 BIOS不懂GPT UEFI BIOS搭配GPT 知识点：过去有一些cracker经常有BIOS的开机阶段来破坏系统，取得系统控制权，所以UEFI加入了一个所谓的安全启动（secure boot）机制，代表着即将开机的操作系统必须要被UEFI所验证，否则无法顺利开机，有些时候需要将此功能关闭，才可以进入linux系统。 linux安装的磁盘分区 目录树结构 所有文件都是由根目录衍生来的 文件系统与目录树的关系：挂载 定义：所谓的挂载就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下，即进入高目录就可以读取该分区槽。 当数据在&#x2F;home下的次目录时，对应的数据就是放在partition2的，如果不是在&#x2F;home下的数据，则被放置在partition1。 安装前的规划选择合适的distribution 考虑网络环境的安全性，尽量选择最新的版本。 若linux定位在服务器上，Red Het Enterprise Linux orSUSE Enterprise Linux比较不错，因为版本更动幅度比较小，并且更新支持的期限比较长。 主机的服务规划与硬件的关系打造Windows、Linux双系统 NAT：达成IP分享器的功能 通常像学校单位大多会有一条对外的联机，然后全校的计算机透过这个设备连接到互联网上，此时就得要使用IP分享器让这一条对外联机分享给所有的成员是用；在linux下要想达成此功能，需要透过NAT服务达成。 此时由于网络流量会比较大，网络卡就需要比较好的配备，而CPU、RAM硬盘等的影响力就小很多。 其实，仅利用linux作为NAT主机来分享IP是很不值的，因为PC的耗电能力要比IP分享器大很多。但由于NAT还可以加装更多的分析软件，实现控制带宽、流量等功能。 SAMBA：加入Windows 网上的邻居Windows系统之间传输数据是用过网络邻居来循环数，但Windows 7的芳邻只能同时分享10步客户端联机，超过的话就要等待。 在linux上使用SAMBA软件达成加入Windows网邻的功能，无客户端限制，适合学校的文件服务器角色。 同样，由于分享的数据量较大，网卡与硬盘大小及速度就比较重要。此时可以考虑将&#x2F;home 目录独立出来，并且加大容量。 Windows传输文件通过网络邻居？？？我不太懂哇，大家似乎传输的方式很多呐，不过还真没用过网络邻居。:smile: Mail：邮件服务器 现在免费的邮箱已经很多了，个人使用的邮箱应该不需要建设mail server 了，但是如果你是一家私人企业，一些邮件是有商业机密或隐私性的，就需要mail server 了，重要的硬件需求也是硬盘容量与网卡。此时可以将&#x2F;var 目录独立出来，并且加大容量。 Web：WWW服务器WWW服务器几乎所有网络主机都会安装的一个功能，除了提供Internet的WWW联机，很多在网络主机上面的软件功能，也都使用WWW作为接口；若要提升WWW副武器的性能，通常提升RAM是一个不错的选择。 DHCP：提供客户端自动取得IP的功能 若你是一个局域网络管理员，区域内部有数十个计算机被使用，这些计算机联网时当然是自动分配比较省力，这就是DHCP的功能；这个功能对硬件的需求不是很高了。 FTP FTP软件进行资源分享还是比较普遍的，硬盘容量与网卡质量相当重要。 主机硬盘的主要规划 要考虑到计算机硬件出现问题时，文件数据能否安全保存 鸟哥说：没有装过十次以上的linux，是学不会linux与磁盘分区的:smile: 我有幸装过两三次了 3.安装CentOS7.x 由于我之前安装过Ubuntu1604，加上租的阿里云的Centos7.4的云服务器，这章就不跟着整理了。 4.登入系统登入一般使用非管理员用户登录，因为系统管理员权限太高，避免出现一些手滑操作。 基础操作介绍 Ctrl+Alt+F1-F6切换终端 简单文本在线文本编辑器：nano 关机指令：shutdown、poweroff、reboot、halt 复杂关机指令：systemctl 【指令】，上面的几个指令都是调用这个指令。 5.Linux的文件权限与目录配置使用者与群组 文件拥有者（owner）：Linux是多人多任务的系统，因此可能会有多人同时使用一部主机的情况，此时文件拥有者这个角色就相当重要，不想让别人看到的文件，就可以设置成只有文件拥有者才可以看到文件的内容。 群组（group）：比如在团队协作的时候，某些文件是具有一定的保密性的，只能让团队里面的成员使用，组内成员之间可以互相修改对方的数据，但是其他组的成员不能看到本组的文件内容。帐号支持多群组设定。 其他人（others）：与文件拥有没有任何关系，只有上述两种使用者给予权限才可访问。 上图中例子：以王三毛为例，王三毛这个文件的拥有者为王三毛，王三毛属于王大毛这个群组，而张小猪相对于王三毛，只是个其他人而已。 图中有一个特殊的人物，就是天神（root），拥有无限的权利，所以他可以访问任何一个地方。 用户身份与群组记录文件 root相关的信息记录在&#x2F;etc&#x2F;passwd 个人的密码信息记录在&#x2F;etc&#x2F;shadow Linux所有的组名记录在&#x2F;etc&#x2F;group 打开这三个文件后，发现并不能看懂:smile: Linux文件权限概念Linux文件属性 第一栏表示这个文件的类型与权限 共有10个字符 第一个字符代表文件类型 d：目录 -：文件 l：链接文档（link file） b：装置文件里面可供存储的接口设备 c：装置文件里面的串行端口设备，例如鼠标键盘 接下来的字符中三个为一组，均为”rwx“三个参数的组合 r：可读；w：可写；x：可执行（execute），三个参数的位置不会变，如果没有权限，会用-代替。 第一组为文件拥有者可具备的权限，上图中对应的权限为rw，表示拥有者可读写，但不可执行。 第二组为加入群组的用户的权限，途中对应权限为r，表示群组内用户可写。 第三组为其他用户的权限，途中对用权限为r，表示其他用户可写。 第二栏表示有多少档名链接到此节点 每个文档都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用温金明来记录，因此每个档名会连接到一个i-node。从.目录和.. 目录就可以看出个数。 第三栏表示这个文件的拥有者名称 图中文件为root用户有。 第四栏表示这个文件的所属群组 图中文件的所属群组为root，在root群组内的用户拥有r权限。 第五栏表示文件的容量大小 默认单位为bytes，图中文件容量为148bytes。 第六栏表示文件的建档日期或者是最近的修改日期 这一栏的内容分别为日期（月&#x2F;日）及时间，如果修改的时间局不是在现在的时间年份，会显示年份。 如果想看完整的时间格式，使用：ls -l –full-time 就能显示出完整的时间格式了。 第七栏为这个文档的名称 如果文档名前面有一个[.]，则代表这个文件为隐藏文件。 对于目录的权限： r：读包含目录中的文件名称； w：写信息到目录中去（增加和删除索引点的链接）； x：搜索目录（能用改目录名称作为路径名去访问它所包含的文件个子目录）；拥有此权限相当于拥有了目录下文件名称及内容的权限。 即： 有只读权限的用户不能用cd进入该目录，还必须有执行权限才能进入。 有执行权限的用户只有在知道文件名，并拥有文件的读权利的情况下才可以访问目录下的文件。 必须有读和执行权限才可以ls列出目录清单，或者使用cd进入该目录。 有目录的写权限，可以创建、删除或修改该目录下的任何文件或子目录，即使该文件或子目录属于其他用户。 Linux文件权限重要性 系统保护的功能：像是&#x2F;etc&#x2F;shadow 这种文件，用来保存系统中所有账号的数据，不能被任何人读取，所以对应权限为———，只有root可读。 团队开发数据共享：希望某些文件只有你团队的人可以实用，其他人都不能看到的时候。 未将权限合理化的危害：比如给了用户开关机权限，使用者不小心关了机，系统就会慕名的挂掉；或者密码被其他人士获得了，他使用root登录就会轻而易举的做root的一些工作。 改变文件属性与权限 更改所属群组：chgrp 被改变的组名必须要在&#x2F;etc&#x2F;group 文件内存在才行。 更改文件拥有者：chown 被更改的用户名必须要在&#x2F;etc&#x2F;passwd 文件内才行。 更改文件权限：chmod 数字类型更改权限： r:4;w:2;x:1；暴力授权的时候经常用的：chmod 777 filename。 符号类型更改权限： 使用user（u）、group（g）、others（o）表示三种身份的权限，a则代表全部的身份。 目录与文件之权限意义 权限对文件的重要性 Windows下的可执行文件室友拓展名来判断的，像是.exe、.bat、.com等，但是在Linux下，是否能够执行，完全是由x这个权限确定的，跟文档名没有绝对的关系。 w权限，表示可以写入、编辑、新增、修改文件内容的权限，但并不具有删除文件本身的权限。对于文件的rwx，都是针对文件的内容而言的，与文档的存在与否没有关系。 权限对目录的重要性 r：具有读取目录结构列表的权限，可以查询该目录下的文件名数据，所以你可以使用ls指令将目录的内容显示出来。 w：这个权限对于目录来说比较重要，表示用户拥有变更目录结构的权限，即： 建立新的文件与目录； 删除已经存在的文件与目录（无论该文件的权限如何）； 将已存在的文件或目录进行更名； 移动该目录内的文件与目录的位置； 总之，w权限与该目录下的文件名变更有关。 x：代表用户能否进入该目录成为工作目录的用途。 上图例子中，r都不是必须的，因为我知道要找的文件file1的名字，缺少r只是缺少了tab补全。 Linux文件种类与拓展名 文件种类 正规文件（regular file） 在查看文件属性时，第一个字符为-的文件； 按照文件内容，大致分为： 纯文本文档（ASCII）：Linux系统中最多的一种文件类型，几乎用来作为设定的文件都是这个文件类型。 二进制文件（binary）：Linux当中的可执行文件就是这种格式，比如指令cat。 数据格式文件（date）：有些文件在运行的过程当中会读取某些特定格式的文件，这些文件可被称作数据文件，数据文件了可以使用last读出来，但使用cat就会出现乱码。 目录（directory） 第一个属性为d。 连接文档（link file） 类似Windows下的快捷方式，第一个属性为l。 设备与装置文件（device） 与系统周边及储存相关的一些文件，通常都集中在&#x2F;dev这个目录下，通常分为两种： 区块（block）设备文档：一些存储数据，以提供系统随机存取的接口设备，比如硬盘与软盘，第一个属性为b。 字符（character）设备文件：即一些串行端口的接口设备，例如键盘鼠标，特征为一次性读取，不能够截断输出。例如不能让鼠标跳到另一个画面，而是连续滑动，第一个属性为c。 资料接口文档（sockets） 这种文件通常被用在网络上的数据承接，当启动一个程序来监听客户端的要求，客户端就可以通过这个socket进行数据的沟通了。第一个属性为s。 数据传送文件（FIFO，pipe） FIFO也是一种特殊的文件类型，主要目的在解决多个程序同时存取一个文件所造成的错误问题。第一个属性为p。 文件拓展名 基本上Linux没有所谓的拓展名，一个文件能不能执行，取决于第一栏的十个属性。不过文件能不能执行成功还要取决于文件是否具备可执行的程序代码。 虽然如此，我们仍希望可以通过文件名来了解某文件是什么东西，所以我们通常还是会以适当的拓展名来区分文件种类的： .sh：脚本或批处理文件，因为批处理文件用shell写成，所以缩写为sh。 Z，.tar，.tar.gz，.zip，tgz：经过打包的压缩文件。因为压缩软件分别为gunzip，tar等，所以取名。 .html，.php：网页相关文件，分别代表HTML语法与PHP语法的网页文件。 文件名长度限制 最大容许文件名255bytes，即约英文字符255个，中文字约128个。 文件名限制 文字接口下的一些指令的操作关系，在设定名称时，最好避免一些特殊字符：*?&lt;&gt;;[]{}()&amp;&#96;’”-| Linux目录配置Linux的目录配置依据—FHS 由于使用Linux开发产品或者distributions的开发者太多了，如果每个人都按照自己的想法来配置文件防止的目录，那可能会造成管理上的困扰，这就有了后来的FHS（Filesystem Hierarchy Standard）标准出炉了。 FHS根据文件系统使用的频繁与否与是否允许使用者随意更改，而将目录定义成为四种交互作用的形态，类似下图： 这是一些代表性的目录，关于这四种类型： 可分享的：可以分享给其他系统挂在使用的目录，像是执行文件、用户的邮件等数据。 不可分享的：自己机器上面运作的装置文件或者与程序有关的socket文件等，由于仅仅与自身及其有关，所以当然不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着distribution而不变动，例如函数库、文件说明文件、系统管理员所管理的主机服务配置文件等等。 可变的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 事实上，FHS针对目录树架构仅定义出三层目录下应该放什么数据而已，分别为： &#x2F;（root，根目录）：与开机系统有关； &#x2F;usr（unix software resource）：与软件安装、执行有关； &#x2F;var（variable）：与系统运作过程有关。 下面是FHS系统规定的必须要存在的目录以及建议存在的目录 在CentOS 7 中，目录编排与过去版本不同，将一部分原本在根目录下的目录，内部数据全部挪到&#x2F;usr 中，然后进行连接设定，具体如下： 目录树 如图，&#x2F;var 目录最好能够独立出来，这样对于系统的数据还有一些安全性的保护，至少&#x2F;var 死掉时，根目录还活着，还能够进入救援模式。 个人理解因为&#x2F;var 存放的是常态性变动文件，所以容易被搞出事情，所以这里强调将其单独放出来。 绝对路径与相对路径绝对路径：一定是从根目录写起； 相对路径：从相对于当前工作目录的路径写起； . ：代表当前的目录，可使用.&#x2F;代替； .. ：代表上一层目录，可使用..&#x2F;代替； 之前编译过后进行的文件运行时使用.&#x2F;run.sh，就表示的是本目录下的run.sh 文件。 6.Linux文件与目录管理目录与路径绝对路径与相对路径用途 绝对路径：比如在使用shell编写管理系统的程序时，写绝对路径虽然比较麻烦但是保险。 相对路径：在同目录下多个文件操作，或者文件树比较深的时候，相对路径简洁的优势就显现出来了。 目录的相关操作常用指令：cd、pwd、mkdir、rmdir。 根目录下也是存在.. 目录的，不过与. 目录所指的是同一个目录。 cd（change directory，变换目录） cd、cd ~ ：指的都是返回家目录； cd - ：指的是返回上次的目录，类似电视机遥控器的返回键。 pwd（print working directory，显示目前所在的工作目录） pwd -P 表示显示实际路径，而非使用链接路径。 mkdir（make directory，建立新目录） 默认情况下，需要的目录需要一层一层建立。 mkdir -p pathname&#x2F;pathname2&#x2F;filename ：指的是递归建立目录。 -m 参数表示预设权限：我的CentOS7.7默认的权限是755。 同时-p -m 创建的目录，只有最底层目录的权限是预设参数，其他的均为默认值。 默认属性跟umask有关。 rmdir（remove directory，删除目录） -p ：递归删除空目录，像是rmdir -p test&#x2F;kong&#x2F;； rm -r ：可删除非空目录。 关于执行文件路径的变量：$PATH像是Windows中的环境变量一样，Linux中的环境变量为用户可以在任何地方使用某些指令提供了帮助。 以ls为例，当你输入ls，系统会按照PATH的设定去每个PATH目录下搜寻文件名为ls的可执行文件，若遇到多个名为ls的文件，那么先搜索到的同名文件先执行。 echo $PATH 指令可以查看当前的环境变量。echo有打印的意思，$后面接的是变量，所以会显示出目前的PATH。 将&#x2F;usr&#x2F;bin&#x2F; 目录下的ls文件移动到&#x2F;root&#x2F;中，会发现ls无法使用，但是使用绝对路径&#x2F;root&#x2F;ls或者&#x2F;root目录下.&#x2F;ls可以执行，说明这个目录不在PATH中。 添加PATH：PATH&#x3D;”${PATH}:&#x2F;root”。 安全起见，不建议将. 加入PATH中，避免写某些文件过度使用权限。 文件与目录管理文件目录查看：ls bash shell 实现了将ll 代表ls -l 的指令。 复制、删除与移动：cp，rm，mv cp（copy） 常用-a 或-p 来完整复制文件的权限，否则都会按照默认的权限复制的！ 总之，由于cp有种种的文件属性与权限的特性，所以在复制时必须要考虑到： 是否需要完整的保留来源文件的信息？ 来源文件是否为链接文档？ 来源文件是否为特殊文件，如FIFO，socket 等？ 来源文件是否为目录？ rm（remove） rm -r 递归删除一些废弃文件夹很好用，慎用。 当然还有毁天灭地的rm -rf &#x2F;* 指令，千万别用！！！:smile: mv(move) 获取路径的文件名与目录名称 文件内容查阅 cat：从第一行开始显示文件内容； tac：从最后一行开始显示，其实是cat倒着拼写； nl：显示的时候，输出行号； more：一页一页显示文件的内容； less：与more相似，不过他可以向前翻页； head：只看前几行； tail：只看尾巴几行； od：以二进制的方式读取文件内容。 前三个都是一口气阿静数据显示在屏幕上面，more和less都可以一页一页的观察。 cat(concatenate) tac 有点意思，tac就是将cat输出的内容按照行数倒序连续输出。 nl(添加行号打印) nl的预设和cat -n有点不太一样，nl可以将行号做比较多的显示设计，包括位数与是否自动补齐0等等。 more() 空格键：代表向下翻一页； 回车键：代表向下翻一行； &#x2F;字符串：代表在这个显示的内容当中，向下搜索【字符串】这个关键词； :f ：立即显示文件名以及目前的行数； q ：代表立即离开more，不在显示文件内容； b 或【Ctrl】-b：代表往回翻页，支队文件有效，对管线无效； 尝试使用&#x2F; 搜索，不知为何失败了。 less(一页一页翻动) man page 就是使用less来显示说明文件的内容的。 head(取出前面几行) 如果n 为负数，代表不显示后面-n行。 tail() 类似tail ，相反方向。 od(非纯文本文档) 修改文件时间或新建文档：touch Linux下记录许多的时间参数，其实是三个主要的变动时间： modification time（mtime） 当文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容。 status time（ctime） 当文件的状态改变时，就会更新这个时间，像是权限与属性被更改了，就回更细这个时间。 access time（atime） 当文件的内容被取用时，就会更新这个时间，比如使用cat读取文件内容，就会更新这个时间。 touch改变的是mtime和atime，因此常被用来更改文件日期为某时间。 另一个常用是创建一个空文件。 文件与目录的默认权限与隐藏权限文件预设权限：umask默认权限的属性上，目录与文件是不一样的，一般情况下，x权限对于目录来说十分重要，而文件则主要是用于数据记录，不需要执行权限。所以： 当使用者建立文件则预设没有可执行权限，即只有rw两个权限，最大的数字表示为666，即-rw-rw-rw-； 当使用者建立目录则预设默认所有权限均开放，最大数字为777，即drwxrwxrwx。 umask的数字代表被减掉的权限，以umask为022为例，相当于： 文件隐藏属性 chattr（配置文件隐藏属性） lsattr（显示文件隐藏属性） 文件特殊权限：SUID，SGID，SBIT Set UID 当s出现在文件拥有者的x权限上时，即称为SUID。 SUID针对文件设定。 例子：Linux的所有账号密码都在&#x2F;etc&#x2F;shadow 这个文件里，这个文件权限为———- 1 root root ,即为只有root可用。但是作为普通用户可以通过passwd修改自己的密码，更改该文件，这就是SUID的功能。 但是像用户dmtsai并不能使用cat查看&#x2F;etc&#x2F;shadow ，因为cat不具有SUID权限。 Set GID 当s出现在文件群组的x权限上时，即称为SGID。 SGID针对目录和文件设定。 当对一个文件设定了SGID权限时： 与SUID类似，在执行一些有SGID权限的文件时会获得对应群组的权限支持。 当对一个目录设定了SGID权限时： Sticky Bit SBIT仅作用在目录上。对于目录的作用为： 当用户对目录具有rwx权限时； 用户在该目录下创建文件或者目录，仅有自己与root才有权利删除该文件。 t的作用就是不能删除别人的文件。 留白，root用户创建的777权限的目录下，普通用户能否进行更改权限，删除文件等操作。 1正常情况下，更改权限只能是文件拥有者或是root用户进行。该目录下用户可以删除文件和空目录，非空目录能否删除取决于目录及目录内文件的权限设置。 权限设定 数字指令 SUID：4 SGID：２ SGIT：１ 在原先的７７７权限之前加上一个数字，因为这三个数字分别在三个用户组下，所以不会有冲突。像是chmod 4755 filename ，当出现Ｓ，Ｔ时，表示对应位置没有ｘ权限。 字母指令 观察文件类型：file 指令与权限的搜寻脚本文件名的搜寻 which type 文档名的搜索 whereis locate &#x2F; updatedb find find 有很多的用途，懒惰至极的我没整理。 这一章后面的习题很精彩，在Pages 276 认识Linux的文件系统","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://kkkkkong.github.io/tags/linux/"}],"author":"kong"},{"title":"push项目遇到timeout","slug":"git timeout问题","date":"2018-01-01T04:00:00.000Z","updated":"2022-11-27T03:06:05.179Z","comments":true,"path":"posts/18120.html","link":"","permalink":"https://kkkkkong.github.io/posts/18120.html","excerpt":"","text":"今天push项目遇到timeout 不知为何遇到了这个问题，仿佛不是第一次了 经过一番百度，找到了解决方案 但不知道为什么，其中的端口号是clash使用的端口号，猜测与其有关 具体操作查看全局配置参数 1git config --global --list 在开启shadowsock的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。 12git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy http://127.0.0.1:7890 其中的7890改成你的ssh端口号 http:&#x2F;&#x2F;也可以改成sockets5:&#x2F;&#x2F;,但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。 取消代理： 12git config --global --unset http.proxy git config --global --unset https.proxy 然后就可以使用了","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/tags/github/"}],"author":"kong"}],"categories":[{"name":"Java","slug":"Java","permalink":"https://kkkkkong.github.io/categories/Java/"},{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/categories/leetcode/"},{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/categories/github/"},{"name":"git","slug":"git","permalink":"https://kkkkkong.github.io/categories/git/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"学习","slug":"学习","permalink":"https://kkkkkong.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kkkkkong.github.io/tags/Java/"},{"name":"刷题","slug":"刷题","permalink":"https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"github","slug":"github","permalink":"https://kkkkkong.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://kkkkkong.github.io/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"https://kkkkkong.github.io/tags/ssh/"},{"name":"学习","slug":"学习","permalink":"https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"实时调度器","slug":"实时调度器","permalink":"https://kkkkkong.github.io/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"},{"name":"小说","slug":"小说","permalink":"https://kkkkkong.github.io/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"非技术","slug":"非技术","permalink":"https://kkkkkong.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"},{"name":"hexo博客","slug":"hexo博客","permalink":"https://kkkkkong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"linux","slug":"linux","permalink":"https://kkkkkong.github.io/tags/linux/"},{"name":"市场经济","slug":"市场经济","permalink":"https://kkkkkong.github.io/tags/%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E/"},{"name":"定价方法","slug":"定价方法","permalink":"https://kkkkkong.github.io/tags/%E5%AE%9A%E4%BB%B7%E6%96%B9%E6%B3%95/"},{"name":"最优化问题","slug":"最优化问题","permalink":"https://kkkkkong.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"},{"name":"摩斯电码","slug":"摩斯电码","permalink":"https://kkkkkong.github.io/tags/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81/"},{"name":"merge","slug":"merge","permalink":"https://kkkkkong.github.io/tags/merge/"},{"name":"pull","slug":"pull","permalink":"https://kkkkkong.github.io/tags/pull/"},{"name":"java","slug":"java","permalink":"https://kkkkkong.github.io/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://kkkkkong.github.io/tags/JDBC/"},{"name":"leetcode","slug":"leetcode","permalink":"https://kkkkkong.github.io/tags/leetcode/"},{"name":"浮点数精度","slug":"浮点数精度","permalink":"https://kkkkkong.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"},{"name":"githubpags","slug":"githubpags","permalink":"https://kkkkkong.github.io/tags/githubpags/"},{"name":"jekyll","slug":"jekyll","permalink":"https://kkkkkong.github.io/tags/jekyll/"},{"name":"排序","slug":"排序","permalink":"https://kkkkkong.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"typora","slug":"typora","permalink":"https://kkkkkong.github.io/tags/typora/"}]}