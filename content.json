{"meta":{"title":"虫兑变的博客","subtitle":"我的博客","description":"","author":"Kong Weichao","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-11-27T02:47:24.114Z","updated":"2022-11-19T12:50:54.398Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-27T02:47:19.876Z","updated":"2022-11-27T02:47:19.876Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍，写啥还没想好"},{"title":"书单","date":"2022-11-27T02:47:42.479Z","updated":"2022-11-27T02:47:42.479Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"目前还没有！"},{"title":"分类","date":"2022-11-27T02:47:48.803Z","updated":"2022-11-19T12:50:54.402Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-27T02:48:02.522Z","updated":"2022-11-27T02:48:02.522Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":"链接测试"},{"title":"标签","date":"2022-11-27T02:48:08.642Z","updated":"2022-11-19T12:50:54.405Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-11-20T02:03:45.950Z","updated":"2022-11-19T12:50:54.404Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"酒香归纳","slug":"酒香归纳","date":"2022-11-27T10:23:39.000Z","updated":"2022-11-27T10:36:21.409Z","comments":true,"path":"posts/57461.html","link":"","permalink":"http://example.com/posts/57461.html","excerpt":"","text":"酒香归纳 偶尔会接触一些酒，但总是听说各种香型，但都没太深的了解，这里先记录一下，以后有机会都尝一尝 香型及其特征 各香型代表酒 酱香型 茅台 清香型 汾酒 浓香型 五粮液、泸州老窖、剑南春 凤香型 西凤酒 董香型&#x2F;药香型 董酒 米香型&#x2F;蜜香型 桂林三花 芝麻香型 景芝酒 豉香型 佛山石湾玉冰烧 兼香型也叫浓酱兼香型白酒 白云边 老白干 衡水老白干 馥郁香 酒鬼酒 特香型","categories":[],"tags":[{"name":"非技术","slug":"非技术","permalink":"http://example.com/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"}]},{"title":"自动部署hexo博客","slug":"自动部署hexo博客","date":"2022-11-26T13:30:25.000Z","updated":"2022-11-27T03:06:05.188Z","comments":true,"path":"posts/32022.html","link":"","permalink":"http://example.com/posts/32022.html","excerpt":"","text":"懒人脚本每次写完博客，都要输入一串机械化的命令，很无聊，索性写个bat脚本，具体内容如下： 12@echo offhexo clean&amp;&amp;hexo g&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source&amp;&amp;pause 然后以bat的格式保存在博客目录下，点击执行即可（比如这篇博客就是这么发布的） 指令解释： @echo off ：关闭cmd指令的回显 hexo clean&amp;&amp;hexo g&amp;&amp;hexo d ：hexo的指令，分别是： hexo clean：清除缓存文件 db.json 和已生成的静态文件 public hexo g：生成网站静态文件到默认设置的 public 文件夹 hexo d：自动生成网站静态文件，并部署到设定的仓库 git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source，是git指令 pause：暂停执行的语句 其中的远程仓库分支source是github的项目分支之一，hexo里设置在hexo d后将代码部署到master分支中，我设置了source分支用来保存其他代码（当然不包括一些静态代码和node的代码），防止换了设备之后会丢失内容 方便好用，强烈推荐","categories":[],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"实时调度器","slug":"实时调度器","date":"2022-11-26T12:30:23.000Z","updated":"2022-11-27T03:16:04.046Z","comments":true,"path":"posts/46423.html","link":"","permalink":"http://example.com/posts/46423.html","excerpt":"","text":"LINUX调度器关系图 所谓调度，就是按照某种调度的算法，从进程的就绪队列中选取进程分配CPU，主要是协调对CPU等的资源使用。进程调度的目标是最大限度利用CPU时间 linux里的调度器 RT调度器， rt_sched_class：实时调度器，为每个优先级维护一个队列 CFS调度器， cfs_sched_class：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念，采用红黑树实现进程实体的存放； 调度策略FIFO、RRlinux的进程分为两大类：实施进程和普通进程 二者的根本不同在于：如果系统中有一个实时进程可以运行，那么调度器总是会选择它，除非另有一个优先级更高的实时进程 实时进程分为两种策略进行调度： SCHED_FIFO：没有时间片，在被调度器选择之后，可以运行任意长时间。 SCHED_RR：有时间片，其值在进程运行时会减少。在所有的时间段都到期后，则该值重置为初始值，而进程则置于队列末尾。这确保了在有几个优先级相同的SCHED_RR进程的情况下，它们总是依次执行。 runqueue 运行队列 每个CPU都有一个运行队列，每个调度器都作用于运行队列； 分配给CPU的task，作为调度实体加入到运行队列中； rt_rq的结构 这里每一个CPU的运行队列rq内都有一个实时进程运行队列rt_rq，制定了优先级链表，链表个数为优先级个数，每个链表存放对应就绪状态的进程实体 调度程序 enqueue_task_rt(struct rq *rq, struct process_control_block *p, int flags) 将进程添加到对应rt_rq的优先级的队列中去 dequeue_task_rt(struct rq *rq, struct process_control_block *p, int flags) 从rt_rq的优先级队列中取出某一个进程 pick_next_task_rt() 从优先级队列中取出当前优先级最高的进程 sched_rt() 此函数是进程调度的核心函数 核心逻辑：选择另一个进程来替换掉当前的运行进程。具体替换进程的选择是通过pick_next_task_rt()函数来实现的 参考链接sched(7) - Linux manual page (man7.org) 【原创】（一）Linux进程调度器-基础 - LoyenWang - 博客园 (cnblogs.com) Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验 - ArnoldLu - 博客园 (cnblogs.com) RT调度学习笔记（1） - Hello-World3 - 博客园 (cnblogs.com) (15条消息) Kernel Scheduler学习之五：RT 调度器_sucjhwaxp的博客-CSDN博客","categories":[],"tags":[{"name":"实时调度器","slug":"实时调度器","permalink":"http://example.com/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"市场体制下企业定价方法","slug":"市场经济定价机制","date":"2022-11-23T11:01:59.000Z","updated":"2022-11-27T03:06:05.187Z","comments":true,"path":"posts/25422.html","link":"","permalink":"http://example.com/posts/25422.html","excerpt":"","text":"在市场经济中，卖方才有定价权，因此需要考虑主要价格制定与变动的是卖方 现有的企业定价方式有三类：成本导向、需求导向和竞争导向 一、成本导向定价法 以营销产品的成本为主要依据制定价格的方法统称为成本导向定价法,这是最简单、应用相当广泛的一种定价方法。 **总成本定价法:**成本加成,目标利润 成本加成定价法（cost-plus pricing），即按产品单位成本加上一定比例的毛利定出销售价。 其计算公式为：P&#x3D;c×(1+r) P—商品的单价 c—商品的单位总成本 r—商品的加成率 目标利润定价法，是根据企业总成本和预期销售量，确定一个目标利润率，并以次作为定价的标准。 其计算公式为：单位商品价格&#x3D;总成本×（1+目标利润率）&#x2F; 预计销量 边际成本定价法：边际成本是企业每增以单位产品所必须支付的成本，采用这种方式暂不考虑固定成本，以边际成本加一定的利润作为最终价格，可以帮助企业迅速打开市场。 盈亏平衡定价：考虑到销售额变化后，成本也在发生变化，这种方法是运用损益平衡原理实行的一种保本定价法。 其公式是： 盈亏平衡点销售量&#x3D;固定成本&#x2F;单位—单位变动成本 盈亏平衡点销售额&#x3D;固定成本&#x2F;1—单位变动成本率 二、需求导向定价法 需求导向定价法是指根据市场需求状况和消费者对产品的感觉差异来确定价格的定价方法。 它包括以下三种 认知导向定价法：是根据消费者对企业提供的产品价值的主观评判来制定价格的一种定价方法。 逆向定价法：它是指依据消费者能够接受的最终销售价格，考虑中间商的成本及正常利润后，逆向推算出中间商的批发价和生产企业的出产价格。 可通过公式计算价格：出厂价格&#x3D;市场可零售价格×（1—批零差率）×（1—进销差率） 习惯定价法：是按照市场长期以来行成的习惯价格定价。 三、竞争导向定价法 竞争导向定价法是企业通过研究竞争对手的生产条件、服务状况、价格水平等因素，依据自身的竞争实力，参考成本和供求状况来确定商品价格。以市场上竞争者的类似产品的价格作为本企业产品定价的参照系的一种定价方法 这种定价方法主要有3方面特点。竞争导向定价主要包括随行就市定价法、产品差别定价法和密封投标定价法。 **随行就市定价法:**在垄断竞争和完全竞争的市场结构条件下，任何一家企业都无法凭借自己的实力而在市场上取得绝对的优势，为了避免竞争特别是价格竞争带来的损失，大多数企业都采用随行就市定价法，即将本企业某产品价格保持在市场平均价格水平上，利用这样的价格来获得平均报酬。此外，采用随行就市定价法，企业就不必去全面了解消费者对不同价差的反应，也不会引起价格波动。 **产品差别定价法:**产品差别定价法是指企业通过不同营销努力，使同种同质的产品在消费者心目中树立起不同的产品形象，进而根据自身特点，选取低于或高于竞争者的价格作为本企业产品价格。因此，产品差别定价法是一种进攻性的定价方法。 **密封投标定价法:**在国内外，许多大宗商品、原材料、成套设备和建筑工程项目的买卖和承包、以及出售小型企业等，往往采用发包人招标、承包人投标的方式来选择承包者，确定最终承包价格。一般来说，招标方只有一个，处于相对垄断地位，而投标方有多个，处于相互竞争地位。标的物的价格由参与投标的各个企业在相互独立的条件下来确定。在买方招标的所有投标者中，报价最低的投标者通常中标，它的报价就是承包价格。这样一种竞争性的定价方法就称密封投标定价法。","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"市场经济","slug":"市场经济","permalink":"http://example.com/tags/%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E/"},{"name":"定价方法","slug":"定价方法","permalink":"http://example.com/tags/%E5%AE%9A%E4%BB%B7%E6%96%B9%E6%B3%95/"}]},{"title":"最优化问题","slug":"最优化问题","date":"2022-11-21T01:05:25.000Z","updated":"2022-11-27T03:06:05.184Z","comments":true,"path":"posts/31098.html","link":"","permalink":"http://example.com/posts/31098.html","excerpt":"","text":"最优化问题定义：在给定的约束条件下，选择最优的参数和方案，使得目标函数最大化&#x2F;最小化的问题 分类： 根据约束条件不同，分为 无约束问题 约束最优问题 等式约束最优问题 不等式约束最优问题 混合约束优化问题 根据目标函数的状态，分为 连续最优化问题：决策变量取值连续 光滑最优化问题：函数连续可微 线性规划 非线性规划 非光滑优化 离散最优化问题：决策标量取值离散 整数规划、资源配置、油路问题生产安排等","categories":[],"tags":[{"name":"最优化问题","slug":"最优化问题","permalink":"http://example.com/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"}]},{"title":"Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks","slug":"Coding based Distributed Data Shuffling for Low Communication Cost in Data","date":"2022-07-24T04:00:00.000Z","updated":"2022-11-27T03:06:05.169Z","comments":true,"path":"posts/40422.html","link":"","permalink":"http://example.com/posts/40422.html","excerpt":"","text":"Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌背景分布式机器学习框架在实际使用中依然存在许多挑战与问题，训练数据样本分布和训练数据样本输入顺序是影响机器学习模型收敛效果的重要因素。全局数据重排能够为分布式机器学习提供更接近于单机的机器学习的数据重排效果。然而其会带来巨大的网络开销 为了让全局数据重排能够应用到实际的分布式机器学习中，目前存在一些使用编码的方法来降低其网络资源开销。 但目前的基于编码的网络传输优化方法都假设存在一台拥有无限存储能力的机器存储了整个训练样本集中的所有样本，并且由这台机器负责所有样本数据的发送工作，而其他机器不具备发送数据的功能。 系统模型和问题制定 基于上述模型优化 方法制定Distributed Coded Shuffling（DCS算法）","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"http://example.com/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"http://example.com/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"}],"author":"kong"},{"title":"摩斯电码快速记忆","slug":"摩斯电码快速记忆","date":"2022-07-24T04:00:00.000Z","updated":"2022-11-27T03:06:05.183Z","comments":true,"path":"posts/58667.html","link":"","permalink":"http://example.com/posts/58667.html","excerpt":"","text":"摩斯电码快速记忆之前无聊的时候翻知乎，看到一个有关摩斯电码的讨论，感觉其中一个回答对记忆莫斯电码十分有帮助，在这里分享下 原电码表 通过图像记忆 有那么两天我甚至感觉自己精通了，勤加练习不难","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"摩斯电码","slug":"摩斯电码","permalink":"http://example.com/tags/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81/"}]},{"title":"Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments","slug":"Partitioning Stateful Data Stream Applications in","date":"2022-07-22T04:00:00.000Z","updated":"2022-11-27T03:06:05.176Z","comments":true,"path":"posts/37834.html","link":"","permalink":"http://example.com/posts/37834.html","excerpt":"","text":"Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments动态边缘云环境下的有状态数据流应用的划分摘要计算分区是一种通过选择性地将一些计算从移动设备卸载到附近的边缘云来提高应用程序性能的重要技术。在动态环境中，边缘云的网络带宽可能会频繁变化，计算的划分需要相应地更新。分区的频繁更新导致了移动端和边缘云之间的高状态迁移成本。但是，现有的工作没有考虑状态迁移开销。因此，分区决策可能会导致重大的拥塞控制，并极大地增加整体完成时间。本文在考虑状态迁移开销的基础上，提出了一套基于网络带宽变化的分区更新算法。据我们所知，这是第一个针对动态环境中的有状态数据流应用程序进行计算分区的工作。这些算法旨在通过在动态边缘云环境中选择性迁移状态来减轻拥塞控制和最小化制造跨度。大量的仿真结果表明，该算法不仅可以选择性地迁移状态，而且在生成时间方面优于其他经典的基准算法。所提出的模型和算法将丰富有状态任务的调度理论，这是以前从未有过的研究。 介绍边缘计算是使云计算技术能够从传统的互联网数据中心到网络边缘进行低延迟数据访问和实时数据处理[7]。作为边缘计算资源的抽象，边缘云通常分布在离终端用户较近的地方，如蜂窝基站和无线局域网。边缘计算的一般形式包括 Cloudlets [9]和 Foglets [10] ，甚至还有一小群有限的设备[8]。与传统的云数据中心相比，边缘云更轻量级，资源受限[11]。随着边缘云在当今网络基础设施中的部署越来越多，计算分区被认为是一种有效的技术，通过选择性地将一些计算从移动设备卸载到附近的边缘云[4][12][18]来提高移动应用程序的性能 为了达到不同的目的，在计算分区方面存在许多相关的工作，比如减少执行时间，节省终端设备的能源消耗，以及云的数据传输开销。这些工作对应用程序有不同的建模方法。典型的应用程序模型包括面向过程程序的方法调用树、面向服务应用程序的服务调用图和面向数据流应用程序的数据流图。&#x2F;n在这些类型的应用程序中，数据流应用程序越来越受到关注，例如扩增实境和目标跟踪。应用程序由一组功能模块组成，数据流通过这些模块。数据流应用程序的分区旨在为每个传入的数据帧决定哪些函数在本地执行，哪些函数在边缘云中执行[4][12]。但是，现有的工作不考虑有状态数据流应用程序的分区。如果数据流应用程序包含有状态函数模块，我们将其定义为有状态应用程序。通过状态函数模块，如果一个数据帧流经它，那么在处理该模块的设备上将留下一个“足迹”。这个“内存占用”(也由状态命名)是下一个数据帧的处理所需要的。许多应用程序(如对象跟踪)都属于有状态应用程序。 对有状态数据流应用程序进行分区非常具有挑战性，尤其是在动态边缘云环境中，在这种环境中，到边缘云的网络连接经常发生变化，甚至可能发生断开连接。由于网络连接的动态性，应用程序的划分需要相应地更新，这将导致移动设备和边缘云之间的状态迁移。因此，我们需要通过选择性迁移状态来划分计算，以减轻网络拥塞。现有的计算划分工作考虑了应用程序的无状态功能模块。当它们应用于有状态应用程序的分区时，网络中会出现较高的状态迁移开销，这可能导致拥塞控制和应用程序的长时间完成。这就是为什么我们需要为有状态应用程序的分区特别设计新的方法，旨在平衡良好的分区和低完成时间以及网络上额外的状态迁移时间。 在本文中，我们开发了一套有效的算法来解决有状态数据流应用程序的划分问题，目的是通过选择性迁移 ing 状态来减少拥塞控制和最小化使用时间。特别地，我们设计了一种新的算法，即基于得分矩阵的启发式算法(SM-H)来解决一次性问题，该算法在边缘网络环境改变时更新当前到达数据帧的划分。SM-H 采用矩阵形式记录调整各模块执行位置的效益得分，然后始终选择得分最大的模块进行调整。调整是迭代进行的，直到没有一个模块得到正分，这意味着调整任何一个模块将导致完成时间的增加。在一次性 SM-H 算法的基础上，进一步推广到解决多步骤的分区问题。 我们通过大量的仿真对提出的算法进行评估，并将它们与几种基准方法进行比较，包括顺序调整(一种幼稚的贪婪启发式方法)、列表调度(一种经典的并行和分布式计算调度方法)、遗传算法等。结果表明，所提出的算法在制作跨度方面优于基准算法。我们将本文的贡献总结如下。 •据我们所知，我们是第一个研究有状态数据流应用程序分区问题的人。这些问题模型可以推广到分布式处理器上的有状态任务调度，这是目前在任务调度领域尚未研究的问题。&#x2F;n •我们开发了一种新算法来划分有状态数据流应用程序。该算法丰富了有状态应用任务的调度理论和方法。&#x2F;n •我们通过广泛的仿真对提出的算法进行了评估，结果表明，提出的 SM-H 算法在制作跨度方面优于基准算法。 系统模型和问题制定定义决策变量表示分配给状态迁移、网络传输的网络带宽，将最小化make-span制定为目标并表示，限制模块之间的依赖性定义，从而定义对状态迁移的限制、对网络带宽的限制 最终形成有状态的数据流应用程序计算分区问题(SCPP)，","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"http://example.com/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"http://example.com/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"}],"author":"kong"},{"title":"基于博弈论的云/边缘计算资源分配与优化算法及应用","slug":"论文阅读","date":"2022-07-22T04:00:00.000Z","updated":"2022-11-27T03:06:05.189Z","comments":true,"path":"posts/23505.html","link":"","permalink":"http://example.com/posts/23505.html","excerpt":"","text":"基于博弈论的云&#x2F;边缘计算资源分配与优化算法及应用 作者：胡俊艳 湖南大学 博士毕业论文 论文创新点 基于非合作博弈的多属性云计算资源竞价算法 时间约束感知的云计算资源联合采购博弈论方法 基于博弈论的边缘计算任务卸载算法 背景用户在意的是QoS，最小成本和最大收益问题，比如响应时间、可靠性、任务的完成时间、资源定价等， 云提供商的主要效益 需要考虑节约能耗、负载均衡等因素，这对减小开销、合理配置资源、提高资源利用率和服务质量有重要意义 无论是云环境还是边环境，都存在资源配置和资源优化问题、尽最大努力改善用户的服务质量和用户体验，降低系统的运行成本问题。因此本文采用了博弈论方法来研究在云&#x2F;边环境下的计算资源的分配优化配置方法 由于文章其他内容与我的研究点“算力网络的多方利益均衡”不同，所以没做记录 基于非合作博弈的多属性云计算资源竞价算法主要贡献针对云计算中多属性资源供应问题，提出一种基于非合作博弈关于云用户和提供商组成的利润最大化的价格竞价算法，提出一种新颖的关于服务质量和竞价的激励性资源购买模型。 然后结合用户的资源购买模型，将提供商的价格竞价问题转化为一个博弈模型来为每个云提供商找到合适的价格。 通过假设每个提供商提供的资源的数量函数是连续的，证明了针对已制定的博弈模型的纳什均衡解集的存在。 为了找到纳什均衡解，提出了一种均衡迭代算法，该算法被证明可以收敛到纳什均衡。 最后提出了一种近均衡价格竞价算法，对获得的纳什均衡解进行修正 多属性云资源价格竞价系统模型云资源供应的参与者将多用户和多提供商的情况并行化为一个用户和多个提供商的情况 3个CPs（提供商）构成一个资源组，2的3次方个方案（这里的方案只是确定CPi是否提供资源，具体提供多少未知） 云用户对多属性云资源的评估用户的属性偏好 其中 用户的资源属性偏好 云用户的云资源购买机制 文章题目：移动边缘计算中基于博弈论的资源分配技术研究算法 基于不完全合同的资源所有权分配算法设计 有关不同所有权分配下的最优投资，最大化运营商部门效用函数（针对运营商） 基于匹配理论的基站资源分配算法设计 添加考虑基站，将基站作为边缘节点，优化系统整体资源分配效益，用户希望选择损失最小的基站（基站分为欠载基站、满载基站、过载基站）。考虑了小基站网络中用户到基站的任务迁移以及基站共同协作处理任务量的模型 基于联合博弈的动态资源分配算法设计 针对边缘计算节点的租用（基于匹配理论）以及计算服务提供商与用户之间的节点拍卖问题（拍卖理论与强化学习理论结合） 网络模型 文章题目：基于任务特性的公有云资源交易机制算法 缓解资源需求峰值的任务调度策略和计价机制 综述 MEC中的资源分配问题主要有： 通信资源分配，根据无线系统环境，高效地分配通信资源，优化传输效率，降低用户间的干扰； 计算资源分配，根据用户的任务需求，有效地分配计算资源，最小化任务时延和能耗，提高卸载效率； 存储资源分配，根据用户的存储需求，分配对应的存储资源，避免用户存储空间不足引发的设备卡顿，提升用户 QoE。 当前对 MEC 资源分配方法的研究大致从两个方面进行：技术层面和经济层面 技术：计算卸载 经济：而经济层面不仅需要考虑如何分配资源，更需要考虑市场竞争性。用户不仅需要评估资源出价，更需要考虑向哪个服务器购买资源，以使自身效益最大化。因此，经济层面的资源分配问题计算复杂度大，综合管理更加复杂。对此，研究者一般采用&#x3D;&#x3D;动态分布式算法、拍卖、博弈&#x3D;&#x3D;等经济分析方法求解","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"http://example.com/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"http://example.com/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"}],"author":"kong"},{"title":"git merge与git pull的区别","slug":"git merge与git pull的区别","date":"2022-07-18T04:00:00.000Z","updated":"2022-11-27T03:06:05.177Z","comments":true,"path":"posts/23828.html","link":"","permalink":"http://example.com/posts/23828.html","excerpt":"","text":"使用GitHubPages+jekyll搭建博客平台git merge与git pull的区别前言最近做项目的时候使用git，遇到一个情形： 在本地自己的分支开发的时候，主分支合并了其他人的工作，此时需要将主分支的代码合并过来，一直使用的是git pull origin main命令，如果有他人合并的工作与我本地工作有冲突，需要自己处理对应冲突 今天偶然看到其他的做法是git pull origin main main，然后git merge main mybranch，发现这也是种实现方式 于是乎开始查这两种做法的区别 git pull直接将origin的分支与本地当前分支合并，会将过程都隐藏起来， 遇到冲突解决 git fetch+ git mergegit fetch origin main 将远程仓库中的最新代码拉回， git merge origin&#x2F;main 把本地代码和已取得的main代码合并 遇到冲突去解决 对比网上很多文章都推荐使用fetch+merge，因为pull会直接更改你的工作，你不了解具体更改了什么 但如果使用了IDE，现在的IDE都集成了冲突处理功能，所以我觉着使用pull也问题不大","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"merge","slug":"merge","permalink":"http://example.com/tags/merge/"},{"name":"pull","slug":"pull","permalink":"http://example.com/tags/pull/"}],"author":"kong"},{"title":"JDBC学习笔记","slug":"JDBC","date":"2022-05-25T04:00:00.000Z","updated":"2022-11-27T03:06:05.175Z","comments":true,"path":"posts/60381.html","link":"","permalink":"http://example.com/posts/60381.html","excerpt":"","text":"JDBC技术体系 一、概述 JDBC由java官方定义的一组标准：接口；对应各个数据库厂商实现对应的方法即驱动 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 在使用JDBC情况下访问数据库 JDBC程序编写步骤 二、获取数据库连接 方式一到五，1-4作为过程存在，了解即可 方式五 &#96;&#96;&#96;java&#x2F;** * 获取数据库连接 * @return * @throws Exception *&#x2F;public static Connection getConnection() throws Exception {&#x2F;&#x2F; 读取配置文件信息 InputStream ips &#x3D; ClassLoader.getSystemClassLoader().getResourceAsStream(“jdbc.properties”); Properties pros&#x3D;new Properties(); pros.load(ips); String user &#x3D; pros.getProperty(“user”); String password &#x3D; pros.getProperty(“password”); String url &#x3D; pros.getProperty(“url”); String driverClass &#x3D; pros.getProperty(“driverClass”);&#x2F;&#x2F; 2.加载驱动 Class.forName(driverClass);&#x2F;&#x2F; 3.连接 Connection conn &#x3D; DriverManager.getConnection(url, user, password); System.out.println(conn); return conn;}123456789- 配置文件jdbc.properties存放在src下 - ```xml user=root password=123456 url=jdbc:mysql://localhost:3306/test?serverTimezone=GMT driverClass=com.mysql.cj.jdbc.Driver 三、JDBCUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package utils;/** * * 操作数据库的工具类 * */public class JDBCUtils &#123; /** * 获取数据库连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123;// 读取配置文件信息 InputStream ips = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros=new Properties(); pros.load(ips); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;);// 2.加载驱动 Class.forName(driverClass);// 3.连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); return conn; &#125; /** * 关闭连接和statement操作 * @param conn * @param ps */ public static void closeResource(Connection conn, Statement ps)&#123; // 资源关闭 try &#123; if(ps!=null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void closeResource(Connection conn, Statement ps, ResultSet rs)&#123; // 资源关闭 try &#123; if(ps!=null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(rs!=null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;// 使用dbutils提供的close关闭数据库资源 public static void closeResource1(Connection conn, Statement ps, ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs); &#125;&#125; 四、使用preparedStatement实现CRUD4.1 使用statement的问题 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 无法操作Blob类型数据 实现批量插入时，效率较低 4.2 使用preparestatement 介绍 是statement的子接口 使用预编译sql语句 可以解决sql注入问题，实现高效的批量操作 通用增删改操作（V1.0） &#96;&#96;&#96;javapublic void update(String sql,Object …args) { Connection conn &#x3D; null; PreparedStatement ps &#x3D; null; try {&#x2F;&#x2F; 占位符的个数等于可变形参的个数 conn &#x3D; JDBCUtils.getConnection(); ps &#x3D; conn.prepareStatement(sql); for(int i&#x3D;0;i&lt;args.length;i++){ ps.setObject(i+1,args[i]); }&#x2F;&#x2F; 方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false&#x2F;&#x2F; ps.execute();&#x2F;&#x2F; 方式二： ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); }}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 - 通用查询操作（V1.0） - ```java /** * *@author Kong *@Description 针对不同表的通用查询操作，返回表中的一组记录 *@Date 22:12 2022/5/19 *@Param *@Return **/ public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz, String sql, Object ...args)&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; public &lt;T&gt;T getForInstance(Class&lt;T&gt; clazz,String sql,Object ...args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); if(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 过程图示 查询操作的流程 五、操作Blob类型的变量 具体的insert &#96;&#96;&#96;java&#x2F;****@author Kong*@Description 向数据表中插入blob信息*@Date 13:59 2022&#x2F;5&#x2F;20*@Param*@Return**&#x2F;@Testpublic void testInsert() throws Exception { Connection conn &#x3D; JDBCUtils.getConnection(); String sql &#x3D; “insert into customers(name,email,birth,photo) values(?,?,?,?)”; PreparedStatement ps &#x3D; conn.prepareStatement(sql); ps.setObject(1, “孙悟空”); ps.setObject(2, “&#x73;&#117;&#x6e;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;“); ps.setObject(3, “500-01-01”); FileInputStream is &#x3D; new FileInputStream(new File(“src&#x2F;sun.jpg”)); ps.setBlob(4, is); ps.execute(); JDBCUtils.closeResource(conn,ps);}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- 具体的查询 - ```java /** * *@author Kong *@Description 从数据表中查询blob信息 *@Date 14:00 2022/5/20 *@Param *@Return **/ @Test public void testQuery() throws Exception &#123; Connection conn = null; PreparedStatement ps = null; InputStream is=null; FileOutputStream fos=null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth,photo from customers where id =?&quot; ; ps = conn.prepareStatement(sql); ps.setObject(1, 20); ResultSet rs = ps.executeQuery(); if(rs.next())&#123; // 方式一 // int id = rs.getInt(1); // String name = rs.getString(2); // String email = rs.getString(3); // Date birth = rs.getDate(4); // 方式二：更易读，不易出错 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); Customer customer = new Customer(id, name, email, birth); System.out.println(customer); // 将文件下载到本地 Blob photo = rs.getBlob(&quot;photo&quot;); is = photo.getBinaryStream(); fos = new FileOutputStream(&quot;wukong.jpg&quot;); byte[] bytes = new byte[1024]; int len; while((len=is.read(bytes))!=-1)&#123; fos.write(bytes,0,len); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps); is.close(); fos.close(); &#125; &#125; 六、批量插入 层次一：使用statement实现 层次二：使用preparestatement实现 层次三： 修改1： 使用 addBatch() &#x2F; executeBatch() &#x2F; clearBatch() 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。?rewriteBatchedStatements&#x3D;true 写在配置文件的url后面 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar 层次四： 在层次三的基础上操作使用Connection 的 setAutoCommit(false) &#x2F; commit() 最终代码 12345678910111213141516171819202122232425262728293031323334// 方式四 :设置不允许自动提交数据 @Test public void testInsert3() &#123; Connection conn = null; PreparedStatement ps = null; try &#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection();// 设置不自动提交数据 conn.setAutoCommit(false); String sql = &quot;insert into goods(name) values(?)&quot;; ps = conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++)&#123; ps.setObject(1,&quot;name_&quot;+i);// 攒batch ps.addBatch(); if(i%500==0)&#123;// 执行batch ps.executeBatch();// 清空batch ps.clearBatch(); &#125; &#125;// 提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;时间为：&quot;+(end-start)); //13174 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,ps); &#125; &#125; 面试题：Preparestatement和statement的异同 接口与子接口的关系 开发中多数使用前者 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 七、事务事务简介 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）的原则：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 避免数据自动提交 执行DML语句会自动提交 设置autocommit无效 执行DDL语句也会自动提交 需要设置autocommit为false 数据库连接关闭也会自动提交 事物的ACID属性 多数的只解决了脏读问题就解决了 mysql支持四种隔离级别，Oracle只支持两种 一般情况保证 read commit就可以 代码体现 &#96;&#96;&#96;java@Testpublic void testUpdateTx() { Connection conn &#x3D; null; try { conn &#x3D; JDBCUtils.getConnection();&#x2F;&#x2F; 取消自动提交 conn.setAutoCommit(false); String sql1&#x3D;”update user_table set balance&#x3D;balance-100 where user&#x3D;?”; update(conn,sql1,”AA”);&#x2F;&#x2F; 模拟错误&#x2F;&#x2F; System.out.println(1&#x2F;0); String sql2=&quot;update user_table set balance=balance+100 where user=?&quot;; update(conn,sql2,&quot;BB&quot;); System.out.println(&quot;成功&quot;); conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; conn.rollback(); &#125; catch (SQLException ex) &#123; e.printStackTrace(); &#125; &#125; finally &#123; &#x2F;&#x2F; 恢复默认值，在设置数据库连接池时使用 try { conn.setAutoCommit(true); } catch (SQLException e) { e.printStackTrace(); } JDBCUtils.closeResource(conn,null); }} 12345678910111213141516171819202122232425- 使用事务后的增删改（V2.0） - ```java // 通用的增删改操作 v2.0（考虑到事务） public int update(Connection conn,String sql,Object ...args) &#123; PreparedStatement ps = null; try &#123; // 占位符的个数等于可变形参的个数 ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; // 方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false // ps.execute(); // 方式二： return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps); &#125; return 0; &#125; 使用事务后的查询（V2.0） 略 事物的四大属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 四种隔离级别（隔离性越好，并发性越差） 查看并设置隔离级别 八、DAOBaseDAO.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package dao2;/** * 功能描述 通用的数据库操作 * * @author Kong * @date 2022/05/23 14:17 */public abstract class BaseDAO&lt;T&gt; &#123; private Class&lt;T&gt; clazz=null; &#123;//此处为子类调用，正常声明在子类更好理解，但是为了避免新添加类就要重复写这段代码，所以放在父类中，在调用时，比如customerDAO类调用，此处的this指的是customerDAO类的对象// 获取当前BaseDAO的子类继承的父类（即为BaseDAO）的泛型 Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType paramType= (ParameterizedType) genericSuperclass; Type[] types = paramType.getActualTypeArguments();//获取父类的泛型 clazz = (Class&lt;T&gt;) types[0];//泛型的第一个参数 &#125; // 通用的增删改操作 v2.0（考虑到事务） public int update(Connection conn, String sql, Object ...args) &#123; PreparedStatement ps = null; try &#123;// 占位符的个数等于可变形参的个数 ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125;// 方式一：如果执行的查询操作又返回结果，此方法返回true；执行增删改，无返回结果，返回false// ps.execute();// 方式二： return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps); &#125; return 0; &#125; /** * *@author Kong *@Description 针对不同表的通用查询操作，返回表中的一条记录 *@Date 22:06 2022/5/19 *@Param *@Return **/ public T getForInstance(Connection conn,String sql,Object ...args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); if(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125; /** * *@author Kong *@Description 针对不同表的通用查询操作，返回表中的一组记录 *@Date 22:12 2022/5/19 *@Param *@Return **/ public List&lt;T&gt; getForList(Connection conn, String sql, Object ...args)&#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next())&#123; T t = clazz.newInstance(); for(int i=0;i&lt;columnCount;i++)&#123; Object value = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;// 查找特殊值的方法 public &lt;E&gt;E getValue(Connection conn,String sql,Object ...args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; rs = ps.executeQuery(); if(rs.next())&#123; return (E) rs.getObject(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;&#125; CustomerDAO12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package dao2;/** * 功能描述 * * @author Kong * @date 2022/05/23 14:35 */public interface CustomerDAO &#123; /** * *@author Kong *@Description 插入指定数据 *@Date 14:35 2022/5/23 *@Param *@Return **/ void insert(Connection conn, Customer cust); /** * *@author Kong *@Description 更新用户数据 *@Date 14:36 2022/5/23 *@Param *@Return **/ void update(Connection conn,Customer cust); /** * *@author Kong *@Description 根据id删除指定用户 *@Date 14:37 2022/5/23 *@Param *@Return **/ void deleteById(Connection conn,int id); /** * *@author Kong *@Description 根据ID获得对应的customer对象 *@Date 14:38 2022/5/23 *@Param *@Return **/ Customer getCustomerById(Connection conn,int id); /** * *@author Kong *@Description 获取所有记录构成的记录 *@Date 14:40 2022/5/23 *@Param *@Return **/ List&lt;Customer&gt; getAll(Connection conn); /** * *@author Kong *@Description 返回数据表中数据的条目数量 *@Date 14:42 2022/5/23 *@Param *@Return **/ long getCount(Connection conn); /** * *@author Kong *@Description 获取数据库表中最大的生日 *@Date 14:43 2022/5/23 *@Param *@Return **/ Date getMaxBirth(Connection conn);&#125; CuscomerDAOImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package dao2;/** * 功能描述 * * @author Kong * @date 2022/05/23 14:45 */public class CustomerDAOImpl extends BaseDAO&lt;Customer&gt; implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth) values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getId()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id = ?&quot;; update(conn,sql,id); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id =?&quot;; Customer customer = getForInstance(conn, sql, id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list = getForList(conn, sql); return list; &#125; @Override public long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn, sql); &#125;&#125; 小结 九、数据库连接池必要性 几种连接池 数据库连接池技术的优点1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 几种连接池的使用十、dbutils的使用","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}],"author":"kong"},{"title":"5.22leetcode周赛","slug":"leetcode周赛","date":"2022-05-22T04:00:00.000Z","updated":"2022-11-27T03:06:05.178Z","comments":true,"path":"posts/42691.html","link":"","permalink":"http://example.com/posts/42691.html","excerpt":"","text":"5.22leetcode周赛 第一次参加这个周赛，很菜，过了两个题，稍微复盘一下 题目一：6074. 字母在字符串中的百分比难度简单0收藏分享切换为英文接收动态反馈 给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。 示例 1： 1234输入：s = &quot;foobar&quot;, letter = &quot;o&quot;输出：33解释：等于字母 &#x27;o&#x27; 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。 示例 2： 1234输入：s = &quot;jjjj&quot;, letter = &quot;k&quot;输出：0解释：等于字母 &#x27;k&#x27; 的字符在 s 中占到的百分比是 0% ，所以返回 0 。 提示： 1 &lt;= s.length &lt;= 100 s 由小写英文字母组成 letter 是一个小写英文字母 解答 这道题是签到题，但是因为有关浮点数精度相关信息忘了，最开始使用float存储的，导致有测试用例不通过，浪费了十多分钟，还被罚时了10分钟 代码 123456789101112131415class Solution &#123; public int percentageLetter(String s, char letter) &#123; int count=0; //计算字符出现的次数 for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==letter)&#123; count++; &#125; &#125; //题目给出s的length最大100，所以使用double不会损失精度，但float不可以，测试用例(float)59/100=58 double res=(double)count/s.length(); return (int)(res*100); &#125;&#125; 题目二：6075. 装满石头的背包的最大数量现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。 请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。 示例 1： 123456789输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2输出：3解释：1 块石头放入背包 0 ，1 块石头放入背包 1 。每个背包中的石头总数是 [2,3,4,4] 。背包 0 、背包 1 和 背包 2 都装满石头。总计 3 个背包装满石头，所以返回 3 。可以证明不存在超过 3 个背包装满石头的情况。注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 示例 2： 123456789输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100输出：3解释：8 块石头放入背包 0 ，2 块石头放入背包 2 。每个背包中的石头总数是 [10,2,2] 。背包 0 、背包 1 和背包 2 都装满石头。总计 3 个背包装满石头，所以返回 3 。可以证明不存在超过 3 个背包装满石头的情况。注意，不必用完所有的额外石头。 提示： n == capacity.length == rocks.length 1 &lt;= n &lt;= 5 * 104 1 &lt;= capacity[i] &lt;= 109 0 &lt;= rocks[i] &lt;= capacity[i] 1 &lt;= additionalRocks &lt;= 109 代码 时空O(n)O(n) 123456789101112131415161718192021222324252627282930class Solution &#123; public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) &#123; int len=capacity.length; int []tmp=new int [len]; //计算每个背包的剩余空间 for(int i=0;i&lt;len;i++)&#123; tmp[i]=capacity[i]-rocks[i]; &#125; //按照剩余空间大小排序 Arrays.sort(tmp); int res=0; for(int i=0;i&lt;len;i++)&#123; //如果空间为0，则满，直接增加 if(tmp[i]==0)&#123; res++; continue; &#125; //剩余空间小于额外的石子数 if(tmp[i]&lt;=additionalRocks)&#123; additionalRocks-=tmp[i]; res++; &#125; //剩余空间大于额外石子数，不满条件，直接结束循环 else&#123; break; &#125; &#125; return res; &#125;&#125; 题目三：6076. 表示一个折线图的最少线段数给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子： 请你返回要表示一个折线图所需要的 最少线段数 。 示例 1： 123456789输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]输出：3解释：上图为输入对应的图，横坐标表示日期，纵坐标表示价格。以下 3 个线段可以表示折线图：- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。可以证明，无法用少于 3 条线段表示这个折线图。 示例 2： 1234输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]输出：1解释：如上图所示，折线图可以用一条线段表示。 提示： 1 &lt;= stockPrices.length &lt;= 105 stockPrices[i].length == 2 1 &lt;= dayi, pricei &lt;= 109 所有 dayi 互不相同 。 解答这道题是没有AC的，卡在了一个隐藏测试用例上，没想到还是因为精度问题，这次我虽然用的是double类型，但是测试用例给到了10的10次方，导致精度丢失，WA 这里判断三个点在不在同一条直线上不能使用斜率判断，需要使用直线方程的一般式判断 在这里我们只需要用到直线方程的部分性质直线方程的一般式为：ax+by+c&#x3D;0在平面直角坐标系中，我们知道任意两个点的坐标就可求出经过这两个点的直线方程可得： 1234a=y2-y1b=x1-x2//注意别写反了c=-(ax1+by1) 显然只需要代入其他点判断是否满足一般式即可 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minimumLines(int[][] stockPrices) &#123; if(stockPrices.length==1)return 0; if(stockPrices.length==2)return 1; int len=stockPrices.length; HashMap&lt;Integer,Integer&gt; hashmap=new HashMap(); int []tmpStock=new int[len]; for(int i=0;i&lt;len;i++)&#123; hashmap.put(stockPrices[i][0],stockPrices[i][1]); tmpStock[i]=stockPrices[i][0]; &#125; Arrays.sort(tmpStock);// 排序后的二维数组 int[][] stockPricesSort=stockPrices; for(int i=0;i&lt;len;i++)&#123; stockPricesSort[i][0]=tmpStock[i]; stockPricesSort[i][1]=hashmap.get(tmpStock[i]); &#125; int res=1; int a=stockPricesSort[1][1]-stockPricesSort[0][1];//y2-y1 int b=stockPricesSort[0][0]-stockPricesSort[1][0];//x1-x2 int c=-(a*stockPricesSort[0][0]+b*stockPricesSort[0][1]);//-(ax1+by1) for(int i=2;i&lt;len;i++)&#123; if(a*stockPricesSort[i][0]+b*stockPricesSort[i][1]+c!=0)&#123; res++; a=stockPricesSort[i][1]-stockPricesSort[i-1][1]; b=stockPricesSort[i-1][0]-stockPricesSort[i][0]; c=-(a*stockPricesSort[i-1][0]+b*stockPricesSort[i-1][1]); &#125; &#125;// 使用浮点数精度会丢失// double k=(double)(stockPricesSort[1][1]-stockPricesSort[0][1])/(stockPricesSort[1][0]-stockPricesSort[0][0]);// for(int i=2;i&lt;len;i++)&#123;// double tmp=(double)(stockPricesSort[i][1]-stockPricesSort[i-1][1])/(stockPricesSort[i][0]-stockPricesSort[i-1][0]);// if(tmp!=k)&#123;// res++;// k=tmp;// &#125;// &#125; return res; &#125;&#125; 第四题：尝试解答，直接超时参考链接(5条消息) 判断几个点是否在同一条直线上（计算几何）_bbbblzy的博客-CSDN博客_判断两点在一条直线上","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"},{"name":"浮点数精度","slug":"浮点数精度","permalink":"http://example.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"}],"author":"kong"},{"title":"使用GitHubPages+jekyll搭建博客平台","slug":"GitHubPages+jekyll","date":"2022-05-18T04:00:00.000Z","updated":"2022-11-27T03:06:05.172Z","comments":true,"path":"posts/61277.html","link":"","permalink":"http://example.com/posts/61277.html","excerpt":"","text":"使用GitHubPages+jekyll搭建博客平台遇到问题 cannot load such file – webrick (LoadError) (4条消息) jekyll 安装遇到的问题（cannot load such file – webrick (LoadError)）_阿gua的博客-CSDN博客 参考文章可能是最全面的github pages搭建个人博客教程 - 云+社区 - 腾讯云 (tencent.com) (4条消息) 使用github pages+Jekyll模板搭建博客（网页小白）_Yan_wd的博客-CSDN博客_github pages模板","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"githubpags","slug":"githubpags","permalink":"http://example.com/tags/githubpags/"},{"name":"jekyll","slug":"jekyll","permalink":"http://example.com/tags/jekyll/"}],"author":"kong"},{"title":"使用typora+github实现图床","slug":"typora+github实现图床","date":"2021-10-18T04:00:00.000Z","updated":"2022-11-27T03:06:05.182Z","comments":true,"path":"posts/20962.html","link":"","permalink":"http://example.com/posts/20962.html","excerpt":"","text":"使用typora+github实现图床[TOC] 需求 在使用typora的时候，有时需要放图片，但截图之类的只能保存在本地，如果换了电脑或者将正篇文档给别人，就无法打开，因此使用图床，方便使用typora 解决方式下载PicGo-Core首先保证有nodejs环境 然后安装picgo 1npm install picgo -g 安装后查看版本，检查是否安装成功 1picgo -v 安装github-plus官方给的github上传不好用，安装github-plus 1picgo install github-plus Typora设置 使用typora的PicGo-Core（不需要下载APP）+ github实现 github上创建一个仓库，填写readme，拿到对应的拥有仓库读写权限的token typora上打开偏好设置，图像栏选择如下图 修改picgo配置打开配置文件更改 &#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;githubPlus&quot;, &quot;current&quot;: &quot;githubPlus&quot;, &quot;githubPlus&quot;: &#123; &quot;branch&quot;: &quot;master&quot;, // 仓库的分支 &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest&quot;, // 访问的自定义url &quot;origin&quot;: &quot;github&quot;, // 存放的图片类型 &quot;repo&quot;: &quot;Kong-PR/Typora-picture&quot;, // 存放图片的仓库 &quot;path&quot;: &quot;img&quot;, // 仓库中存放图片的文件夹，也可以不填 &quot;token&quot;: &quot;&quot; // 访问github的仓库的token，就是一开始生成的 &#125; &#125;, &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-github-plus&quot;: true//启动github-plus插件 &#125;, &quot;picgo-plugin-github-plus&quot;: &#123; &quot;lastSync&quot;: &quot;2021-10-03 02:44:04&quot; &#125; &#125; 对应的插件一栏是在PicGo-Core的安装目录下安装的,有的没用上 picgo install smms-user picgo install gitee-uploader picgo install github-plus 上面的 customUrl，在这里我是使用了 jsdeliver cdn 进行加速访问.比正常要上传快很多 token填写github的对应token 然后就可以使用了,图片放上去就自动上传了 有一个疑问 在我github账户改名后，我仍然可以通过原用户名访问，这是什么原因呢 参考 [使用jsdelivr + GitHub + PicGo搭建免费图床 - 啸歌 - 博客园 (cnblogs.com)](https://www.cnblogs.com/SeanYoung/p/13407250.html#:~:text=由于GitHub国内访问速度慢，所以可以考虑使用CDN优化加速进行访问，这里选择免费的jsdeliver进行CDN优化。 jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。 包含,JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。) Typora + PicGo-Core + Github 实现图片上传到Github - 码农教程 (manongjc.com)","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"typora","slug":"typora","permalink":"http://example.com/tags/typora/"}],"author":"kong"},{"title":"鸟哥linux私房菜琐碎知识点","slug":"鸟哥linux私房菜琐碎知识点整理","date":"2021-10-08T04:00:00.000Z","updated":"2022-11-27T03:06:05.234Z","comments":true,"path":"posts/52308.html","link":"","permalink":"http://example.com/posts/52308.html","excerpt":"","text":"鸟哥linux私房菜琐碎知识点 看懂了在整理，这样子整理的才有意义； 切记不要为了整理而整理！！！ 0. 计算机基础知识固态硬盘（solid state disk，ssd）​ 优点：马达不需要转动，所以速度快； ​ 缺点：写入次数限制，所以寿命短； 数据表示方式文字编码系统 每个符号（英文数字或符号）都占用1bytes，所以有2^8^&#x3D;256种变化； 每个汉字占用2bytes，所以用216&#x3D;65536种变化，即可表示6w多个中文字； big5码的中文字编码仅仅定义了一万三千多个中文字，所以有些中文使用big5无法实现； big5中某些字码像是【许、盖、功】等字，由于这几个字的内部编码会误判为单双引号，所以常常出现乱码。（不仅中文字，其他非英语系国家也会有这样的问题出现）。 为解决上面的问题，国际组织ISO&#x2F;IEC制定了所谓的Unicode编码系统，我们常称为utf-8或者万国码。该编码打破了所有国家的不同编码，因此大多用户选择这个编码系统。 软件程序运作机器程序与编译程序机器语言：全部由0和1组成，人类识别起来相当难！ 高级语言：计算机科学家大牛们为了推动人类计算机事业的发展，设计了一种人类能看得懂的语言，然后创造一种【编译程序】来将这些人类写的语言转译成机器能够看懂的机器码。 操作系统本质：也是一组程序，程序的终点在于管理计算机的所有活动以及驱动系统中的所有硬件。 1.linux是什么？、如何学习？是什么 简单定义：操作系统。 历史：主要原因是一些大牛为了完成自己的兴趣主键开发形成的一款操作系统，非常重要的一点是open source。 知识点 GNU&#x3D;GNU‘s Not Unix，:smile:大佬的脑子搞不懂。 GCC&#x3D;GNU Compiler Collection，是linux下的编译器，目前支持C、C++、Java、Objective-C、Fortran、Ada。 GPL&#x3D;GNU General Public License，自由软件的版权。 open source 协议说明 linux发展 重要人物：Linus Torvalds（托瓦兹），早期的Unix系统只提供运算功能，terminal仅负责IO，他想自己搞一个Unix，首先找到了minix。 386硬件的多任务测试：理论上一个CPU在一个时间段内只能处理一个任务，具有多任务能力的CPU可以在不同程序之间切换，eg：一个CPU频率为1GHz，表示他一秒钟可进行10^9^次运算，假设每个程序以1000次作为运作周期，则CPU一秒钟就能切换106次，如此快的运算速度，人为感觉两个程序是同时运行的了。 linux0.02：托瓦兹参考minux的设计理念，写出的操作系统，早期的linux。 linux虚拟团队的发展： 单人维护：最开始托瓦兹将linux核心放置在FTP上，用户下载使用发现问题主动汇给他； 广大黑客加入：托瓦兹总是有解决不了的问题，像是硬件驱动程序的撰写，这是就有人提出可以帮忙写相关程序。托瓦兹的务实态度是linux发展迅速的重要原因。 核心功能逐渐完善：托瓦兹一个人精力有限，所以有一些朋友跳出来帮忙做这些工作，1994年终于完成了linux的核心正式版1.0，94年完成2.0，而这些人其实都没见过面。 linux的核心版本： 奇偶版本分类： 2.6版本以前两股分类： 主次版本为奇数：发展中版本（development）eg：2.5.xx 主次版本为偶数：稳定版本（stable）eg：2.6.xx 主线版本、长期维护版本： 3.0后开始使用 linux核心版本与linux发布商版本 linux核心版本与distribution版本不同 linux核心最新版本4.0.0（2015&#x2F;04）、centos的distribution版本7.x。 linux distributions 出现了诸多版本像是：Red Hat,Ubuntu,Debian等等，但它们使用的核心（kernel）都是官方提供的，各种标准都相同，基本上除了开发商自家开发出的软件外，不同版本的差异并不大。 鸟哥的分类： 使用RPM方式安装软件的系统：Red HAT、Fedora、SUSE等； 使用dpkg方式安装软件的系统：Debian、Ubuntu、B2D等； 鸟哥的选择建议： linux当前的应用角色主要分为企业应用于个人应用，这几年非常流行的云端运算机制中，linux似乎更有着力点。 企业应用 网络服务器：继承了Unix高稳定性的良好传统，linux上面的网络功能非常稳定，又有GNU计划于GPL授权模式，很多优秀的软件都在linux上发展。–15年为止，广泛流传的distribution仍旧是Red Hat和SUSE两个大厂。 关键人物的应用：金融数据库、大型企业网管环境，像是金融业将存储数据的任务交给了linux。 学术机构的高效能运算任务：服务器的CPU可以增加许多，而且linux的创造者本身就是一个性能癖，所以拥有强大的运算能力，加上linux具有支持范围广泛的GCC编译器，因此在这方面的优势相当明显。 个人环境的使用平时接触的电子产品中，好多东西都有linux的存在，没看之前我还真不知道是linux提供的支持。 桌面计算机：在个人使用的计算机下，大多是办公学习之类的，desktop环境最需要的就是窗口，但最开始linux的设计者是一大堆工程师大牛，大牛们对于窗口并不是很需要，所以早期的linux并受众面并不是特别广泛；后来为了强化桌面计算机的使用率，linux与X Window System结合了 X Windows System相当于在linux上运行的软件，就算他挂了，对linux也可能不会有直接的影响呢！ 手持系统：手机、pda；Google推出的Android手机专用操作系统，其实就是linux核心的一支，专门针对手机、平板这类的ARM机器所设计的。 观察了我的手机，Android系统9.0，linux kernel4.9.148 嵌入式系统： 理解：直接嵌入到产品当中的操作系统，理论上用户不会更动这个操作系统，所以叫嵌入式系统。 产品例子：路由器、防火墙、手机、机器人控制芯片、家电用品的微电脑控制器等，都有linux的身影。 不过嵌入式开发需要很熟悉linux kernel与驱动程序的结合才行，我准备在接下来尝试一些学习。 云端使用 分久必合，合久必分：早期贼贵的大型主机分配终端的集中运算，到2010年前个人计算机运算能力增强，大部分运算在桌机或者笔电上进行，到现在人类活动的发达，产生庞大的数据需要集中处理，从而产生云端系统的需求，将信息集中管理。 数据集中在云端，企业员工无时无地都可以办公，不知对于员工来说是喜是忧:smile: 云程序：公司内部私有云、大型因特网供货商等等 端设备：连接上面的云程序，很多时候使用智能手机、平板，连接到某云就可以使用了；还有像是更迷你的端点设备树莓派、香蕉派，网上售价百十块钱的样子。 linux该如何学习 拒绝X Window的环境，因为它只算是一个linux的一个应用，对于某些深入级别的知识学习没有帮助。 站在要让linux成为自己的好用的工具为出发点学习。 从头学起。vi文本编辑器、shell scripts 、软件管理员（安装方式） 讨论地址 http://phorum.study-area.org/ https://phorum.vbird.org/ 好习惯 兴趣、成就感 不同的环境下，解决问题的办法有很多种，只要行得通，就是好办法！ 2.主机规划与磁盘划分linux与硬件搭配1.计算机硬件配备 游戏or工作：一般的三位计算机游戏所需要的3D光影运算很多，显示适配器与CPU资源被耗用的就回很多，所以需要比较高的配置。而工作大多需要的是办公软件，所以多数入门级的极端及都能拍的非常流畅了。 效能与与价格：个人用户似乎不太考虑这个，但是对于一些企业，就不得不考虑用电带来的经济账。 支援度：有些极端及的硬件设计可能不支持某些操作系统，及时自己可以会搞编译程序，也要弄清楚硬件是否支持呐！ 2.linux搭配主机日常个人使用做个小服务器不需要太高的性能，CPU i3的够用，但是做一些重要的功能，还是需要高档一些的计算机配备了。 个人服务器的基本要求： CPU：Intel i3的CPU不算太久，够用。 RAM：主存越大越好，因为如果主存不够用，就会用到硬盘的内存置换空间，而硬盘的速度要比内存速度慢得多，所以主存太小会影响整体系统的性能，如果再加上有X Window的话，主存太小会炸掉；一般的小型服务器，至少也要512MB以上的主存储器。 Hard Disk：硬盘容量取决于个人用途，小型服务器20G基本够用。 VGA：如果你不使用X Window，显示适配器可有可无，如果使用，显示器最好拥有32MB以上的内存。 NetWork InterFace Card：服务器上最重要的组件之一，但没看懂，后面会讲吧。 光盘，软盘、键盘and鼠标：能用就行，做服务器可能多数情况下不怎么用，通过网络管控，类似云服务器。 3.各硬件装置在linux文件夹中的命名 在linux中，每个装置都被当成一个文件夹来对待 使用虚拟机学习 Windows：VMware、VirtualBox linux：KVM 磁盘分区磁盘连接方式与装置文件名的关系正常实体机大概使用的都是&#x2F;dev&#x2F;sd[a-]磁盘文件名，但是在虚拟环境下，为了加速可能就会有&#x2F;dev&#x2F;vd[a-p]这种装置文件名。 我的阿里云服务器，centos7.4，对应的文件名称为&#x2F;dec&#x2F;vda、&#x2F;dev&#x2F;vda1 MSDOS（MBR）与GPT磁盘分区表 MSDOS：早期的linux系统为了兼容Windows的磁盘，使用的是Windows支持的MBR（Master Boot Record，主要开机记录区）的方式处理开机管理程序与分区表。 吧啦吧啦，脑子不够用，看不懂了，总之这里出现了文件名称后面的对应数字。&#x2F;dev&#x2F;sda2 GUID partition table，GPT磁盘分区表 也看不懂，容我歇歇，叫脑子起床 开机流程中的BIOS与UEFI开机检测BIOS搭配MBR&#x2F;GPT的开机流程 BIOS不懂GPT UEFI BIOS搭配GPT 知识点：过去有一些cracker经常有BIOS的开机阶段来破坏系统，取得系统控制权，所以UEFI加入了一个所谓的安全启动（secure boot）机制，代表着即将开机的操作系统必须要被UEFI所验证，否则无法顺利开机，有些时候需要将此功能关闭，才可以进入linux系统。 linux安装的磁盘分区 目录树结构 所有文件都是由根目录衍生来的 文件系统与目录树的关系：挂载 定义：所谓的挂载就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下，即进入高目录就可以读取该分区槽。 当数据在&#x2F;home下的次目录时，对应的数据就是放在partition2的，如果不是在&#x2F;home下的数据，则被放置在partition1。 安装前的规划选择合适的distribution 考虑网络环境的安全性，尽量选择最新的版本。 若linux定位在服务器上，Red Het Enterprise Linux orSUSE Enterprise Linux比较不错，因为版本更动幅度比较小，并且更新支持的期限比较长。 主机的服务规划与硬件的关系打造Windows、Linux双系统 NAT：达成IP分享器的功能 通常像学校单位大多会有一条对外的联机，然后全校的计算机透过这个设备连接到互联网上，此时就得要使用IP分享器让这一条对外联机分享给所有的成员是用；在linux下要想达成此功能，需要透过NAT服务达成。 此时由于网络流量会比较大，网络卡就需要比较好的配备，而CPU、RAM硬盘等的影响力就小很多。 其实，仅利用linux作为NAT主机来分享IP是很不值的，因为PC的耗电能力要比IP分享器大很多。但由于NAT还可以加装更多的分析软件，实现控制带宽、流量等功能。 SAMBA：加入Windows 网上的邻居Windows系统之间传输数据是用过网络邻居来循环数，但Windows 7的芳邻只能同时分享10步客户端联机，超过的话就要等待。 在linux上使用SAMBA软件达成加入Windows网邻的功能，无客户端限制，适合学校的文件服务器角色。 同样，由于分享的数据量较大，网卡与硬盘大小及速度就比较重要。此时可以考虑将&#x2F;home 目录独立出来，并且加大容量。 Windows传输文件通过网络邻居？？？我不太懂哇，大家似乎传输的方式很多呐，不过还真没用过网络邻居。:smile: Mail：邮件服务器 现在免费的邮箱已经很多了，个人使用的邮箱应该不需要建设mail server 了，但是如果你是一家私人企业，一些邮件是有商业机密或隐私性的，就需要mail server 了，重要的硬件需求也是硬盘容量与网卡。此时可以将&#x2F;var 目录独立出来，并且加大容量。 Web：WWW服务器WWW服务器几乎所有网络主机都会安装的一个功能，除了提供Internet的WWW联机，很多在网络主机上面的软件功能，也都使用WWW作为接口；若要提升WWW副武器的性能，通常提升RAM是一个不错的选择。 DHCP：提供客户端自动取得IP的功能 若你是一个局域网络管理员，区域内部有数十个计算机被使用，这些计算机联网时当然是自动分配比较省力，这就是DHCP的功能；这个功能对硬件的需求不是很高了。 FTP FTP软件进行资源分享还是比较普遍的，硬盘容量与网卡质量相当重要。 主机硬盘的主要规划 要考虑到计算机硬件出现问题时，文件数据能否安全保存 鸟哥说：没有装过十次以上的linux，是学不会linux与磁盘分区的:smile: 我有幸装过两三次了 3.安装CentOS7.x 由于我之前安装过Ubuntu1604，加上租的阿里云的Centos7.4的云服务器，这章就不跟着整理了。 4.登入系统登入一般使用非管理员用户登录，因为系统管理员权限太高，避免出现一些手滑操作。 基础操作介绍 Ctrl+Alt+F1-F6切换终端 简单文本在线文本编辑器：nano 关机指令：shutdown、poweroff、reboot、halt 复杂关机指令：systemctl 【指令】，上面的几个指令都是调用这个指令。 5.Linux的文件权限与目录配置使用者与群组 文件拥有者（owner）：Linux是多人多任务的系统，因此可能会有多人同时使用一部主机的情况，此时文件拥有者这个角色就相当重要，不想让别人看到的文件，就可以设置成只有文件拥有者才可以看到文件的内容。 群组（group）：比如在团队协作的时候，某些文件是具有一定的保密性的，只能让团队里面的成员使用，组内成员之间可以互相修改对方的数据，但是其他组的成员不能看到本组的文件内容。帐号支持多群组设定。 其他人（others）：与文件拥有没有任何关系，只有上述两种使用者给予权限才可访问。 上图中例子：以王三毛为例，王三毛这个文件的拥有者为王三毛，王三毛属于王大毛这个群组，而张小猪相对于王三毛，只是个其他人而已。 图中有一个特殊的人物，就是天神（root），拥有无限的权利，所以他可以访问任何一个地方。 用户身份与群组记录文件 root相关的信息记录在&#x2F;etc&#x2F;passwd 个人的密码信息记录在&#x2F;etc&#x2F;shadow Linux所有的组名记录在&#x2F;etc&#x2F;group 打开这三个文件后，发现并不能看懂:smile: Linux文件权限概念Linux文件属性 第一栏表示这个文件的类型与权限 共有10个字符 第一个字符代表文件类型 d：目录 -：文件 l：链接文档（link file） b：装置文件里面可供存储的接口设备 c：装置文件里面的串行端口设备，例如鼠标键盘 接下来的字符中三个为一组，均为”rwx“三个参数的组合 r：可读；w：可写；x：可执行（execute），三个参数的位置不会变，如果没有权限，会用-代替。 第一组为文件拥有者可具备的权限，上图中对应的权限为rw，表示拥有者可读写，但不可执行。 第二组为加入群组的用户的权限，途中对应权限为r，表示群组内用户可写。 第三组为其他用户的权限，途中对用权限为r，表示其他用户可写。 第二栏表示有多少档名链接到此节点 每个文档都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用温金明来记录，因此每个档名会连接到一个i-node。从.目录和.. 目录就可以看出个数。 第三栏表示这个文件的拥有者名称 图中文件为root用户有。 第四栏表示这个文件的所属群组 图中文件的所属群组为root，在root群组内的用户拥有r权限。 第五栏表示文件的容量大小 默认单位为bytes，图中文件容量为148bytes。 第六栏表示文件的建档日期或者是最近的修改日期 这一栏的内容分别为日期（月&#x2F;日）及时间，如果修改的时间局不是在现在的时间年份，会显示年份。 如果想看完整的时间格式，使用：ls -l –full-time 就能显示出完整的时间格式了。 第七栏为这个文档的名称 如果文档名前面有一个[.]，则代表这个文件为隐藏文件。 对于目录的权限： r：读包含目录中的文件名称； w：写信息到目录中去（增加和删除索引点的链接）； x：搜索目录（能用改目录名称作为路径名去访问它所包含的文件个子目录）；拥有此权限相当于拥有了目录下文件名称及内容的权限。 即： 有只读权限的用户不能用cd进入该目录，还必须有执行权限才能进入。 有执行权限的用户只有在知道文件名，并拥有文件的读权利的情况下才可以访问目录下的文件。 必须有读和执行权限才可以ls列出目录清单，或者使用cd进入该目录。 有目录的写权限，可以创建、删除或修改该目录下的任何文件或子目录，即使该文件或子目录属于其他用户。 Linux文件权限重要性 系统保护的功能：像是&#x2F;etc&#x2F;shadow 这种文件，用来保存系统中所有账号的数据，不能被任何人读取，所以对应权限为———，只有root可读。 团队开发数据共享：希望某些文件只有你团队的人可以实用，其他人都不能看到的时候。 未将权限合理化的危害：比如给了用户开关机权限，使用者不小心关了机，系统就会慕名的挂掉；或者密码被其他人士获得了，他使用root登录就会轻而易举的做root的一些工作。 改变文件属性与权限 更改所属群组：chgrp 被改变的组名必须要在&#x2F;etc&#x2F;group 文件内存在才行。 更改文件拥有者：chown 被更改的用户名必须要在&#x2F;etc&#x2F;passwd 文件内才行。 更改文件权限：chmod 数字类型更改权限： r:4;w:2;x:1；暴力授权的时候经常用的：chmod 777 filename。 符号类型更改权限： 使用user（u）、group（g）、others（o）表示三种身份的权限，a则代表全部的身份。 目录与文件之权限意义 权限对文件的重要性 Windows下的可执行文件室友拓展名来判断的，像是.exe、.bat、.com等，但是在Linux下，是否能够执行，完全是由x这个权限确定的，跟文档名没有绝对的关系。 w权限，表示可以写入、编辑、新增、修改文件内容的权限，但并不具有删除文件本身的权限。对于文件的rwx，都是针对文件的内容而言的，与文档的存在与否没有关系。 权限对目录的重要性 r：具有读取目录结构列表的权限，可以查询该目录下的文件名数据，所以你可以使用ls指令将目录的内容显示出来。 w：这个权限对于目录来说比较重要，表示用户拥有变更目录结构的权限，即： 建立新的文件与目录； 删除已经存在的文件与目录（无论该文件的权限如何）； 将已存在的文件或目录进行更名； 移动该目录内的文件与目录的位置； 总之，w权限与该目录下的文件名变更有关。 x：代表用户能否进入该目录成为工作目录的用途。 上图例子中，r都不是必须的，因为我知道要找的文件file1的名字，缺少r只是缺少了tab补全。 Linux文件种类与拓展名 文件种类 正规文件（regular file） 在查看文件属性时，第一个字符为-的文件； 按照文件内容，大致分为： 纯文本文档（ASCII）：Linux系统中最多的一种文件类型，几乎用来作为设定的文件都是这个文件类型。 二进制文件（binary）：Linux当中的可执行文件就是这种格式，比如指令cat。 数据格式文件（date）：有些文件在运行的过程当中会读取某些特定格式的文件，这些文件可被称作数据文件，数据文件了可以使用last读出来，但使用cat就会出现乱码。 目录（directory） 第一个属性为d。 连接文档（link file） 类似Windows下的快捷方式，第一个属性为l。 设备与装置文件（device） 与系统周边及储存相关的一些文件，通常都集中在&#x2F;dev这个目录下，通常分为两种： 区块（block）设备文档：一些存储数据，以提供系统随机存取的接口设备，比如硬盘与软盘，第一个属性为b。 字符（character）设备文件：即一些串行端口的接口设备，例如键盘鼠标，特征为一次性读取，不能够截断输出。例如不能让鼠标跳到另一个画面，而是连续滑动，第一个属性为c。 资料接口文档（sockets） 这种文件通常被用在网络上的数据承接，当启动一个程序来监听客户端的要求，客户端就可以通过这个socket进行数据的沟通了。第一个属性为s。 数据传送文件（FIFO，pipe） FIFO也是一种特殊的文件类型，主要目的在解决多个程序同时存取一个文件所造成的错误问题。第一个属性为p。 文件拓展名 基本上Linux没有所谓的拓展名，一个文件能不能执行，取决于第一栏的十个属性。不过文件能不能执行成功还要取决于文件是否具备可执行的程序代码。 虽然如此，我们仍希望可以通过文件名来了解某文件是什么东西，所以我们通常还是会以适当的拓展名来区分文件种类的： .sh：脚本或批处理文件，因为批处理文件用shell写成，所以缩写为sh。 Z，.tar，.tar.gz，.zip，tgz：经过打包的压缩文件。因为压缩软件分别为gunzip，tar等，所以取名。 .html，.php：网页相关文件，分别代表HTML语法与PHP语法的网页文件。 文件名长度限制 最大容许文件名255bytes，即约英文字符255个，中文字约128个。 文件名限制 文字接口下的一些指令的操作关系，在设定名称时，最好避免一些特殊字符：*?&lt;&gt;;[]{}()&amp;&#96;’”-| Linux目录配置Linux的目录配置依据—FHS 由于使用Linux开发产品或者distributions的开发者太多了，如果每个人都按照自己的想法来配置文件防止的目录，那可能会造成管理上的困扰，这就有了后来的FHS（Filesystem Hierarchy Standard）标准出炉了。 FHS根据文件系统使用的频繁与否与是否允许使用者随意更改，而将目录定义成为四种交互作用的形态，类似下图： 这是一些代表性的目录，关于这四种类型： 可分享的：可以分享给其他系统挂在使用的目录，像是执行文件、用户的邮件等数据。 不可分享的：自己机器上面运作的装置文件或者与程序有关的socket文件等，由于仅仅与自身及其有关，所以当然不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着distribution而不变动，例如函数库、文件说明文件、系统管理员所管理的主机服务配置文件等等。 可变的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 事实上，FHS针对目录树架构仅定义出三层目录下应该放什么数据而已，分别为： &#x2F;（root，根目录）：与开机系统有关； &#x2F;usr（unix software resource）：与软件安装、执行有关； &#x2F;var（variable）：与系统运作过程有关。 下面是FHS系统规定的必须要存在的目录以及建议存在的目录 在CentOS 7 中，目录编排与过去版本不同，将一部分原本在根目录下的目录，内部数据全部挪到&#x2F;usr 中，然后进行连接设定，具体如下： 目录树 如图，&#x2F;var 目录最好能够独立出来，这样对于系统的数据还有一些安全性的保护，至少&#x2F;var 死掉时，根目录还活着，还能够进入救援模式。 个人理解因为&#x2F;var 存放的是常态性变动文件，所以容易被搞出事情，所以这里强调将其单独放出来。 绝对路径与相对路径绝对路径：一定是从根目录写起； 相对路径：从相对于当前工作目录的路径写起； . ：代表当前的目录，可使用.&#x2F;代替； .. ：代表上一层目录，可使用..&#x2F;代替； 之前编译过后进行的文件运行时使用.&#x2F;run.sh，就表示的是本目录下的run.sh 文件。 6.Linux文件与目录管理目录与路径绝对路径与相对路径用途 绝对路径：比如在使用shell编写管理系统的程序时，写绝对路径虽然比较麻烦但是保险。 相对路径：在同目录下多个文件操作，或者文件树比较深的时候，相对路径简洁的优势就显现出来了。 目录的相关操作常用指令：cd、pwd、mkdir、rmdir。 根目录下也是存在.. 目录的，不过与. 目录所指的是同一个目录。 cd（change directory，变换目录） cd、cd ~ ：指的都是返回家目录； cd - ：指的是返回上次的目录，类似电视机遥控器的返回键。 pwd（print working directory，显示目前所在的工作目录） pwd -P 表示显示实际路径，而非使用链接路径。 mkdir（make directory，建立新目录） 默认情况下，需要的目录需要一层一层建立。 mkdir -p pathname&#x2F;pathname2&#x2F;filename ：指的是递归建立目录。 -m 参数表示预设权限：我的CentOS7.7默认的权限是755。 同时-p -m 创建的目录，只有最底层目录的权限是预设参数，其他的均为默认值。 默认属性跟umask有关。 rmdir（remove directory，删除目录） -p ：递归删除空目录，像是rmdir -p test&#x2F;kong&#x2F;； rm -r ：可删除非空目录。 关于执行文件路径的变量：$PATH像是Windows中的环境变量一样，Linux中的环境变量为用户可以在任何地方使用某些指令提供了帮助。 以ls为例，当你输入ls，系统会按照PATH的设定去每个PATH目录下搜寻文件名为ls的可执行文件，若遇到多个名为ls的文件，那么先搜索到的同名文件先执行。 echo $PATH 指令可以查看当前的环境变量。echo有打印的意思，$后面接的是变量，所以会显示出目前的PATH。 将&#x2F;usr&#x2F;bin&#x2F; 目录下的ls文件移动到&#x2F;root&#x2F;中，会发现ls无法使用，但是使用绝对路径&#x2F;root&#x2F;ls或者&#x2F;root目录下.&#x2F;ls可以执行，说明这个目录不在PATH中。 添加PATH：PATH&#x3D;”${PATH}:&#x2F;root”。 安全起见，不建议将. 加入PATH中，避免写某些文件过度使用权限。 文件与目录管理文件目录查看：ls bash shell 实现了将ll 代表ls -l 的指令。 复制、删除与移动：cp，rm，mv cp（copy） 常用-a 或-p 来完整复制文件的权限，否则都会按照默认的权限复制的！ 总之，由于cp有种种的文件属性与权限的特性，所以在复制时必须要考虑到： 是否需要完整的保留来源文件的信息？ 来源文件是否为链接文档？ 来源文件是否为特殊文件，如FIFO，socket 等？ 来源文件是否为目录？ rm（remove） rm -r 递归删除一些废弃文件夹很好用，慎用。 当然还有毁天灭地的rm -rf &#x2F;* 指令，千万别用！！！:smile: mv(move) 获取路径的文件名与目录名称 文件内容查阅 cat：从第一行开始显示文件内容； tac：从最后一行开始显示，其实是cat倒着拼写； nl：显示的时候，输出行号； more：一页一页显示文件的内容； less：与more相似，不过他可以向前翻页； head：只看前几行； tail：只看尾巴几行； od：以二进制的方式读取文件内容。 前三个都是一口气阿静数据显示在屏幕上面，more和less都可以一页一页的观察。 cat(concatenate) tac 有点意思，tac就是将cat输出的内容按照行数倒序连续输出。 nl(添加行号打印) nl的预设和cat -n有点不太一样，nl可以将行号做比较多的显示设计，包括位数与是否自动补齐0等等。 more() 空格键：代表向下翻一页； 回车键：代表向下翻一行； &#x2F;字符串：代表在这个显示的内容当中，向下搜索【字符串】这个关键词； :f ：立即显示文件名以及目前的行数； q ：代表立即离开more，不在显示文件内容； b 或【Ctrl】-b：代表往回翻页，支队文件有效，对管线无效； 尝试使用&#x2F; 搜索，不知为何失败了。 less(一页一页翻动) man page 就是使用less来显示说明文件的内容的。 head(取出前面几行) 如果n 为负数，代表不显示后面-n行。 tail() 类似tail ，相反方向。 od(非纯文本文档) 修改文件时间或新建文档：touch Linux下记录许多的时间参数，其实是三个主要的变动时间： modification time（mtime） 当文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容。 status time（ctime） 当文件的状态改变时，就会更新这个时间，像是权限与属性被更改了，就回更细这个时间。 access time（atime） 当文件的内容被取用时，就会更新这个时间，比如使用cat读取文件内容，就会更新这个时间。 touch改变的是mtime和atime，因此常被用来更改文件日期为某时间。 另一个常用是创建一个空文件。 文件与目录的默认权限与隐藏权限文件预设权限：umask默认权限的属性上，目录与文件是不一样的，一般情况下，x权限对于目录来说十分重要，而文件则主要是用于数据记录，不需要执行权限。所以： 当使用者建立文件则预设没有可执行权限，即只有rw两个权限，最大的数字表示为666，即-rw-rw-rw-； 当使用者建立目录则预设默认所有权限均开放，最大数字为777，即drwxrwxrwx。 umask的数字代表被减掉的权限，以umask为022为例，相当于： 文件隐藏属性 chattr（配置文件隐藏属性） lsattr（显示文件隐藏属性） 文件特殊权限：SUID，SGID，SBIT Set UID 当s出现在文件拥有者的x权限上时，即称为SUID。 SUID针对文件设定。 例子：Linux的所有账号密码都在&#x2F;etc&#x2F;shadow 这个文件里，这个文件权限为———- 1 root root ,即为只有root可用。但是作为普通用户可以通过passwd修改自己的密码，更改该文件，这就是SUID的功能。 但是像用户dmtsai并不能使用cat查看&#x2F;etc&#x2F;shadow ，因为cat不具有SUID权限。 Set GID 当s出现在文件群组的x权限上时，即称为SGID。 SGID针对目录和文件设定。 当对一个文件设定了SGID权限时： 与SUID类似，在执行一些有SGID权限的文件时会获得对应群组的权限支持。 当对一个目录设定了SGID权限时： Sticky Bit SBIT仅作用在目录上。对于目录的作用为： 当用户对目录具有rwx权限时； 用户在该目录下创建文件或者目录，仅有自己与root才有权利删除该文件。 t的作用就是不能删除别人的文件。 留白，root用户创建的777权限的目录下，普通用户能否进行更改权限，删除文件等操作。 1正常情况下，更改权限只能是文件拥有者或是root用户进行。该目录下用户可以删除文件和空目录，非空目录能否删除取决于目录及目录内文件的权限设置。 权限设定 数字指令 SUID：4 SGID：２ SGIT：１ 在原先的７７７权限之前加上一个数字，因为这三个数字分别在三个用户组下，所以不会有冲突。像是chmod 4755 filename ，当出现Ｓ，Ｔ时，表示对应位置没有ｘ权限。 字母指令 观察文件类型：file 指令与权限的搜寻脚本文件名的搜寻 which type 文档名的搜索 whereis locate &#x2F; updatedb find find 有很多的用途，懒惰至极的我没整理。 这一章后面的习题很精彩，在Pages 276 认识Linux的文件系统","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}],"author":"kong"},{"title":"Java 二维数组排序","slug":"Java 二维数组的排序","date":"2020-05-18T04:00:00.000Z","updated":"2022-11-27T12:58:16.842Z","comments":true,"path":"posts/1218.html","link":"","permalink":"http://example.com/posts/1218.html","excerpt":"","text":"Java 二维数组排序按照第一个元素升序排序，如果第一个元素相同，则按照第二个元素升序排序 12345678int [][]people=new int[4][2];Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; if (o1[0]==o2[0]) return o1[1]-o2[1]; return o1[0]-o2[0]; &#125;&#125;); 如果需要降序排序，将返回值加负号","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}],"author":"kong"},{"title":"push项目遇到timeout","slug":"git timeout问题","date":"2018-01-01T04:00:00.000Z","updated":"2022-11-27T03:06:05.179Z","comments":true,"path":"posts/18120.html","link":"","permalink":"http://example.com/posts/18120.html","excerpt":"","text":"今天push项目遇到timeout 不知为何遇到了这个问题，仿佛不是第一次了 经过一番百度，找到了解决方案 但不知道为什么，其中的端口号是clash使用的端口号，猜测与其有关 具体操作查看全局配置参数 1git config --global --list 在开启shadowsock的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。 12git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy http://127.0.0.1:7890 其中的7890改成你的ssh端口号 http:&#x2F;&#x2F;也可以改成sockets5:&#x2F;&#x2F;,但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。 取消代理： 12git config --global --unset http.proxy git config --global --unset https.proxy 然后就可以使用了","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}],"author":"kong"}],"categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"非技术","slug":"非技术","permalink":"http://example.com/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"},{"name":"hexo博客","slug":"hexo博客","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"实时调度器","slug":"实时调度器","permalink":"http://example.com/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"市场经济","slug":"市场经济","permalink":"http://example.com/tags/%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E/"},{"name":"定价方法","slug":"定价方法","permalink":"http://example.com/tags/%E5%AE%9A%E4%BB%B7%E6%96%B9%E6%B3%95/"},{"name":"最优化问题","slug":"最优化问题","permalink":"http://example.com/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"},{"name":"论文阅读","slug":"论文阅读","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"算力网络","slug":"算力网络","permalink":"http://example.com/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"},{"name":"边缘博弈","slug":"边缘博弈","permalink":"http://example.com/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"},{"name":"摩斯电码","slug":"摩斯电码","permalink":"http://example.com/tags/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"merge","slug":"merge","permalink":"http://example.com/tags/merge/"},{"name":"pull","slug":"pull","permalink":"http://example.com/tags/pull/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"},{"name":"浮点数精度","slug":"浮点数精度","permalink":"http://example.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"},{"name":"githubpags","slug":"githubpags","permalink":"http://example.com/tags/githubpags/"},{"name":"jekyll","slug":"jekyll","permalink":"http://example.com/tags/jekyll/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"typora","slug":"typora","permalink":"http://example.com/tags/typora/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]}