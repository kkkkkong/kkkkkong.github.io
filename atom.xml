<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-02-21T06:32:13.991Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 438</title>
    <link href="https://kkkkkong.github.io/posts/51961.html"/>
    <id>https://kkkkkong.github.io/posts/51961.html</id>
    <published>2023-02-21T06:29:10.000Z</published>
    <updated>2023-02-21T06:32:13.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>数组差+滑窗，用两个数组分别表示字符串p中字母出现的次数以及滑窗中字母出现的次数，方便统计，采用变量diff表示两个数组的不同字母数。diff为0时，将left指针加入结果集中</li></ol><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了67.39%的用户</p><p>内存消耗：42.7 MB, 在所有 Java 提交中击败了38.45%的用户</p><p>通过测试用例：64 &#x2F; 64</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []ptmp=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> []stmp=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,n=s.length();</span><br><span class="line">        <span class="type">int</span> plen=p.length();</span><br><span class="line">        <span class="type">int</span> diff=plen;</span><br><span class="line">        List&lt;Integer&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;plen;i++)&#123;</span><br><span class="line">            ptmp[p.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span>&gt;plen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmp[s.charAt(left)-<span class="string">&#x27;a&#x27;</span>]&lt;=ptmp[s.charAt(left)-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    diff--;</span><br><span class="line">                &#125;</span><br><span class="line">                stmp[s.charAt(left)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmp[s.charAt(right)-<span class="string">&#x27;a&#x27;</span>]&gt;=ptmp[s.charAt(right)-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    diff--;</span><br><span class="line">                &#125;</span><br><span class="line">                stmp[s.charAt(right)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;438-找到字符串中所有字母异位词&quot;&gt;&lt;a href=&quot;#438-找到字符串中所有字母异位词&quot; class=&quot;he</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1004</title>
    <link href="https://kkkkkong.github.io/posts/39420.html"/>
    <id>https://kkkkkong.github.io/posts/39420.html</id>
    <published>2023-02-21T02:13:15.000Z</published>
    <updated>2023-02-21T02:21:17.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h4><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑窗，数组中只有1和0，可以用做和的形式来表示，左指针移动的条件为right-left+1&gt;sum+k</li></ol><blockquote><p>执行用时：4 ms, 在所有 Java 提交中击败了17.57%的用户</p><p>内存消耗：43.2 MB, 在所有 Java 提交中击败了20.81%的用户</p><p>通过测试用例：52 &#x2F; 52</p><p>时间 O(N)</p><p>空间O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span>&lt;=sum+k)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>精简一下，因为在一次左指针移动后，下次循环必定不会再进if，所以默认每次right++，减少循环次数</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了69.83%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了91.21%的用户</p><p>通过测试用例：52 &#x2F; 52</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span>&gt;sum+k)&#123;</span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            ans=Math.max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1004-最大连续1的个数-III&quot;&gt;&lt;a href=&quot;#1004-最大连续1的个数-III&quot; class=&quot;he</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 424</title>
    <link href="https://kkkkkong.github.io/posts/24568.html"/>
    <id>https://kkkkkong.github.io/posts/24568.html</id>
    <published>2023-02-21T01:46:17.000Z</published>
    <updated>2023-02-21T01:49:19.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p><p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ABAB&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>数组+滑窗：两个关键条件，一个是maxcount，表示当前窗口内的单个单词的最大数目；另一个是left向前移动的条件，right-left&gt;max+k，巧妙的进行了控制</li></ol><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了29.40%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了53.10%的用户</p><p>通过测试用例：37 &#x2F; 37</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characterReplacement</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="type">int</span> maxCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            tmp[s.charAt(right)-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            maxCount=Math.max(maxCount,tmp[s.charAt(right)-<span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;maxCount+k)&#123;</span><br><span class="line">                tmp[s.charAt(left)-<span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;424-替换后的最长重复字符&quot;&gt;&lt;a href=&quot;#424-替换后的最长重复字符&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 219</title>
    <link href="https://kkkkkong.github.io/posts/27609.html"/>
    <id>https://kkkkkong.github.io/posts/27609.html</id>
    <published>2023-02-20T02:31:47.000Z</published>
    <updated>2023-02-20T02:35:47.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+滑动窗口</li></ol><blockquote><p>执行用时：16 ms, 在所有 Java 提交中击败了84.97%的用户</p><p>内存消耗：51.8 MB, 在所有 Java 提交中击败了34.72%的用户</p><p>通过测试用例：54 &#x2F; 54</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(nums[right]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.add(nums[right]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(nums[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;219-存在重复元素-II&quot;&gt;&lt;a href=&quot;#219-存在重复元素-II&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 3</title>
    <link href="https://kkkkkong.github.io/posts/41773.html"/>
    <id>https://kkkkkong.github.io/posts/41773.html</id>
    <published>2023-02-20T02:00:47.000Z</published>
    <updated>2023-02-20T02:16:10.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口+哈希表：右指针前进条件，set中不包含right指向元素，否则左指针前进，并移除掉当前左指针指向元素。</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了58.48%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了91.46%的用户</p><p>通过测试用例：987 &#x2F; 987</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(c))&#123;</span><br><span class="line">                len++;</span><br><span class="line">                right++;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len--;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动窗口+数组：优化1，使用数组存放，ASCII编码，使用128大小的数组存放</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了92.81%的用户</p><p>内存消耗：41.2 MB, 在所有 Java 提交中击败了96.93%的用户</p><p>通过测试用例：987 &#x2F; 987</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(tmp[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                len++;</span><br><span class="line">                right++;</span><br><span class="line">                tmp[c]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len--;</span><br><span class="line">                tmp[s.charAt(left)]=<span class="number">0</span>;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#3-无重复字符的最长子串&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 523</title>
    <link href="https://kkkkkong.github.io/posts/24040.html"/>
    <id>https://kkkkkong.github.io/posts/24040.html</id>
    <published>2023-02-20T01:08:11.000Z</published>
    <updated>2023-02-20T02:16:10.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p><ul><li>子数组大小 <strong>至少为 2</strong> ，且</li><li>子数组元素总和为 <code>k</code> 的倍数。</li></ul><p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [23,2,4,6,7], k = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+同余定理+前缀和</li></ol><blockquote><p>执行用时：25 ms, 在所有 Java 提交中击败了9.51%的用户</p><p>内存消耗：56.9 MB, 在所有 Java 提交中击败了59.05%的用户</p><p>通过测试用例：98 &#x2F; 98</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSubarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="type">int</span> mod=sum%k;</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(mod,-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=-<span class="number">2</span>&amp;&amp;i-value&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(mod,map.getOrDefault(mod,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;523-连续的子数组和&quot;&gt;&lt;a href=&quot;#523-连续的子数组和&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 974</title>
    <link href="https://kkkkkong.github.io/posts/52330.html"/>
    <id>https://kkkkkong.github.io/posts/52330.html</id>
    <published>2023-02-19T08:52:01.000Z</published>
    <updated>2023-02-19T08:57:55.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a></h4><p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p><p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,0,-2,-3,1], k = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 k = 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+同余定理+哈希表，a和b对k的余数相同，那么(a-b)对k取余为0</li></ol><blockquote><p>执行用时：16 ms, 在所有 Java 提交中击败了81.95%的用户</p><p>内存消耗：47.6 MB, 在所有 Java 提交中击败了5.25%的用户</p><p>通过测试用例：73 &#x2F; 73</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysDivByK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>,n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="type">int</span> mod=(sum%k+k)%k;</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(mod,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(mod,value+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;974-和可被-K-整除的子数组&quot;&gt;&lt;a href=&quot;#974-和可被-K-整除的子数组&quot; class=&quot;head</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 930</title>
    <link href="https://kkkkkong.github.io/posts/53097.html"/>
    <id>https://kkkkkong.github.io/posts/53097.html</id>
    <published>2023-02-19T07:17:09.000Z</published>
    <updated>2023-02-19T08:02:27.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930. 和相同的二元子数组"></a><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></h4><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：hashmap存放sum出现的次数</li></ol><blockquote><p>执行用时：20 ms, 在所有 Java 提交中击败了59.25%的用户</p><p>内存消耗：46.1 MB, 在所有 Java 提交中击败了35.95%的用户</p><p>通过测试用例：60 &#x2F; 60</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="comment">// hashmap存放sum出现的次数</span></span><br><span class="line">        Map &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(sum-goal,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=-<span class="number">1</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动窗口，重点打开思路，因为数组中只有0和1，需要使用两个左指针来表示right固定的情况下，有多少种情况满足</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了78.77%的用户</p><p>内存消耗：45.2 MB, 在所有 Java 提交中击败了60.27%的用户</p><p>通过测试用例：60 &#x2F; 60</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> left1=<span class="number">0</span>,left2=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            sum1+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left1&lt;=right&amp;&amp;sum1&gt;goal)&#123;</span><br><span class="line">                sum1-=nums[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left2&lt;=right&amp;&amp;sum2&gt;=goal)&#123;</span><br><span class="line">                sum2-=nums[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=left2-left1;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;930-和相同的二元子数组&quot;&gt;&lt;a href=&quot;#930-和相同的二元子数组&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 724</title>
    <link href="https://kkkkkong.github.io/posts/24328.html"/>
    <id>https://kkkkkong.github.io/posts/24328.html</id>
    <published>2023-02-19T02:26:13.000Z</published>
    <updated>2023-02-19T08:02:27.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/">724. 寻找数组的中心下标</a></h4><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了73.45%的用户</p><p>内存消耗：42.4 MB, 在所有 Java 提交中击败了32.02%的用户</p><p>通过测试用例：746 &#x2F; 746</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []sum=<span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum[i]=sum[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i]==sum[n]-sum[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前缀和优化，不需要使用数组存储，只需要用一个变量记录当前的数组和是多少即可</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了36.89%的用户</p><p>内存消耗：42 MB, 在所有 Java 提交中击败了75.86%的用户</p><p>通过测试用例：746 &#x2F; 746</p><p>时间 O(N)</p><p>空间 O(1)</p><p>一样的代码，运行两次，也不知道是为何两次差距这么大</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了10.93%的用户</p><p>通过测试用例：746 &#x2F; 746</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==sum-pre-nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;724-寻找数组的中心下标&quot;&gt;&lt;a href=&quot;#724-寻找数组的中心下标&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 560</title>
    <link href="https://kkkkkong.github.io/posts/40106.html"/>
    <id>https://kkkkkong.github.io/posts/40106.html</id>
    <published>2023-02-18T07:49:42.000Z</published>
    <updated>2023-02-18T08:04:17.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：查找tmp[i]-k出现的次数</li></ol><blockquote><p>执行用时：17 ms, 在所有 Java 提交中击败了98.66%的用户</p><p>内存消耗：45.6 MB, 在所有 Java 提交中击败了39.34%的用户</p><p>通过测试用例：93 &#x2F; 93</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        tmp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp[i]=tmp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找tmp[i]-k出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> q=tmp[i]-k;</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="number">0</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(q,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(tmp[i],map.getOrDefault(tmp[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法一的优化，笑死，优化完，时间翻倍了</li></ol><blockquote><p>执行用时：29 ms, 在所有 Java 提交中击败了40.76%的用户</p><p>内存消耗：44.9 MB, 在所有 Java 提交中击败了63.23%的用户</p><p>通过测试用例：93 &#x2F; 93</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="type">int</span> q=sum-k;</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(q,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;560-和为-K-的子数组&quot;&gt;&lt;a href=&quot;#560-和为-K-的子数组&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 528</title>
    <link href="https://kkkkkong.github.io/posts/39593.html"/>
    <id>https://kkkkkong.github.io/posts/39593.html</id>
    <published>2023-02-18T03:41:24.000Z</published>
    <updated>2023-02-18T08:04:17.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a><a href="https://leetcode.cn/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4><p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p><p>请你实现一个函数 <code>pickIndex</code> ，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code> 的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p><ul><li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，<code>75%</code>）。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1]],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,0]</span><br><span class="line">解释：</span><br><span class="line">Solution solution = new Solution([1]);</span><br><span class="line">solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+二分查找，重点是将权重数组以前缀和的形式表示出来，假设总权重和为sum，那么在[1,sum]上随机取数字，落在权重大的区间上的概率更大。二分查找只是更快的查到<strong>下标最大的小于x的区间</strong>在哪</li></ol><p>int x&#x3D;(int)(Math.random()*sum)+1;的取值很重要，random返回的是[0,1)的数字，不加1永远取不到sum的右边界</p><blockquote><p>执行用时：25 ms, 在所有 Java 提交中击败了45.06%的用户</p><p>内存消耗：45.8 MB, 在所有 Java 提交中击败了80.66%的用户</p><p>通过测试用例：57 &#x2F; 57</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> []pre;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        pre=<span class="keyword">new</span> <span class="title class_">int</span>[w.length];</span><br><span class="line">        pre[<span class="number">0</span>]=w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">            pre[i]=pre[i-<span class="number">1</span>]+w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum=Arrays.stream(w).sum();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pickIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> x=(<span class="type">int</span>)(Math.random()*sum)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(pre,x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> []pre,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=pre.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[mid]&lt;x)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;528-按权重随机选择&quot;&gt;&lt;a href=&quot;#528-按权重随机选择&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 525</title>
    <link href="https://kkkkkong.github.io/posts/24424.html"/>
    <id>https://kkkkkong.github.io/posts/24424.html</id>
    <published>2023-02-17T03:20:26.000Z</published>
    <updated>2023-02-17T07:15:50.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a href="https://leetcode.cn/problems/contiguous-array/">525. 连续数组</a></h4><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这里的变0为-1真的是神来之笔</p></blockquote><ol><li>前缀和+变0为-1，将0变为-1后，主要统计前缀和，将第一次出现的元素保存到map中。特殊的，和为0的表示天然符合题目要求</li></ol><blockquote><p>执行用时：13 ms, 在所有 Java 提交中击败了97.19%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了95.36%的用户</p><p>通过测试用例：564 &#x2F; 564</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)nums[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存放第一个和为k的元素位置</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                ans=Math.max(ans,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tmp=map.getOrDefault(sum,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp==-<span class="number">1</span>)&#123;</span><br><span class="line">                map.put(sum,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans=Math.max(ans,i-tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;525-连续数组&quot;&gt;&lt;a href=&quot;#525-连续数组&quot; class=&quot;headerlink&quot; title=&quot;5</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 209</title>
    <link href="https://kkkkkong.github.io/posts/64472.html"/>
    <id>https://kkkkkong.github.io/posts/64472.html</id>
    <published>2023-02-17T02:14:09.000Z</published>
    <updated>2023-02-17T07:15:50.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+二分查找 时空 O(NLogN) O(1)</li><li>前缀和作差+滑动窗口，这里的额外数组使用n+1长度更舒服，tmp[i]表示前i个元素的和</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了15.24%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了7.48%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">// 数组计数，tmp[i]表示前i个元素的和</span></span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        tmp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp[i]=tmp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp[n-<span class="number">1</span>]&lt;target)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp[<span class="number">0</span>]&gt;=target)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,ans=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[j]&gt;=target)&#123;</span><br><span class="line">                ans=Math.min(ans,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp[j]-tmp[i]&lt;target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(tmp[j]-tmp[i]&gt;=target)&#123;</span><br><span class="line">                    ans=Math.min(ans,j-i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前缀和+滑动窗口，改进版</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：49.2 MB, 在所有 Java 提交中击败了14.99%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> ans=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;n)&#123;</span><br><span class="line">            sum+=nums[end++];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                ans=Math.min(ans,end-start);</span><br><span class="line">                sum-=nums[start++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans==Integer.MAX_VALUE?<span class="number">0</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;209-长度最小的子数组&quot;&gt;&lt;a href=&quot;#209-长度最小的子数组&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2341</title>
    <link href="https://kkkkkong.github.io/posts/7886.html"/>
    <id>https://kkkkkong.github.io/posts/7886.html</id>
    <published>2023-02-16T01:09:05.000Z</published>
    <updated>2023-02-16T02:35:57.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2341-数组能形成多少数对"><a href="#2341-数组能形成多少数对" class="headerlink" title="2341. 数组能形成多少数对"></a><a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/">2341. 数组能形成多少数对</a></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p><ul><li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li><li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li></ul><p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p><p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中 <code>answer[0]</code> 是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,1,3,2,2]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：</span><br><span class="line">nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。</span><br><span class="line">nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。</span><br><span class="line">nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。</span><br><span class="line">无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+枚举：排序后遍历数组，如果一个数和他后面的数相等，那么说明这两个数需要移除，否则继续向后移动</li></ol><blockquote><p>时间 O(NLogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfPairs(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []ans=<span class="keyword">new</span> <span class="title class_">int</span> []&#123;<span class="number">0</span>,n&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                ans[<span class="number">0</span>]++;</span><br><span class="line">                ans[<span class="number">1</span>]-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>哈希+枚举</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了54.00%的用户</p><p>内存消耗：40.3 MB, 在所有 Java 提交中击败了40.80%的用户</p><p>通过测试用例：128 &#x2F; 128</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfPairs(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Boolean&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,!map.getOrDefault(i,<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">if</span>(map.get(i))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ans,n-ans*<span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2341-数组能形成多少数对&quot;&gt;&lt;a href=&quot;#2341-数组能形成多少数对&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 647</title>
    <link href="https://kkkkkong.github.io/posts/15898.html"/>
    <id>https://kkkkkong.github.io/posts/15898.html</id>
    <published>2023-02-15T01:38:38.000Z</published>
    <updated>2023-02-16T02:35:57.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>找规律+中心扩展法：参考题解，非常巧妙的应用了回文串的规律，将回文串的长度分为奇偶两种情况，<strong>枚举每一个回文中心，并用两个指针向左右两边扩展，两个指针指向相同的时候，就扩展，否则就返回</strong></li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了84.78%的用户</p><p>通过测试用例：130 &#x2F; 130</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            count(s,i,i);</span><br><span class="line">            count(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))&#123;</span><br><span class="line">            num++;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>马拉车算法，还没吃透</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了75.45%的用户</p><p>通过测试用例：130 &#x2F; 130</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        StringBuffer t=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;$#&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            t.append(s.charAt(i));</span><br><span class="line">            t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        n=t.length();</span><br><span class="line">        t.append(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> []f=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> iMax=<span class="number">0</span>,rMax=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=i&lt;=rMax?Math.min(rMax-i+<span class="number">1</span>,f[<span class="number">2</span>*iMax-i]):<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t.charAt(i+f[i])==t.charAt(i-f[i]))&#123;</span><br><span class="line">                ++f[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+f[i]-<span class="number">1</span>&gt;rMax)&#123;</span><br><span class="line">                iMax=i;</span><br><span class="line">                rMax=i+f[i]-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=f[i]/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;647-回文子串&quot;&gt;&lt;a href=&quot;#647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;6</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1124</title>
    <link href="https://kkkkkong.github.io/posts/14764.html"/>
    <id>https://kkkkkong.github.io/posts/14764.html</id>
    <published>2023-02-14T12:29:10.000Z</published>
    <updated>2023-02-14T13:04:05.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a><a href="https://leetcode.cn/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a></h4><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hours = [9,9,6,0,6,6,9]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的表现良好时间段是 [9,9,6]。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：将原问题转化为和大于0的最小子数组的问题，通过前缀和求解。</li></ol><p>如果hours[i]&gt;8，则arr[i]为1，否则为-1，然后再用arr[i]表示前i个元素的和，要寻找i和j，使得在i&lt;j时，arr[i]-arr[j]&gt;0（也就意味着i到j之间的和大于0，也即问题的求解）</p><p>对于arr[i]，有两种情况</p><ul><li>arr[i]&gt;0，表示前i+1个元素的和是表现良好的时间段</li><li>arr[i]&lt;&#x3D;0，则需要找到一个j，满足j&lt;i，arr[i]-arr[j]&gt;0，对于arr[j]来说，存在两种情况<ul><li>j&lt;i时，不存在arr[i]-arr[j]&gt;0，</li><li>j&lt;i时，存在arr[i]-arr[j]&gt;0，那么此时也一定存在arr[i]-arr[j]&#x3D;1，也即arr[j]&#x3D;arr[i]-1，使用哈希表存储第一次出现的arr[j]即可</li></ul></li></ul><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了70.25%的用户</p><p>内存消耗：42.1 MB, 在所有 Java 提交中击败了44.50%的用户</p><p>通过测试用例：98 &#x2F; 98</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=hours.length;</span><br><span class="line">        <span class="type">int</span> [] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        arr[<span class="number">0</span>]=hours[<span class="number">0</span>]&gt;<span class="number">8</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i]=arr[i-<span class="number">1</span>]+(hours[i]&gt;<span class="number">8</span>?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans=Math.max(ans,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> tmp=map.getOrDefault(arr[i]-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(tmp!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    ans=Math.max(ans,i-tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                map.putIfAbsent(arr[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1124-表现良好的最长时间段&quot;&gt;&lt;a href=&quot;#1124-表现良好的最长时间段&quot; class=&quot;header</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1234</title>
    <link href="https://kkkkkong.github.io/posts/43357.html"/>
    <id>https://kkkkkong.github.io/posts/43357.html</id>
    <published>2023-02-13T09:30:25.000Z</published>
    <updated>2023-02-13T09:32:31.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a></h4><p>有一个只含有 <code>&#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39;</code> 四种字符，且长度为 <code>n</code> 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 <code>n/4</code> 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 <code>s</code>，请通过「替换一个子串」的方式，使原字符串 <code>s</code> 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 <strong>任何</strong> 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;QWER&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：s 已经是平衡的了。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>暴力解法，超时了</p></li><li><p>滑动窗口，重要的是窗口左右移动的时机</p></li></ol><blockquote><p>执行用时：10 ms, 在所有 Java 提交中击败了22.95%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了43.44%的用户</p><p>通过测试用例：40 &#x2F; 40</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []cnt=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        String t=<span class="string">&quot;QWER&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt[t.indexOf(s.charAt(i))]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m=n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]==m&amp;&amp;cnt[<span class="number">1</span>]==m&amp;&amp;cnt[<span class="number">2</span>]==m&amp;&amp;cnt[<span class="number">3</span>]==m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cnt[t.indexOf(s.charAt(j))]--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;cnt[<span class="number">0</span>]&lt;=m&amp;&amp;cnt[<span class="number">1</span>]&lt;=m&amp;&amp;cnt[<span class="number">2</span>]&lt;=m&amp;&amp;cnt[<span class="number">3</span>]&lt;=m)&#123;</span><br><span class="line">                ans=Math.min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">                cnt[t.indexOf(s.charAt(i++))]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1234-替换子串得到平衡字符串&quot;&gt;&lt;a href=&quot;#1234-替换子串得到平衡字符串&quot; class=&quot;head</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CPU架构</title>
    <link href="https://kkkkkong.github.io/posts/27701.html"/>
    <id>https://kkkkkong.github.io/posts/27701.html</id>
    <published>2023-02-13T07:04:00.000Z</published>
    <updated>2023-02-13T09:32:31.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主流CPU指令集"><a href="#主流CPU指令集" class="headerlink" title="主流CPU指令集"></a>主流CPU指令集</h2><table><thead><tr><th align="center">架构</th><th align="center">指令集位数</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">x86</td><td align="center">32</td><td align="center">Intel开发，CPU架构习惯以86结尾，所以之后被称之为x86</td></tr><tr><td align="center">AMD64</td><td align="center">64</td><td align="center">32位向64位演进时，AMD更早的开发除了兼容x86(32位)指令集的处理器</td></tr><tr><td align="center">x86_64</td><td align="center">64</td><td align="center">Intel为了迈向64位，设计了IA-64（不兼容x86），但反响不好，因此采用了AMD64，并在此基础进行扩充，改名为x86_64，两种差别不大（现在用的intel&#x2F;amd的桌面级CPU基本上都是x86_64）</td></tr><tr><td align="center">ARM</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ARM-V8</td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>x86是一种CISC的指令集</p><p>非x86，一般是RISC指令集</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主流CPU指令集&quot;&gt;&lt;a href=&quot;#主流CPU指令集&quot; class=&quot;headerlink&quot; title=&quot;主流CPU指令集&quot;&gt;&lt;/a&gt;主流CPU指令集&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;架构&lt;/th&gt;
&lt;</summary>
      
    
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 39</title>
    <link href="https://kkkkkong.github.io/posts/4003.html"/>
    <id>https://kkkkkong.github.io/posts/4003.html</id>
    <published>2023-02-13T02:23:12.000Z</published>
    <updated>2023-02-13T02:38:15.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+深度优先搜索+递归</li></ol><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230213102600206.png" alt="image-20230213102600206" style="zoom: 33%;" /><p>图片来源：题解</p><p>使用一个数字，target做减法，不断减少直到target&lt;&#x3D;0，但这样做会出现重复路径，因此需要去重</p><p>去重方法为：同一层的节点，已经使用过的数字不在考虑，也即</p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230213102848235.png" alt="image-20230213102848235" style="zoom:33%;" /><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了75.79%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了82.05%的用户</p><p>通过测试用例：160 &#x2F; 160</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> len=candidates.length;</span><br><span class="line"></span><br><span class="line">        ArrayDeque&lt;Integer&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">        dfs(candidates,<span class="number">0</span>,len,path,target,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] candidates,<span class="type">int</span> begin,<span class="type">int</span> len,ArrayDeque&lt;Integer&gt; path,<span class="type">int</span> target,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;len;i++)&#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates,i,len,path,target-candidates[i],ans);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝之后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> len=candidates.length;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        ArrayDeque&lt;Integer&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">        dfs(candidates,<span class="number">0</span>,len,path,target,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] candidates,<span class="type">int</span> begin,<span class="type">int</span> len,ArrayDeque&lt;Integer&gt; path,<span class="type">int</span> target,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates,i,len,path,target-candidates[i],ans);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DragonOS 实时调度器相关API</title>
    <link href="https://kkkkkong.github.io/posts/56746.html"/>
    <id>https://kkkkkong.github.io/posts/56746.html</id>
    <published>2023-02-12T01:55:50.000Z</published>
    <updated>2023-02-12T12:20:33.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时进程调度器相关的api"><a href="#实时进程调度器相关的api" class="headerlink" title="实时进程调度器相关的api"></a>实时进程调度器相关的api</h1><p>&amp;emsp;&amp;emsp; RT（realtime scheduler），实时调度器。实时调度是为了完成实时处理任务而分配CPU的调度方法。</p><p>&amp;emsp;&amp;emsp;DragonOS的进程分为“实时进程”和“普通进程”两类；实时进程的优先级高于普通进程，如果当前的系统的执行队列中有“实时进程”，RT调度器会优先选择实时进程；如果队列中会有多个实时进程，调度器会选择优先级最高的实时进程来执行；</p><h2 id="1-RTQueue-介绍"><a href="#1-RTQueue-介绍" class="headerlink" title="1. RTQueue 介绍"></a>1. RTQueue 介绍</h2><p>&amp;emsp;&amp;emsp; RTQueue是用来存放state为running的实时进程的调度队列，每个CPU维护一个RTQueue，主要使用Vec作为主要存储结构来实现。</p><h3 id="1-1-主要函数"><a href="#1-1-主要函数" class="headerlink" title="1.1 主要函数"></a>1.1 主要函数</h3><ol><li><p><strong>enqueue():</strong> 将pcb入队列</p></li><li><p><strong>dequeue():</strong> 将pcb出队列</p></li></ol><h2 id="2-SchedulerRT-介绍"><a href="#2-SchedulerRT-介绍" class="headerlink" title="2. SchedulerRT 介绍"></a>2. SchedulerRT 介绍</h2><p>&amp;emsp;&amp;emsp; RT调度器类，主要实现了RT调度器类的初始化以及调度功能函数。</p><h3 id="2-1-主要函数"><a href="#2-1-主要函数" class="headerlink" title="2.1 主要函数"></a>2.1 主要函数</h3><ol><li><p><strong>pick_next_task_rt():</strong> 获取当前CPU中的第一个需要执行的RT pcb</p></li><li><p><strong>sched():</strong> 是对于Scheduler trait的sched()实现，是实时进程进行调度时的逻辑处理，该函数会返回接下来要执行的pcb，若没有符合要求的pcb，返回None</p></li><li><p><strong>enqueue():</strong> 同样是对于Scheduler trait的sched()实现，将一个pcb加入调度器的调度队列</p></li></ol><h3 id="2-2-内核调度策略"><a href="#2-2-内核调度策略" class="headerlink" title="2.2 内核调度策略"></a>2.2 内核调度策略</h3><p>目前在DragonOS中，主要的调度策略有SCHED_NORMAL 策略 | SCHED_FIFO 策略 | SCHED_RT 策略，具体的调度策略为：</p><ol><li><p><strong>SCHED_NORMAL 策略</strong>：SCHED_NORMAL 是“绝对公平调度策略”，该策略的进程使用CFS进行调度。</p></li><li><p><strong>SCHED_FIFO 策略</strong>：SCHED_FIFO是“实时进程调度策略”，这是一种先进先出的调度策略，该策略不涉及到CPU时间片机制，在没有更高优先级进程的前提下，只能等待其他进程主动释放CPU资源；在SCHED_FIFO策略中，被调度器调度运行的进程，其运行时长不受限制，可以运行任意长的时间。</p></li><li><p><strong>SCHED_RR 策略</strong>：SCHED_RR是“实时进程调度策略”，使用的是时间片轮转机制，对应进程的time_slice会在运行时减少，进程使用完CPU时间片后，会加入该CPU的与该进程优先级相同的执行队列中。同时，释放CPU资源，CPU的使用权会被分配给下一个执行的进程</p></li></ol><h2 id="3-Q-amp-A"><a href="#3-Q-amp-A" class="headerlink" title="3. Q&amp;A"></a>3. Q&amp;A</h2><ol><li><p>如何创建实时进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">pcb_name</span> =</span> kthread_run_rt(&amp;fn_name, <span class="literal">NULL</span>, <span class="string">&quot;test create rt pcb&quot;</span>);</span><br></pre></td></tr></table></figure><p>  其中kthread_run_rt，是创建内核实时线程的宏</p></li><li><p>pcb中涉及到实时进程的字段含义</p><ol><li><p><strong>policy：</strong>实时进程的策略，目前有：SCHED_FIFO与SCHED_RR</p></li><li><p><strong>priority:</strong> 实时进程的优先级，范围为0-99，数字越大，表示优先级越高</p></li><li><p><strong>rt_time_slice:</strong> 调度策略为 “RR” 的实时进程的时间片，默认为100，随着CPU运行而减少，在rt_time_slice为0时，将时间片赋初值并将该进程加入执行队列。</p></li></ol></li><li><p>如何实时进程存储队列</p><ul><li>目前是使用 Vec 来保存，因为具体实现的逻辑原因，目前的入队列和出队列都是对队尾的操作，因此会有如下现象：系统中有<strong>多个优先级相同的实时进程</strong>等待运行时，会出现<strong>饥饿现象</strong>，也即上一个因为时间片耗尽的进程会在下一个执行，造成同优先级等待的进程饥饿。</li></ul></li><li><p>TODO</p><ol><li><p>将存储实时进程的队列改为使用双向链表存储（或者其他办法解决上述的饥饿问题）</p></li><li><p>多核CPU的实时调度</p><ul><li>目前的实时调度是针对单核CPU的，需要实现多核CPU的实时调度</li></ul></li><li><p>RT进程带宽比</p><ul><li><p>由于实时任务的优先级高于普通任务，因而为了防止cpu消耗型的实时任务一直占用cpu引发其他任务”饥饿”的情况发生，linux内核采用了带宽限制手段来抑制实时任务的运行时间</p></li><li><p><strong>带宽限制：</strong>在任务调度中带宽限制就是指一定周期内一个队列上任务可运行的最大时间</p></li></ul></li><li><p>多个CPU之间实现<strong>负载均衡</strong></p><ul><li>最开始linux采用跟踪每个CPU的运行队列的负载情况来进行负载计算和决策</li><li>之后linux引入PELT <code>PELT, Per-entity load tracking </code>，通过跟踪每个调度实体的负载贡献来计算CPU负载，来进行调度决策</li></ul></li><li><p>更远：组调度</p><ul><li><strong>要解决的问题：</strong>A和B两个用户使用同一台机器，A用户16个进程，B用户2个进程，如果按照进程的个数来分配CPU资源，显然A用户会占据大量的CPU时间，这对于B用户是不公平的。组调度就可以解决这个问题，分别将A、B用户进程划分成组，并将两组的权重设置成占比50%即可。（调度时不再以进程为单位，而是以进程组作为调度实体）</li></ul></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时进程调度器相关的api&quot;&gt;&lt;a href=&quot;#实时进程调度器相关的api&quot; class=&quot;headerlink&quot; title=&quot;实时进程调度器相关的api&quot;&gt;&lt;/a&gt;实时进程调度器相关的api&lt;/h1&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp; RT（re</summary>
      
    
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="实时调度器" scheme="https://kkkkkong.github.io/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
  </entry>
  
</feed>
