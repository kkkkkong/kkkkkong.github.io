<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-01-04T06:09:14.216Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 283</title>
    <link href="https://kkkkkong.github.io/posts/15455.html"/>
    <id>https://kkkkkong.github.io/posts/15455.html</id>
    <published>2023-01-04T02:36:12.000Z</published>
    <updated>2023-01-04T06:09:14.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p> <a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解法，既然要求原地操作，那么我直接两层for循环</li></ol><blockquote><p>执行用时：565 ms, 在所有 Java 提交中击败了5.03%的用户</p><p>内存消耗：43.1 MB, 在所有 Java 提交中击败了20.29%的用户</p><p>通过测试用例：74 &#x2F; 74</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] swap(<span class="type">int</span> [] nums,<span class="type">int</span> i,<span class="type">int</span> j)&#123;</span><br><span class="line">        <span class="type">int</span> tmp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>能不能用O(n)的实现呢，想到了双指针实现，但是一时间没有捋顺代码，卡了半天，借鉴了别人的代码实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>,next=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 快慢指针,pre指向当前的0，next指向当前0后的第一个非零</span></span><br><span class="line">        <span class="keyword">while</span>(next&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[next]!=<span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,pre,next);</span><br><span class="line">                pre++;</span><br><span class="line">            &#125;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] swap(<span class="type">int</span> [] nums,<span class="type">int</span> i,<span class="type">int</span> j)&#123;</span><br><span class="line">        <span class="type">int</span> tmp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 1802</title>
    <link href="https://kkkkkong.github.io/posts/23037.html"/>
    <id>https://kkkkkong.github.io/posts/23037.html</id>
    <published>2023-01-04T02:11:30.000Z</published>
    <updated>2023-01-04T02:17:20.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p><p>nums.length &#x3D;&#x3D; n<br>nums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n<br>abs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1<br>nums 中所有元素之和不超过 maxSum<br>nums[index] 的值被 最大化<br>返回你所构造的数组中的 nums[index] 。</p><p>注意：abs(x) 等于 x 的前提是 x &gt;&#x3D; 0 ；否则，abs(x) 等于 -x 。</p><p><a href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/">1802. 有界数组中指定下标处的最大值 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>自己想的，没有什么章法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> maxSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==maxSum)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="type">int</span> nowSum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 一个较小值，通过平均值计算，比平均值小n的数字一定是小于结果值的，因此设置所有数字都是rev</span></span><br><span class="line">        <span class="type">int</span> rev=maxSum/n-n;</span><br><span class="line">        <span class="keyword">if</span>(rev&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 当maxsum较大时，设置一个基值，相当于剪枝</span></span><br><span class="line">            nowSum+=rev*n+<span class="number">1</span>;</span><br><span class="line">            res=rev+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// rev小于0，表示maxsum不是很大</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res=<span class="number">2</span>;</span><br><span class="line">            nowSum=n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nowSum&lt;maxSum)&#123;</span><br><span class="line">            <span class="type">int</span> left=index&gt;num?num:index;</span><br><span class="line">            <span class="type">int</span> right=(index+num)&gt;(n-<span class="number">1</span>)?(n-<span class="number">1</span>-index):(num);</span><br><span class="line">            nowSum+=left+right+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nowSum&gt;maxSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 </summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 136</title>
    <link href="https://kkkkkong.github.io/posts/3944.html"/>
    <id>https://kkkkkong.github.io/posts/3944.html</id>
    <published>2023-01-03T10:58:44.000Z</published>
    <updated>2023-01-03T11:02:31.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚好最近写项目用到了异或运算，一下子就想到了妙解，不然这个题要费一阵子劲</p><blockquote><p>异或运算：各个位上，相同为0，不同为1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a:nums)&#123;</span><br><span class="line">            result^=a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2042</title>
    <link href="https://kkkkkong.github.io/posts/8062.html"/>
    <id>https://kkkkkong.github.io/posts/8062.html</id>
    <published>2023-01-03T10:39:19.000Z</published>
    <updated>2023-01-03T10:53:23.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。</p><p>示例，”a puppy has 2 eyes 4 legs” 是一个由 7 个 token 组成的句子：”2” 和 “4” 是数字，其他像 “puppy” 这样的 tokens 属于单词。<br>给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。</p><p>如果满足题目要求，返回 true ，否则，返回 false 。</p><p><a href="https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/">2042. 检查句子中的数字是否递增 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>以后要仔细读题了，把简单题做复杂了</p></blockquote><p>这题没有看到数字的限制，自然而然的想到有些数字会超出int的范围（如 &gt;2147483647的数字），然后就写了个比较的函数，后来看见了题目后面的条件</p><ol><li>使用split的方式</li></ol><p><strong>98 &#x2F; 98</strong> 个通过测试用例</p><p>状态：<em>通过</em></p><p>执行用时: <strong>4 ms</strong></p><p>内存消耗: <strong>39.6 MB</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areNumbersAscending</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String [] array=s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        String tmp=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String a:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isNum(a))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isBig(a,tmp))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp=a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;s.charAt(<span class="number">0</span>)&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果a大于b，返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBig</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> a_len=a.length(),b_len=b.length();</span><br><span class="line">        System.out.println(a_len);</span><br><span class="line">        <span class="keyword">if</span>(a_len&gt;b_len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a_len&lt;b_len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a_len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a.charAt(i)&gt;b.charAt(i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a.charAt(i)&lt;b.charAt(i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 相等返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2. </p><p>执行用时：1 ms, 在所有 Java 提交中击败了89.21%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了56.43%的用户</p><p>通过测试用例：98 &#x2F; 98</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areNumbersAscending</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String [] array=s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        String tmp=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String a:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isNum(a))&#123;</span><br><span class="line">                <span class="type">int</span> now=Integer.parseInt(a);</span><br><span class="line">                <span class="keyword">if</span>(now&lt;=pre)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre=now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;s.charAt(<span class="number">0</span>)&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自己切分字符串，更快</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 20</title>
    <link href="https://kkkkkong.github.io/posts/39266.html"/>
    <id>https://kkkkkong.github.io/posts/39266.html</id>
    <published>2023-01-02T12:29:57.000Z</published>
    <updated>2023-01-02T12:53:09.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用栈辅助存储左括号，来进行匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()%<span class="number">2</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> a=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="string">&#x27;&#123;&#x27;</span>||a==<span class="string">&#x27;[&#x27;</span>||a==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stack.pop()!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stack.pop()!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stack.pop()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完通过后，看了别人的解法，可以说是相当简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt;stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1801</title>
    <link href="https://kkkkkong.github.io/posts/22717.html"/>
    <id>https://kkkkkong.github.io/posts/22717.html</id>
    <published>2023-01-02T12:01:58.000Z</published>
    <updated>2023-01-02T12:04:50.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二维整数数组 orders ，其中每个 orders[i] &#x3D; [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。</p><p>订单类型 orderTypei 可以分为两种：</p><p>0 表示这是一批采购订单 buy<br>1 表示这是一批销售订单 sell<br>注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><p>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。<br>反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。</p><p><a href="https://leetcode.cn/problems/number-of-orders-in-the-backlog/">1801. 积压订单中的订单总数 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>采用优先级队列解决，但由于对于这里不太熟，所以参考了解析</p><p>按照题目描述的思路，主要是捋顺了比较的逻辑，加上清楚优先级队列的使用；这题可以做出来</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfBacklogOrders</span><span class="params">(<span class="type">int</span>[][] orders)</span> &#123; </span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; buyOrders=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b[<span class="number">0</span>]-a[<span class="number">0</span>]);</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; sellOrders=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> [] order:orders)&#123;</span><br><span class="line">            <span class="type">int</span> price=order[<span class="number">0</span>],amount=order[<span class="number">1</span>],orderType=order[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 采购订单</span></span><br><span class="line">            <span class="keyword">if</span>(orderType==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(amount&gt;<span class="number">0</span>&amp;&amp;!sellOrders.isEmpty()&amp;&amp;sellOrders.peek()[<span class="number">0</span>]&lt;=price)&#123;</span><br><span class="line">                    <span class="comment">// 取出销售订单中的最低销售订单</span></span><br><span class="line">                    <span class="type">int</span>[] sellOrder=sellOrders.poll();</span><br><span class="line">                    <span class="type">int</span> dellAmount=amount&gt;sellOrder[<span class="number">1</span>]?sellOrder[<span class="number">1</span>]:amount;</span><br><span class="line">                    amount-=dellAmount;</span><br><span class="line">                    sellOrder[<span class="number">1</span>]-=dellAmount;</span><br><span class="line">                    <span class="comment">// 如果最低销售订单未耗尽</span></span><br><span class="line">                    <span class="keyword">if</span>(sellOrder[<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        sellOrders.offer(sellOrder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果耗尽了所有的低价订单，仍有部分未采购，则加入购买的积压订单</span></span><br><span class="line">                <span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    buyOrders.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;price,amount&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 销售订单</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(amount&gt;<span class="number">0</span>&amp;&amp;!buyOrders.isEmpty()&amp;&amp;buyOrders.peek()[<span class="number">0</span>]&gt;=price)&#123;</span><br><span class="line">                    <span class="comment">// 取出采购订单中的最高订单</span></span><br><span class="line">                    <span class="type">int</span>[] buyOrder=buyOrders.poll();</span><br><span class="line">                    <span class="type">int</span> dellAmount=amount&gt;buyOrder[<span class="number">1</span>]?buyOrder[<span class="number">1</span>]:amount;</span><br><span class="line">                    amount-=dellAmount;</span><br><span class="line">                    buyOrder[<span class="number">1</span>]-=dellAmount;</span><br><span class="line">                    <span class="keyword">if</span>(buyOrder[<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        buyOrders.offer(buyOrder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    sellOrders.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;price,amount&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(PriorityQueue&lt;<span class="type">int</span>[]&gt; pq: Arrays.asList(buyOrders,sellOrders))&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span>[] order=pq.poll();</span><br><span class="line">                res=(res+order[<span class="number">1</span>])%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个二维整数数组 orders ，其中每个 orders[i] &amp;#x3D; [pricei, amounti, ord</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2351</title>
    <link href="https://kkkkkong.github.io/posts/36559.html"/>
    <id>https://kkkkkong.github.io/posts/36559.html</id>
    <published>2023-01-01T00:52:11.000Z</published>
    <updated>2023-01-01T01:10:36.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>简单题不简单</p><p>给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。</p><p>注意：</p><p>如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。<br>s 包含至少一个出现两次的字母。</p><p><a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">2351. 第一个出现两次的字母 - 力扣（LeetCode）</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>最开始想用hashmap解决，因为用的比较熟悉了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">repeatedCharacter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>后来发现，这东西用hashset更合适，因为只需要存key，value没有实际意义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">repeatedCharacter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashSet set=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>看了解析之后，发现可以用位运算，通过int类型的后26位，模拟26个字母，对应某位为1则 &amp;的结果不为0，因此可以找到第一个元素；否则将该元素 | 运算后将对应位置为1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">repeatedCharacter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> letter=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">int</span> l=s.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>((letter&amp;(<span class="number">1</span>&lt;&lt;l))!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                letter=letter|<span class="number">1</span>&lt;&lt;l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;简单题不简单&lt;/p&gt;
&lt;p&gt;给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 11</title>
    <link href="https://kkkkkong.github.io/posts/43427.html"/>
    <id>https://kkkkkong.github.io/posts/43427.html</id>
    <published>2022-12-31T11:11:30.000Z</published>
    <updated>2022-12-31T11:24:23.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><a href="https://leetcode.cn/problems/container-with-most-water/">题目链接11. 盛最多水的容器 - 力扣（LeetCode）</a></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li><p>拿过来一看，最先想到的就是暴力解法，两层for循环遍历，寻找最大元素，但作为中等题，果然是超时的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>;left&lt;height.length-<span class="number">1</span>;left++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> right=left+<span class="number">1</span>;right&lt;height.length;right++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span>(height[right]&gt;height[left]?height[left]:height[right])*(right-left);</span><br><span class="line">                max=max&gt;tmp?max:tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暴力不行，然后考虑采用其他方式，按照提示，考虑采用双指针，分别指向开头和结尾，从两边向中间缩，但怎么移动指针是关键，面积是容器底[1]*两边中较小的一方[2]，底随着移动不断缩小，因此只有增大[2]，短板效应，需要将[2]中较小的一方扩大，才能扩大，因此较小的一方移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> tmp=(height[right]&gt;height[left]?height[left]:height[right])*(right-left);</span><br><span class="line">            max=max&gt;tmp?max:tmp;</span><br><span class="line">            <span class="keyword">if</span>(height[right]&gt;height[left])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, heig</summary>
      
    
    
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>坦格利安家族人物关系</title>
    <link href="https://kkkkkong.github.io/posts/9659.html"/>
    <id>https://kkkkkong.github.io/posts/9659.html</id>
    <published>2022-12-11T13:27:04.000Z</published>
    <updated>2022-12-11T13:56:34.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="龙之家族人物关系"><a href="#龙之家族人物关系" class="headerlink" title="龙之家族人物关系"></a>龙之家族人物关系</h1><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215241372.png" alt="image-20221211215241372"  /><blockquote><p>最近在追剧权游前传-《龙之家族》，看了第一季之后意犹未尽，索性找来原著小说，原著中龙家的关系比较复杂，所以画个个图方便自己屡清关系（hh，看小说还记笔记）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="流程图"></p><p>图为截止坦格利安王朝史·第一卷的坦格利安家族的主要人物关系</p><p>其中人物名字上方为其所御之龙的名字</p><p>红色箭头代表七大王国的王位继承顺序</p><h3 id="放几张剧照吧"><a href="#放几张剧照吧" class="headerlink" title="放几张剧照吧"></a>放几张剧照吧</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215410115.png" alt="image-20221211215410115"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215446184.png" alt="image-20221211215446184"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215508154.png" alt="image-20221211215508154"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221211215602968.png" alt="image-20221211215602968"></p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://weread.qq.com/book-detail?type=1&senderVid=328921405&v=02f325c071aebcf302f6772&wtheme=white&wfrom=app&wvid=328921405&scene=bottomSheetShare">血与火：坦格利安王朝史·第一卷（HBO 热播剧《龙之家族》影视原著小说，奇幻巨著冰与火之歌前传）》乔治·R.R.马丁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;龙之家族人物关系&quot;&gt;&lt;a href=&quot;#龙之家族人物关系&quot; class=&quot;headerlink&quot; title=&quot;龙之家族人物关系&quot;&gt;&lt;/a&gt;龙之家族人物关系&lt;/h1&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Kong-PR/Typ</summary>
      
    
    
    
    
    <category term="小说" scheme="https://kkkkkong.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="https://kkkkkong.github.io/posts/953.html"/>
    <id>https://kkkkkong.github.io/posts/953.html</id>
    <published>2022-11-28T11:21:24.000Z</published>
    <updated>2022-11-28T11:37:58.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git常用命令总结"><a href="#git常用命令总结" class="headerlink" title="git常用命令总结"></a>git常用命令总结</h2><blockquote><p>总结我常用的git命令，不然每次想不起来了还要去找</p><p>持续更新…</p></blockquote><ul><li>git add ：添加文件到缓存，常用git add . 添加所有文件夹</li><li>git status ：查看项目内文件的状态</li><li>git diff ：查看未缓存的更改</li><li>git commit ：提交命令，<ul><li>常用git commit -m “update内容”</li><li>偷懒可以git commit -am “update内容”，这样不需要每次都add</li></ul></li><li>git push originname a:b ：将本地的a分支推送到originname 的b上去</li><li>git pull originname a ：将远程originname分支的a拉取到本地当前分支上</li><li>git reset –hard “commitID” ：回退到某个版本</li><li>git reset HEAD test.txt ：取消已缓存的test.txt文件</li><li>git branch ：查看本地的分支<ul><li>git branch newbranch ：创建分支newbranch</li></ul></li><li>git checkout branchname：切换到branchname 分支</li><li>git merge branchname ：将任意分支合并到到当前分支中</li><li>git branch -d branchname)：删除某个分支</li><li>git remote add urlname urllink：添加新的远程仓库地址，一般一个项目托管到不同平台用得到</li><li>git remote：查看当前的远程仓库</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git常用命令总结&quot;&gt;&lt;a href=&quot;#git常用命令总结&quot; class=&quot;headerlink&quot; title=&quot;git常用命令总结&quot;&gt;&lt;/a&gt;git常用命令总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;总结我常用的git命令，不然每次想不起来了还要去找&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="git" scheme="https://kkkkkong.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>酒香归纳</title>
    <link href="https://kkkkkong.github.io/posts/57461.html"/>
    <id>https://kkkkkong.github.io/posts/57461.html</id>
    <published>2022-11-27T10:23:39.000Z</published>
    <updated>2022-12-15T01:34:58.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="酒香归纳"><a href="#酒香归纳" class="headerlink" title="酒香归纳"></a>酒香归纳</h2><blockquote><p>偶尔会接触一些酒，但总是听说各种香型，但都没太深的了解，这里先记录一下，以后有机会都尝一尝</p></blockquote><h3 id="香型及其特征"><a href="#香型及其特征" class="headerlink" title="香型及其特征"></a>香型及其特征</h3><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127182513378.png" alt="image-20221127182513378" style="zoom:50%;" /><h3 id="各香型代表酒"><a href="#各香型代表酒" class="headerlink" title="各香型代表酒"></a>各香型代表酒</h3><ul><li>酱香型 茅台</li><li>清香型 汾酒<ul><li>42度的汾酒喝了半斤，入口微微辣，第二天上午也迷瞪的</li></ul></li><li>浓香型 五粮液、泸州老窖、剑南春<ul><li>泸州老窖52度喝了塑料杯一杯半，入口比较辣，晚上感觉浑身暖和，第二天毫无感觉</li></ul></li><li>凤香型 西凤酒<ul><li>45度西凤酒喝了三两，过了太久，记不得啥情况了</li></ul></li><li>董香型&#x2F;药香型 董酒</li><li>米香型&#x2F;蜜香型 桂林三花</li><li>芝麻香型 景芝酒</li><li>豉香型 佛山石湾玉冰烧</li><li>兼香型也叫浓酱兼香型白酒 白云边<ul><li>喝了两塑料杯53度白云边，酒比较好入口，第二天早上起来微微有点头疼</li></ul></li><li>老白干 衡水老白干</li><li>馥郁香 酒鬼酒</li><li>特香型</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;酒香归纳&quot;&gt;&lt;a href=&quot;#酒香归纳&quot; class=&quot;headerlink&quot; title=&quot;酒香归纳&quot;&gt;&lt;/a&gt;酒香归纳&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;偶尔会接触一些酒，但总是听说各种香型，但都没太深的了解，这里先记录一下，以后有机会都尝一尝&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="非技术" scheme="https://kkkkkong.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自动部署hexo博客</title>
    <link href="https://kkkkkong.github.io/posts/32022.html"/>
    <id>https://kkkkkong.github.io/posts/32022.html</id>
    <published>2022-11-26T13:30:25.000Z</published>
    <updated>2022-11-27T03:06:05.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="懒人脚本"><a href="#懒人脚本" class="headerlink" title="懒人脚本"></a>懒人脚本</h2><p>每次写完博客，都要输入一串机械化的命令，很无聊，索性写个bat脚本，具体内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">hexo clean&amp;&amp;hexo g&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source&amp;&amp;<span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p>然后以bat的格式保存在博客目录下，点击执行即可（比如这篇博客就是这么发布的）</p><h4 id="指令解释："><a href="#指令解释：" class="headerlink" title="指令解释："></a>指令解释：</h4><ol><li><code>@echo off</code> ：关闭cmd指令的回显</li><li><code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code> ：hexo的指令，分别是：<ol><li><code>hexo clean</code>：清除缓存文件 <code>db.json</code> 和已生成的静态文件 <code>public</code></li><li><code>hexo g</code>：生成网站静态文件到默认设置的 <code>public</code> 文件夹</li><li><code>hexo d</code>：自动生成网站静态文件，并部署到设定的仓库</li></ol></li><li><code>git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source</code>，是git指令</li><li><code>pause</code>：暂停执行的语句</li></ol><blockquote><p>其中的远程仓库分支source是github的项目分支之一，hexo里设置在<code>hexo d</code>后将代码部署到master分支中，我设置了source分支用来保存其他代码（当然不包括一些静态代码和node的代码），防止换了设备之后会丢失内容</p><p>方便好用，强烈推荐</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;懒人脚本&quot;&gt;&lt;a href=&quot;#懒人脚本&quot; class=&quot;headerlink&quot; title=&quot;懒人脚本&quot;&gt;&lt;/a&gt;懒人脚本&lt;/h2&gt;&lt;p&gt;每次写完博客，都要输入一串机械化的命令，很无聊，索性写个bat脚本，具体内容如下：&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
    <category term="hexo博客" scheme="https://kkkkkong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>实时调度器</title>
    <link href="https://kkkkkong.github.io/posts/46423.html"/>
    <id>https://kkkkkong.github.io/posts/46423.html</id>
    <published>2022-11-26T12:30:23.000Z</published>
    <updated>2022-11-27T03:16:04.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LINUX调度器关系图"><a href="#LINUX调度器关系图" class="headerlink" title="LINUX调度器关系图"></a>LINUX调度器关系图</h2><blockquote><p>所谓调度，就是按照某种调度的算法，从<strong>进程的就绪队列中选取进程分配CPU</strong>，主要是协调对CPU等的资源使用。进程调度的目标是最大限度利用CPU时间</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127111427338.png" alt="image-20221127111427338" style="zoom: 33%;" /><p>linux里的调度器</p><p><code>RT调度器， rt_sched_class</code>：实时调度器，为每个优先级维护一个队列</p><p><code>CFS调度器， cfs_sched_class</code>：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念，采用红黑树实现进程实体的存放；</p><h2 id="调度策略FIFO、RR"><a href="#调度策略FIFO、RR" class="headerlink" title="调度策略FIFO、RR"></a>调度策略FIFO、RR</h2><p>linux的进程分为两大类：<strong>实施进程和普通进程</strong></p><p>二者的根本不同在于：如果系统中有一个实时进程可以运行，那么调度器总是会选择它，除非另有一个优先级更高的实时进程</p><p><strong>实时进程</strong>分为两种策略进行调度：</p><p><strong>SCHED_FIFO：</strong>没有时间片，在被调度器选择之后，可以运行任意长时间。</p><p><strong>SCHED_RR：</strong>有时间片，其值在进程运行时会减少。在所有的时间段都到期后，则该值重置为初始值，而进程则置于队列末尾。这确保了在有几个优先级相同的SCHED_RR进程的情况下，它们总是依次执行。</p><h2 id="runqueue-运行队列"><a href="#runqueue-运行队列" class="headerlink" title="runqueue 运行队列"></a>runqueue 运行队列</h2><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/asynccode" alt="img" style="zoom:50%;" /><ul><li><p>每个CPU都有一个运行队列，每个调度器都作用于运行队列；</p></li><li><p>分配给CPU的task，作为调度实体加入到运行队列中；</p></li></ul><p><strong>rt_rq的结构</strong></p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127111507059.png" alt="image-20221127111507059" style="zoom: 33%;" /><blockquote><p>这里每一个CPU的运行队列rq内都有一个实时进程运行队列rt_rq，制定了优先级链表，链表个数为优先级个数，每个链表存放对应就绪状态的进程实体</p></blockquote><h2 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h2><ol><li>enqueue_task_rt(struct rq *rq, struct process_control_block *p, int flags)</li></ol><blockquote><p>将进程添加到对应rt_rq的优先级的队列中去</p></blockquote><ol><li>dequeue_task_rt(struct rq *rq, struct process_control_block *p, int flags)</li></ol><blockquote><p>从rt_rq的优先级队列中取出某一个进程</p></blockquote><ol><li>pick_next_task_rt()</li></ol><blockquote><p>从优先级队列中取出当前优先级最高的进程</p></blockquote><ol><li>sched_rt()</li></ol><blockquote><ul><li><p>此函数是进程调度的核心函数</p></li><li><p>核心逻辑：选择另一个进程来替换掉当前的运行进程。具体替换进程的选择是通过pick_next_task_rt()函数来实现的</p></li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20221127111532683.png" alt="image-20221127111532683" style="zoom: 67%;" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.man7.org/linux/man-pages/man7/sched.7.html">sched(7) - Linux manual page (man7.org)</a></p><p><a href="https://www.cnblogs.com/LoyenWang/p/12249106.html">【原创】（一）Linux进程调度器-基础 - LoyenWang - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/arnoldlu/p/9025981.html">Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验 - ArnoldLu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/hellokitty2/p/14199741.html">RT调度学习笔记（1） - Hello-World3 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/sucjhwaxp/article/details/106602613">(15条消息) Kernel Scheduler学习之五：RT 调度器_sucjhwaxp的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LINUX调度器关系图&quot;&gt;&lt;a href=&quot;#LINUX调度器关系图&quot; class=&quot;headerlink&quot; title=&quot;LINUX调度器关系图&quot;&gt;&lt;/a&gt;LINUX调度器关系图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所谓调度，就是按照某种调度的算法，从&lt;st</summary>
      
    
    
    
    
    <category term="实时调度器" scheme="https://kkkkkong.github.io/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
    <category term="linux" scheme="https://kkkkkong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>市场体制下企业定价方法</title>
    <link href="https://kkkkkong.github.io/posts/25422.html"/>
    <id>https://kkkkkong.github.io/posts/25422.html</id>
    <published>2022-11-23T11:01:59.000Z</published>
    <updated>2022-11-27T03:06:05.187Z</updated>
    
    <content type="html"><![CDATA[<p>在市场经济中，卖方才有定价权，因此需要考虑主要价格制定与变动的是卖方</p><p>现有的企业定价方式有三类：成本导向、需求导向和竞争导向</p><h3 id="一、成本导向定价法"><a href="#一、成本导向定价法" class="headerlink" title="一、成本导向定价法"></a><strong>一、成本导向定价法</strong></h3><blockquote><p>以营销产品的成本为主要依据制定价格的方法统称为成本导向定价法,这是最简单、应用相当广泛的一种定价方法。</p></blockquote><ol><li><p>**总成本定价法:**成本加成,目标利润</p><ol><li>成本加成定价法（cost-plus pricing），即按产品单位成本加上一定比例的毛利定出销售价。 　其计算公式为：P&#x3D;c×(1+r) 　P—商品的单价 　c—商品的单位总成本 　r—商品的加成率</li><li>目标利润定价法，是根据企业总成本和预期销售量，确定一个目标利润率，并以次作为定价的标准。 　其计算公式为：单位商品价格&#x3D;总成本×（1+目标利润率）&#x2F; 预计销量</li></ol><p> 　　</p></li><li><p><strong>边际成本定价法：</strong>边际成本是企业每增以单位产品所必须支付的成本，采用这种方式暂不考虑固定成本，以边际成本加一定的利润作为最终价格，可以帮助企业迅速打开市场。</p></li><li><p><strong>盈亏平衡定价</strong>：考虑到销售额变化后，成本也在发生变化，这种方法是运用损益平衡原理实行的一种保本定价法。 　其公式是： 　盈亏平衡点销售量&#x3D;固定成本&#x2F;单位—单位变动成本 　盈亏平衡点销售额&#x3D;固定成本&#x2F;1—单位变动成本率</p></li></ol><h3 id="二、需求导向定价法"><a href="#二、需求导向定价法" class="headerlink" title="二、需求导向定价法"></a><strong>二、需求导向定价法</strong></h3><blockquote><p>需求导向定价法是指根据市场需求状况和消费者对产品的感觉差异来确定价格的定价方法。 它包括以下三种</p></blockquote><ol><li><p><strong>认知导向定价法：</strong>是根据消费者对企业提供的产品价值的主观评判来制定价格的一种定价方法。</p></li><li><p><strong>逆向定价法：</strong>它是指依据消费者能够接受的最终销售价格，考虑中间商的成本及正常利润后，逆向推算出中间商的批发价和生产企业的出产价格。 　可通过公式计算价格：出厂价格&#x3D;市场可零售价格×（1—批零差率）×（1—进销差率）</p></li><li><p><strong>习惯定价法：</strong>是按照市场长期以来行成的习惯价格定价。</p></li></ol><h3 id="三、竞争导向定价法"><a href="#三、竞争导向定价法" class="headerlink" title="三、竞争导向定价法"></a><strong>三、竞争导向定价法</strong></h3><blockquote><p>竞争导向定价法是企业通过研究竞争对手的生产条件、服务状况、价格水平等因素，依据自身的竞争实力，参考成本和供求状况来确定商品价格。以市场上竞争者的类似产品的价格作为本企业产品定价的参照系的一种定价方法 这种定价方法主要有3方面特点。竞争导向定价主要包括随行就市定价法、产品差别定价法和密封投标定价法。</p></blockquote><ol><li><p>**随行就市定价法:**在垄断竞争和完全竞争的市场结构条件下，任何一家企业都无法凭借自己的实力而在市场上取得绝对的优势，为了避免竞争特别是价格竞争带来的损失，大多数企业都采用随行就市定价法，即将本企业某产品价格保持在市场平均价格水平上，利用这样的价格来获得平均报酬。此外，采用随行就市定价法，企业就不必去全面了解消费者对不同价差的反应，也不会引起价格波动。</p></li><li><p>**产品差别定价法:**产品差别定价法是指企业通过不同营销努力，使同种同质的产品在消费者心目中树立起不同的产品形象，进而根据自身特点，选取低于或高于竞争者的价格作为本企业产品价格。因此，产品差别定价法是一种进攻性的定价方法。</p></li><li><p>**密封投标定价法:**在国内外，许多大宗商品、原材料、成套设备和建筑工程项目的买卖和承包、以及出售小型企业等，往往采用发包人招标、承包人投标的方式来选择承包者，确定最终承包价格。一般来说，招标方只有一个，处于相对垄断地位，而投标方有多个，处于相互竞争地位。标的物的价格由参与投标的各个企业在相互独立的条件下来确定。在买方招标的所有投标者中，报价最低的投标者通常中标，它的报价就是承包价格。这样一种竞争性的定价方法就称密封投标定价法。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在市场经济中，卖方才有定价权，因此需要考虑主要价格制定与变动的是卖方&lt;/p&gt;
&lt;p&gt;现有的企业定价方式有三类：成本导向、需求导向和竞争导向&lt;/p&gt;
&lt;h3 id=&quot;一、成本导向定价法&quot;&gt;&lt;a href=&quot;#一、成本导向定价法&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="市场经济" scheme="https://kkkkkong.github.io/tags/%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E/"/>
    
    <category term="定价方法" scheme="https://kkkkkong.github.io/tags/%E5%AE%9A%E4%BB%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最优化问题</title>
    <link href="https://kkkkkong.github.io/posts/31098.html"/>
    <id>https://kkkkkong.github.io/posts/31098.html</id>
    <published>2022-11-21T01:05:25.000Z</published>
    <updated>2022-11-27T03:06:05.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h1><p>定义：在给定的约束条件下，选择最优的参数和方案，使得目标函数最大化&#x2F;最小化的问题</p><p>分类：</p><ul><li>根据约束条件不同，分为<ul><li>无约束问题</li><li>约束最优问题<ul><li>等式约束最优问题</li><li>不等式约束最优问题</li><li>混合约束优化问题</li></ul></li></ul></li><li>根据目标函数的状态，分为<ul><li>连续最优化问题：决策变量取值连续<ul><li>光滑最优化问题：函数连续可微<ul><li>线性规划</li><li>非线性规划</li></ul></li><li>非光滑优化</li></ul></li><li>离散最优化问题：决策标量取值离散<ul><li>整数规划、资源配置、油路问题生产安排等</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最优化问题&quot;&gt;&lt;a href=&quot;#最优化问题&quot; class=&quot;headerlink&quot; title=&quot;最优化问题&quot;&gt;&lt;/a&gt;最优化问题&lt;/h1&gt;&lt;p&gt;定义：在给定的约束条件下，选择最优的参数和方案，使得目标函数最大化&amp;#x2F;最小化的问题&lt;/p&gt;
&lt;p&gt;分类：&lt;/</summary>
      
    
    
    
    
    <category term="最优化问题" scheme="https://kkkkkong.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks</title>
    <link href="https://kkkkkong.github.io/posts/40422.html"/>
    <id>https://kkkkkong.github.io/posts/40422.html</id>
    <published>2022-07-24T04:00:00.000Z</published>
    <updated>2022-11-27T03:06:05.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Coding-based-Distributed-Data-Shufflfling-for-Low-Communication-Cost-in-DataCenter-Networks"><a href="#Coding-based-Distributed-Data-Shufflfling-for-Low-Communication-Cost-in-DataCenter-Networks" class="headerlink" title="Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks"></a>Coding based Distributed Data Shufflfling for Low Communication Cost in DataCenter Networks</h3><h3 id="基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌"><a href="#基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌" class="headerlink" title="基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌"></a>基于编码的在数据中心网络中实现低通信成本的分布式数据洗牌</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>分布式机器学习框架在实际使用中依然存在许多挑战与问题，训练数据样本分布和训练数据样本输入顺序是影响机器学习模型收敛效果的重要因素。全局数据重排能够为分布式机器学习提供更接近于单机的机器学习的数据重排效果。然而其会带来巨大的网络开销</p><p>为了让全局数据重排能够应用到实际的分布式机器学习中，目前存在一些使用编码的方法来降低其网络资源开销。</p><p>但目前的基于编码的网络传输优化方法都假设存在一台拥有无限存储能力的机器<br>存储了整个训练样本集中的所有样本，并且由这台机器负责所有样本数据的发送工作，<br>而其他机器不具备发送数据的功能。</p><h3 id="系统模型和问题制定"><a href="#系统模型和问题制定" class="headerlink" title="系统模型和问题制定"></a>系统模型和问题制定</h3><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195221509.png" alt="image-20220724195221509"></p><p>基于上述模型优化</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195252224.png" alt="image-20220724195252224"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195300494.png" alt="image-20220724195300494"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195308972.png" alt="image-20220724195308972"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195316646.png" alt="image-20220724195316646"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195326229.png" alt="image-20220724195326229"></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195336124.png" alt="image-20220724195336124"></p><h3 id="方法制定"><a href="#方法制定" class="headerlink" title="方法制定"></a>方法制定</h3><p>Distributed Coded Shuffling（DCS算法）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724195407995.png" alt="image-20220724195407995"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Coding-based-Distributed-Data-Shufflfling-for-Low-Communication-Cost-in-DataCenter-Networks&quot;&gt;&lt;a href=&quot;#Coding-based-Distributed-Data</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="算力网络" scheme="https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"/>
    
    <category term="边缘博弈" scheme="https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>摩斯电码快速记忆</title>
    <link href="https://kkkkkong.github.io/posts/58667.html"/>
    <id>https://kkkkkong.github.io/posts/58667.html</id>
    <published>2022-07-24T04:00:00.000Z</published>
    <updated>2022-11-27T03:06:05.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摩斯电码快速记忆"><a href="#摩斯电码快速记忆" class="headerlink" title="摩斯电码快速记忆"></a>摩斯电码快速记忆</h3><p>之前无聊的时候翻知乎，看到一个有关摩斯电码的讨论，感觉其中一个回答对记忆莫斯电码十分有帮助，在这里分享下</p><h4 id="原电码表"><a href="#原电码表" class="headerlink" title="原电码表"></a>原电码表</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724150944205.png" alt="image-20220724150944205"></p><h4 id="通过图像记忆"><a href="#通过图像记忆" class="headerlink" title="通过图像记忆"></a>通过图像记忆</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724151014928.png" alt="image-20220724151014928"></p><p>有那么两天我甚至感觉自己精通了，勤加练习不难</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;摩斯电码快速记忆&quot;&gt;&lt;a href=&quot;#摩斯电码快速记忆&quot; class=&quot;headerlink&quot; title=&quot;摩斯电码快速记忆&quot;&gt;&lt;/a&gt;摩斯电码快速记忆&lt;/h3&gt;&lt;p&gt;之前无聊的时候翻知乎，看到一个有关摩斯电码的讨论，感觉其中一个回答对记忆莫斯电码十分有帮助，</summary>
      
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="摩斯电码" scheme="https://kkkkkong.github.io/tags/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments</title>
    <link href="https://kkkkkong.github.io/posts/37834.html"/>
    <id>https://kkkkkong.github.io/posts/37834.html</id>
    <published>2022-07-22T04:00:00.000Z</published>
    <updated>2022-11-27T03:06:05.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Partitioning-Stateful-Data-Stream-Applications-in-Dynamic-Edge-Cloud-Environments"><a href="#Partitioning-Stateful-Data-Stream-Applications-in-Dynamic-Edge-Cloud-Environments" class="headerlink" title="Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments"></a>Partitioning Stateful Data Stream Applications in Dynamic Edge Cloud Environments</h3><h3 id="动态边缘云环境下的有状态数据流应用的划分"><a href="#动态边缘云环境下的有状态数据流应用的划分" class="headerlink" title="动态边缘云环境下的有状态数据流应用的划分"></a>动态边缘云环境下的有状态数据流应用的划分</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>计算分区是一种通过选择性地将一些计算从移动设备卸载到附近的边缘云来提高应用程序性能的重要技术。在动态环境中，边缘云的网络带宽可能会频繁变化，计算的划分需要相应地更新。分区的频繁更新导致了移动端和边缘云之间的高状态迁移成本。但是，现有的工作没有考虑状态迁移开销。因此，分区决策可能会导致重大的拥塞控制，并极大地增加整体完成时间。本文在考虑状态迁移开销的基础上，提出了一套基于网络带宽变化的分区更新算法。据我们所知，<strong>这是第一个针对动态环境中的有状态数据流应用程序进行计算分区的工作。这些算法旨在通过在动态边缘云环境中选择性迁移状态来减轻拥塞控制和最小化制造跨度</strong>。大量的仿真结果表明，该算法不仅可以选择性地迁移状态，而且在生成时间方面优于其他经典的基准算法。所提出的模型和算法将丰富有状态任务的调度理论，这是以前从未有过的研究。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>边缘计算是使云计算技术能够从传统的互联网数据中心到网络边缘进行低延迟数据访问和实时数据处理[7]。作为边缘计算资源的抽象，边缘云通常分布在离终端用户较近的地方，如蜂窝基站和无线局域网。边缘计算的一般形式包括 Cloudlets [9]和 Foglets [10] ，甚至还有一小群有限的设备[8]。与传统的云数据中心相比，边缘云更轻量级，资源受限[11]。随着边缘云在当今网络基础设施中的部署越来越多，计算分区被认为是一种有效的技术，通过选择性地将一些计算从移动设备卸载到附近的边缘云[4][12][18]来提高移动应用程序的性能</p><p>为了达到不同的目的，在计算分区方面存在许多相关的工作，比如减少执行时间，节省终端设备的能源消耗，以及云的数据传输开销。这些工作对应用程序有不同的建模方法。典型的应用程序模型包括面向过程程序的方法调用树、面向服务应用程序的服务调用图和面向数据流应用程序的数据流图。&#x2F;n在这些类型的应用程序中，数据流应用程序越来越受到关注，例如扩增实境和目标跟踪。应用程序由一组功能模块组成，数据流通过这些模块。数据流应用程序的分区旨在为每个传入的数据帧决定哪些函数在本地执行，哪些函数在边缘云中执行[4][12]。但是，现有的工作不考虑有状态数据流应用程序的分区。如果数据流应用程序包含有状态函数模块，我们将其定义为有状态应用程序。通过状态函数模块，如果一个数据帧流经它，那么在处理该模块的设备上将留下一个“足迹”。这个“内存占用”(也由状态命名)是下一个数据帧的处理所需要的。许多应用程序(如对象跟踪)都属于有状态应用程序。</p><p>对有状态数据流应用程序进行分区非常具有挑战性，尤其是在动态边缘云环境中，在这种环境中，到边缘云的网络连接经常发生变化，甚至可能发生断开连接。由于网络连接的动态性，应用程序的划分需要相应地更新，这将导致移动设备和边缘云之间的状态迁移。因此，我们需要通过选择性迁移状态来划分计算，以减轻网络拥塞。现有的计算划分工作考虑了应用程序的无状态功能模块。当它们应用于有状态应用程序的分区时，网络中会出现较高的状态迁移开销，这可能导致拥塞控制和应用程序的长时间完成。这就是为什么我们需要为有状态应用程序的分区特别设计新的方法，旨在平衡良好的分区和低完成时间以及网络上额外的状态迁移时间。</p><p>在本文中，我们开发了一套有效的算法来解决有状态数据流应用程序的划分问题，目的是通过选择性迁移 ing 状态来减少拥塞控制和最小化使用时间。特别地，我们设计了一种新的算法，即基于得分矩阵的启发式算法(SM-H)来解决一次性问题，该算法在边缘网络环境改变时更新当前到达数据帧的划分。SM-H 采用矩阵形式记录调整各模块执行位置的效益得分，然后始终选择得分最大的模块进行调整。调整是迭代进行的，直到没有一个模块得到正分，这意味着调整任何一个模块将导致完成时间的增加。在一次性 SM-H 算法的基础上，进一步推广到解决多步骤的分区问题。</p><p>我们通过大量的仿真对提出的算法进行评估，并将它们与几种基准方法进行比较，包括顺序调整(一种幼稚的贪婪启发式方法)、列表调度(一种经典的并行和分布式计算调度方法)、遗传算法等。结果表明，所提出的算法在制作跨度方面优于基准算法。我们将本文的贡献总结如下。</p><p>•据我们所知，我们是第一个研究有状态数据流应用程序分区问题的人。这些问题模型可以推广到分布式处理器上的有状态任务调度，这是目前在任务调度领域尚未研究的问题。&#x2F;n</p><p>•我们开发了一种新算法来划分有状态数据流应用程序。该算法丰富了有状态应用任务的调度理论和方法。&#x2F;n</p><p>•我们通过广泛的仿真对提出的算法进行了评估，结果表明，提出的 SM-H 算法在制作跨度方面优于基准算法。</p><h4 id="系统模型和问题制定"><a href="#系统模型和问题制定" class="headerlink" title="系统模型和问题制定"></a>系统模型和问题制定</h4><p>定义决策变量表示分配给状态迁移、网络传输的网络带宽，将最小化make-span制定为目标并表示，限制模块之间的依赖性定义，从而定义对状态迁移的限制、对网络带宽的限制</p><p>最终形成有状态的数据流应用程序计算分区问题(SCPP)，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Partitioning-Stateful-Data-Stream-Applications-in-Dynamic-Edge-Cloud-Environments&quot;&gt;&lt;a href=&quot;#Partitioning-Stateful-Data-Stream-Appli</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="算力网络" scheme="https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"/>
    
    <category term="边缘博弈" scheme="https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>基于博弈论的云/边缘计算资源分配与优化算法及应用</title>
    <link href="https://kkkkkong.github.io/posts/23505.html"/>
    <id>https://kkkkkong.github.io/posts/23505.html</id>
    <published>2022-07-22T04:00:00.000Z</published>
    <updated>2022-11-27T03:06:05.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于博弈论的云-x2F-边缘计算资源分配与优化算法及应用"><a href="#基于博弈论的云-x2F-边缘计算资源分配与优化算法及应用" class="headerlink" title="基于博弈论的云&#x2F;边缘计算资源分配与优化算法及应用"></a>基于博弈论的云&#x2F;边缘计算资源分配与优化算法及应用</h1><blockquote><p>作者：胡俊艳 湖南大学 博士毕业论文</p></blockquote><h2 id="论文创新点"><a href="#论文创新点" class="headerlink" title="论文创新点"></a>论文创新点</h2><ol><li>基于非合作博弈的多属性云计算资源竞价算法</li><li>时间约束感知的云计算资源联合采购博弈论方法</li><li>基于博弈论的边缘计算任务卸载算法</li></ol><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用户在意的是QoS，最小成本和最大收益问题，比如响应时间、可靠性、任务的完成时间、资源定价等，</p><p>云提供商的主要效益 需要考虑节约能耗、负载均衡等因素，这对减小开销、合理配置资源、提高资源利用率和服务质量有重要意义</p><p>无论是云环境还是边环境，都存在资源配置和资源优化问题、尽最大努力改善用户的服务质量和用户体验，降低系统的运行成本问题。因此本文采用了博弈论方法来研究在云&#x2F;边环境下的计算资源的分配优化配置方法</p><blockquote><p>由于文章其他内容与我的研究点“算力网络的多方利益均衡”不同，所以没做记录</p></blockquote><h2 id="基于非合作博弈的多属性云计算资源竞价算法"><a href="#基于非合作博弈的多属性云计算资源竞价算法" class="headerlink" title="基于非合作博弈的多属性云计算资源竞价算法"></a>基于非合作博弈的多属性云计算资源竞价算法</h2><h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><p>针对云计算中多属性资源供应问题，提出一种<strong>基于非合作博弈关于云用户和提供商组成的利润最大化的价格竞价算法</strong>，提出一种新颖的关于服务质量和竞价的激励性资源购买模型。</p><p>然后结合用户的资源购买模型，将提供商的价格竞价问题转化为一个博弈模型来为每个云提供商找到合适的价格。</p><p>通过假设每个提供商提供的资源的数量函数是连续的，证明了针对已制定的博弈模型的纳什均衡解集的存在。</p><p>为了找到纳什均衡解，提出了一种均衡迭代算法，该算法被证明可以收敛到纳什均衡。</p><p>最后提出了一种近均衡价格竞价算法，对获得的纳什均衡解进行修正</p><h3 id="多属性云资源价格竞价系统模型"><a href="#多属性云资源价格竞价系统模型" class="headerlink" title="多属性云资源价格竞价系统模型"></a>多属性云资源价格竞价系统模型</h3><h4 id="云资源供应的参与者"><a href="#云资源供应的参与者" class="headerlink" title="云资源供应的参与者"></a>云资源供应的参与者</h4><p>将多用户和多提供商的情况并行化为<strong>一个用户和多个提供商的情况</strong></p><p>3个CPs（提供商）构成一个资源组，2的3次方个方案（这里的方案只是确定CPi是否提供资源，具体提供多少未知）</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724155121067.png" alt="image-20220724155121067"></p><h4 id="云用户对多属性云资源的评估"><a href="#云用户对多属性云资源的评估" class="headerlink" title="云用户对多属性云资源的评估"></a>云用户对多属性云资源的评估</h4><p>用户的属性偏好</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724171032448.png" alt="image-20220724171032448"></p><p>其中 用户的资源属性偏好</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724171333310.png" alt="image-20220724171333310"></p><h4 id="云用户的云资源购买机制"><a href="#云用户的云资源购买机制" class="headerlink" title="云用户的云资源购买机制"></a>云用户的云资源购买机制</h4><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220724192555620.png" alt="image-20220724192555620"></p><h2 id="文章题目：移动边缘计算中基于博弈论的资源分配技术研究"><a href="#文章题目：移动边缘计算中基于博弈论的资源分配技术研究" class="headerlink" title="文章题目：移动边缘计算中基于博弈论的资源分配技术研究"></a>文章题目：移动边缘计算中基于博弈论的资源分配技术研究</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>基于不完全合同的资源所有权分配算法设计<ol><li>有关不同所有权分配下的最优投资，最大化运营商部门效用函数（针对运营商）</li></ol></li><li>基于匹配理论的基站资源分配算法设计<ol><li>添加考虑基站，将基站作为边缘节点，优化系统整体资源分配效益，用户希望选择损失最小的基站（基站分为欠载基站、满载基站、过载基站）。考虑了小基站网络中用户到基站的任务迁移以及基站共同协作处理任务量的模型</li></ol></li><li>基于联合博弈的动态资源分配算法设计<ol><li>针对边缘计算节点的租用（基于匹配理论）以及计算服务提供商与用户之间的节点拍卖问题（拍卖理论与强化学习理论结合）</li><li>网络模型<ol><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20220726091144358.png" alt="image-20220726091144358"></li><li></li></ol></li></ol></li></ol><h2 id="文章题目：基于任务特性的公有云资源交易机制"><a href="#文章题目：基于任务特性的公有云资源交易机制" class="headerlink" title="文章题目：基于任务特性的公有云资源交易机制"></a>文章题目：基于任务特性的公有云资源交易机制</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ol><li>缓解资源需求峰值的任务调度策略和计价机制<ol><li></li></ol></li></ol><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul><li>MEC中的资源分配问题主要有：<ol><li>通信资源分配，根据无线系统环境，高效地分配通信资源，优化传输效率，降低用户间的干扰；</li><li>计算资源分配，根据用户的任务需求，有效地分配计算资源，最小化任务时延和能耗，提高卸载效率；</li><li>存储资源分配，根据用户的存储需求，分配对应的存储资源，避免用户存储空间不足引发的设备卡顿，提升用户 QoE。</li></ol></li><li>当前对 MEC 资源分配方法的研究大致从两个方面进行：技术层面和经济层面<ul><li>技术：计算卸载</li><li>经济：而经济层面不仅需要考虑如何分配资源，更需要考虑市场竞争性。用户不仅需要评估资源出价，更需要考虑向哪个服务器购买资源，以使自身效益最大化。因此，经济层面的资源分配问题计算复杂度大，综合管理更加复杂。对此，研究者一般采用&#x3D;&#x3D;动态分布式算法、拍卖、博弈&#x3D;&#x3D;等经济分析方法求解</li><li></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于博弈论的云-x2F-边缘计算资源分配与优化算法及应用&quot;&gt;&lt;a href=&quot;#基于博弈论的云-x2F-边缘计算资源分配与优化算法及应用&quot; class=&quot;headerlink&quot; title=&quot;基于博弈论的云&amp;#x2F;边缘计算资源分配与优化算法及应用&quot;&gt;&lt;/a&gt;基</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://kkkkkong.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="算力网络" scheme="https://kkkkkong.github.io/tags/%E7%AE%97%E5%8A%9B%E7%BD%91%E7%BB%9C/"/>
    
    <category term="边缘博弈" scheme="https://kkkkkong.github.io/tags/%E8%BE%B9%E7%BC%98%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>git merge与git pull的区别</title>
    <link href="https://kkkkkong.github.io/posts/23828.html"/>
    <id>https://kkkkkong.github.io/posts/23828.html</id>
    <published>2022-07-18T04:00:00.000Z</published>
    <updated>2022-11-27T03:06:05.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用GitHubPages-jekyll搭建博客平台"><a href="#使用GitHubPages-jekyll搭建博客平台" class="headerlink" title="使用GitHubPages+jekyll搭建博客平台"></a>使用GitHubPages+jekyll搭建博客平台</h3><h3 id="git-merge与git-pull的区别"><a href="#git-merge与git-pull的区别" class="headerlink" title="git merge与git pull的区别"></a>git merge与git pull的区别</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近做项目的时候使用git，遇到一个情形：</p><p>在本地自己的分支开发的时候，主分支合并了其他人的工作，此时需要将主分支的代码合并过来，一直使用的是git pull origin main命令，如果有他人合并的工作与我本地工作有冲突，需要自己处理对应冲突</p><p>今天偶然看到其他的做法是git pull origin main main，然后git merge main mybranch，发现这也是种实现方式</p><p>于是乎开始查这两种做法的区别</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>直接将origin的分支与本地当前分支合并，会将过程都隐藏起来，</p><p>遇到冲突解决</p><h4 id="git-fetch-git-merge"><a href="#git-fetch-git-merge" class="headerlink" title="git fetch+ git merge"></a>git fetch+ git merge</h4><p>git fetch origin main 将远程仓库中的最新代码拉回，</p><p>git merge origin&#x2F;main 把本地代码和已取得的main代码合并</p><p>遇到冲突去解决</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>网上很多文章都推荐使用fetch+merge，因为pull会直接更改你的工作，你不了解具体更改了什么</p><p>但如果使用了IDE，现在的IDE都集成了冲突处理功能，所以我觉着使用pull也问题不大</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用GitHubPages-jekyll搭建博客平台&quot;&gt;&lt;a href=&quot;#使用GitHubPages-jekyll搭建博客平台&quot; class=&quot;headerlink&quot; title=&quot;使用GitHubPages+jekyll搭建博客平台&quot;&gt;&lt;/a&gt;使用GitHub</summary>
      
    
    
    
    
    <category term="git" scheme="https://kkkkkong.github.io/tags/git/"/>
    
    <category term="merge" scheme="https://kkkkkong.github.io/tags/merge/"/>
    
    <category term="pull" scheme="https://kkkkkong.github.io/tags/pull/"/>
    
  </entry>
  
</feed>
