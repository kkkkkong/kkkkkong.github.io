<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-04-25T08:06:18.752Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客论坛实现技术细节</title>
    <link href="https://kkkkkong.github.io/posts/56055.html"/>
    <id>https://kkkkkong.github.io/posts/56055.html</id>
    <published>2023-04-25T01:04:23.000Z</published>
    <updated>2023-04-25T08:06:18.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="牛客论坛项目"><a href="#牛客论坛项目" class="headerlink" title="牛客论坛项目"></a>牛客论坛项目</h2><h3 id="首页功能"><a href="#首页功能" class="headerlink" title="首页功能"></a>首页功能</h3><ol><li>展示讨论区的内容</li><li>分页获取展示</li><li>日志显示</li></ol><h3 id="2-1-发送邮件"><a href="#2-1-发送邮件" class="headerlink" title="2.1 发送邮件"></a>2.1 发送邮件</h3><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230425102912452.png" alt="image-20230425102912452" style="zoom:50%;" /><h3 id="2-2-注册功能"><a href="#2-2-注册功能" class="headerlink" title="2.2 注册功能"></a>2.2 注册功能</h3><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230425152748247.png" alt="image-20230425152748247" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;牛客论坛项目&quot;&gt;&lt;a href=&quot;#牛客论坛项目&quot; class=&quot;headerlink&quot; title=&quot;牛客论坛项目&quot;&gt;&lt;/a&gt;牛客论坛项目&lt;/h2&gt;&lt;h3 id=&quot;首页功能&quot;&gt;&lt;a href=&quot;#首页功能&quot; class=&quot;headerlink&quot; title=&quot;首</summary>
      
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="项目" scheme="https://kkkkkong.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>IBM lab踩坑</title>
    <link href="https://kkkkkong.github.io/posts/45603.html"/>
    <id>https://kkkkkong.github.io/posts/45603.html</id>
    <published>2023-04-23T07:00:53.000Z</published>
    <updated>2023-04-23T07:40:28.049Z</updated>
    
    <content type="html"><![CDATA[<p>注册IBM cloud账号</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230423150141834.png" alt="image-20230423150141834"></p><ol><li>猜测是他不支持一些邮箱注册，我使用的是不常见的邮箱，可以使用QQ邮箱</li><li>也可能是开了梯子的问题，把梯子关了，是可以的</li></ol><p>ibmcloud cli 安装使用</p><p><a href="https://cloud.ibm.com/docs/codeengine?topic=codeengine-cli">IBM Cloud Code Engine CLI | IBM Cloud 文档</a></p><p><a href="https://cloud.ibm.com/docs/cli?topic=cli-getting-started">IBM Cloud CLI 入门 | IBM Cloud 文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注册IBM cloud账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230423150141834.png&quot; alt=&quot;image-2023</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 931</title>
    <link href="https://kkkkkong.github.io/posts/4008.html"/>
    <id>https://kkkkkong.github.io/posts/4008.html</id>
    <published>2023-04-19T02:00:21.000Z</published>
    <updated>2023-04-19T02:06:35.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931. 下降路径最小和"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">931. 下降路径最小和</a></h4><p>给你一个 <code>n x n</code> 的 <strong>方形</strong> 整数数组 <code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong> 的 <strong>最小和</strong> 。</p><p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/failing1-grid.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[2,1,3],[6,5,4],[7,8,9]]</span><br>输出：<span class="hljs-number">13</span><br>解释：如图所示，为和最小的两条下降路径<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>二维dp</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了41.74%的用户</p><p>内存消耗：41.7 MB, 在所有 Java 提交中击败了79.21%的用户</p><p>通过测试用例：49 &#x2F; 49</p><p>时间O(N*N)</p><p>空间 O(N*N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> m=matrix.length;<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> [][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i]=matrix[<span class="hljs-number">0</span>][i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)&#123;<br>                    tmp=dp[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==n-<span class="hljs-number">1</span>)&#123;<br>                    tmp=dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    tmp=Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br>                &#125;<br>                dp[i][j]=matrix[i][j]+Math.min(dp[i-<span class="hljs-number">1</span>][j],tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            ans=Math.min(ans,dp[m-<span class="hljs-number">1</span>][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>可以优化空间复杂度为O(N)，因为每次只使用上一行的元素</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;931-下降路径最小和&quot;&gt;&lt;a href=&quot;#931-下降路径最小和&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 354</title>
    <link href="https://kkkkkong.github.io/posts/44619.html"/>
    <id>https://kkkkkong.github.io/posts/44619.html</id>
    <published>2023-04-19T01:19:34.000Z</published>
    <updated>2023-04-19T01:27:08.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h4><p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>注意</strong>：不允许旋转信封。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：envelopes = <span class="hljs-comment">[<span class="hljs-comment">[5,4]</span>,<span class="hljs-comment">[6,4]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：3<br>解释：最多信封的个数为 3, 组合为: <span class="hljs-comment">[2,3]</span> =&gt; <span class="hljs-comment">[5,4]</span> =&gt; <span class="hljs-comment">[6,7]</span>。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>拆解为二维dp，先将原数组按照宽度升序排序，如果宽度相同，按照长度降序排序，这样不会出现多个宽度相同的信封</li></ol><blockquote><p>超时</p><p>时间 O(NlogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] envelopes)</span> &#123;<br>        Arrays.sort(envelopes,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> []o1,<span class="hljs-type">int</span> []o2)</span>&#123;<br>                <span class="hljs-comment">// 宽度相同，按长度降序排序</span><br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>]?<br>                o2[<span class="hljs-number">1</span>]-o1[<span class="hljs-number">1</span>]:o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> len=envelopes.length;<br>        <span class="hljs-type">int</span> []length=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            length[i]=envelopes[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> getLis(length);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLis</span><span class="hljs-params">(<span class="hljs-type">int</span> []arr)</span>&#123;<br>        <span class="hljs-type">int</span> []dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [arr.length];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(arr[i]&gt;arr[j])&#123;<br>                    dp[i]=Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            ans=Math.max(ans,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用二分做，不是正常人想的，近期理解普通dp就行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;354-俄罗斯套娃信封问题&quot;&gt;&lt;a href=&quot;#354-俄罗斯套娃信封问题&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>BBC纪录片《睡眠十律》</title>
    <link href="https://kkkkkong.github.io/posts/45782.html"/>
    <id>https://kkkkkong.github.io/posts/45782.html</id>
    <published>2023-04-18T09:15:42.000Z</published>
    <updated>2023-04-19T10:53:55.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BBC纪录片《睡眠十律》观后小知识点"><a href="#BBC纪录片《睡眠十律》观后小知识点" class="headerlink" title="BBC纪录片《睡眠十律》观后小知识点"></a>BBC纪录片《睡眠十律》观后小知识点</h2><blockquote><p>帮助人更多的了解自己</p></blockquote><ol><li>睡前至少一个小时，洗个热水澡，让体温上升。体温逐渐下降的过程会让人更有睡意</li><li>限制卧床时间，规律作息，只有睡觉的时候才上床</li><li>打盹时间：下午2点到5点。上午7-12点，晚上6-8点不要打盹。</li><li>打鼾：用润湿条（这个没怎么听过）减少口腔内软组织的振动  轻微打鼾 非处方药   严重打鼾 看医生</li><li>酒和咖啡都会非常影响睡觉，不要在睡前喝    咖啡会入睡期很艰难，酒虽然入睡容易但是下半夜仍然会很容易醒，两个都会减少深度睡眠时间，很难进入快速动眼期</li><li>让早上更清醒   蓝光灯</li><li>蛋白质食物让人活跃  高碳水让人昏昏欲睡</li><li>倒时差：上飞机前断食（只喝水）下飞机，到目的地时按当地第一个正常时间就餐</li><li>肌肉放松法：15分钟的肌肉紧绷后放松练习，降低皮质醇水平</li><li>传统草药植物助眠：薰衣草泡脚，缬草酊剂泡水喝。有点像中医的方式，应该也比较好用</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BBC纪录片《睡眠十律》观后小知识点&quot;&gt;&lt;a href=&quot;#BBC纪录片《睡眠十律》观后小知识点&quot; class=&quot;headerlink&quot; title=&quot;BBC纪录片《睡眠十律》观后小知识点&quot;&gt;&lt;/a&gt;BBC纪录片《睡眠十律》观后小知识点&lt;/h2&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="日常" scheme="https://kkkkkong.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="日常" scheme="https://kkkkkong.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB MVCC 机制理解</title>
    <link href="https://kkkkkong.github.io/posts/37067.html"/>
    <id>https://kkkkkong.github.io/posts/37067.html</id>
    <published>2023-04-18T03:33:33.000Z</published>
    <updated>2023-04-18T03:44:44.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-InnoDB-MVCC-机制理解"><a href="#MySQL-InnoDB-MVCC-机制理解" class="headerlink" title="MySQL InnoDB MVCC 机制理解"></a>MySQL InnoDB MVCC 机制理解</h2><h3 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h3><p>MVCC，即<strong>Multi-Version Concurrency Control （多版本并发控制）</strong>。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>mysql数据库隔离级别读<strong>已提交、可重复读</strong> 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。</p><h3 id="2-MVCC实现关键知识点"><a href="#2-MVCC实现关键知识点" class="headerlink" title="2. MVCC实现关键知识点"></a>2. MVCC实现关键知识点</h3><p>MVCC是通过UndoLog+ReadView实现</p><h4 id="2-0-隐藏字段"><a href="#2-0-隐藏字段" class="headerlink" title="2.0 隐藏字段"></a>2.0 隐藏字段</h4><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>单调递增的行ID，不是必需的，占用6个字节。</td></tr><tr><td>trx_id</td><td>是</td><td>记录操作该数据事务的事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>这个隐藏列就相当于一个指针，指向回滚段的undo日志</td></tr></tbody></table><h4 id="2-1-Undolog"><a href="#2-1-Undolog" class="headerlink" title="2.1 Undolog"></a>2.1 Undolog</h4><p>Undo log 主要用于<code>记录</code>数据被<code>修改之前</code>的日志，在表信息修改之前先会把数据拷贝到<code>undo log</code>里。<br>当<code>事务</code>进行<code>回滚时</code>可以通过undo log 里的日志进行<code>数据还原</code>。</p><p><strong>undo log主要分为两种：</strong></p><ul><li>insert undo log<br>代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li><li>update undo log（主要）<br>事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；<br>所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li></ul><h4 id="2-2-Readview"><a href="#2-2-Readview" class="headerlink" title="2.2 Readview"></a>2.2 Readview</h4><h5 id="readview中的属性"><a href="#readview中的属性" class="headerlink" title="readview中的属性"></a>readview中的属性</h5><ol><li><code>trx_ids</code>: 当前系统活跃(<code>未提交</code>)事务版本号集合。</li><li><code>low_limit_id</code>: 创建当前read view 时“当前系统<code>最大事务版本号</code>+1”。</li><li><code>up_limit_id(min_limit_id)</code>: 创建当前read view 时“系统正处于活跃事务<code>最小版本号</code>”</li><li><code>creator_trx_id</code>: 创建当前read view的事务版本号；</li></ol><h5 id="readview匹配规则"><a href="#readview匹配规则" class="headerlink" title="readview匹配规则"></a>readview匹配规则</h5><ol><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>,需要分3种情况讨论</li><li><blockquote><ul><li>如果<code>m_ids</code>包含<code>trx_id</code>,则代表Read View生成时刻，这个事务还未提交，但是如果数据的<code>trx_id</code>等于<code>creator_trx_id</code>的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</li><li>如果<code>m_ids</code>包含<code>trx_id</code>，并且<code>trx_id</code>不等于<code>creator_trx_id</code>，则Read   View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</li><li>如果<code>m_ids</code>不包含<code>trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></blockquote></li></ol><h4 id="2-3-主要过程"><a href="#2-3-主要过程" class="headerlink" title="2.3 主要过程"></a>2.3 主要过程</h4><ol><li>获取事务自己的版本号，即事务ID</li><li>获取Read View</li><li>查询得到的数据，然后Read View中的事务版本号进行比较。</li><li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li><li>最后返回符合规则的数据</li></ol><h4 id="2-4-MVCC在RC和RR实现上的区别"><a href="#2-4-MVCC在RC和RR实现上的区别" class="headerlink" title="2.4 MVCC在RC和RR实现上的区别"></a>2.4 MVCC在RC和RR实现上的区别</h4><p>在RC下，事务中每执行一条sql都会有<strong>新的readview</strong>，所以会出现不可重复读的问题，但RR下在同一个事务中<strong>使用同一个readview对象</strong></p><h3 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3. 参考链接"></a>3. 参考链接</h3><p><a href="https://juejin.cn/post/7016165148020703246#heading-22">看一遍就理解:MVCC原理详解 - 掘金</a></p><p><a href="https://zhuanlan.zhihu.com/p/492249490">看一遍就懂，全网最全一篇数据库MVCC详解！ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-InnoDB-MVCC-机制理解&quot;&gt;&lt;a href=&quot;#MySQL-InnoDB-MVCC-机制理解&quot; class=&quot;headerlink&quot; title=&quot;MySQL InnoDB MVCC 机制理解&quot;&gt;&lt;/a&gt;MySQL InnoDB MVCC 机制</summary>
      
    
    
    
    <category term="MySQL" scheme="https://kkkkkong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://kkkkkong.github.io/tags/MySQL/"/>
    
    <category term="MVCC" scheme="https://kkkkkong.github.io/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 300</title>
    <link href="https://kkkkkong.github.io/posts/15689.html"/>
    <id>https://kkkkkong.github.io/posts/15689.html</id>
    <published>2023-04-16T09:50:51.000Z</published>
    <updated>2023-04-18T03:42:57.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>dp</li></ol><blockquote><p>执行用时：59 ms, 在所有 Java 提交中击败了53.47%的用户</p><p>内存消耗：41 MB, 在所有 Java 提交中击败了49.70%的用户</p><p>通过测试用例：54 &#x2F; 54</p><p>时间 O(N*N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> []dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])&#123;<br>                    dp[i]=Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            ans=Math.max(ans,dp[i]);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>IBM开发项目总结</title>
    <link href="https://kkkkkong.github.io/posts/59923.html"/>
    <id>https://kkkkkong.github.io/posts/59923.html</id>
    <published>2023-04-15T14:50:44.000Z</published>
    <updated>2023-04-15T15:01:25.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IBM后端开发项目总结"><a href="#IBM后端开发项目总结" class="headerlink" title="IBM后端开发项目总结"></a>IBM后端开发项目总结</h1><blockquote><p> 项目名称：IBM的资源部署后端开发</p><p>单位：IBM中国</p><p>编程语言：Python</p><p>web框架：CherryPy</p><p>开发时间：2022.7-2022.11</p></blockquote><hr><blockquote><p>IBM项目经历了大概4个月的开发，截止半个月前（11.10）已经结束，上周开了最后一次项目总结会议，也算是给这几个月的开发画了一个圆满的句号</p></blockquote><h2 id="编程方面"><a href="#编程方面" class="headerlink" title="编程方面"></a>编程方面</h2><ol><li>对于python的web框架CherryPy有了一定的了解，可以部署并使用</li><li>对于所谓的三层架构的规范更加熟悉（DAO、Service、Controller）<ol><li>DAO只负责对于数据库的增删改查，将基础的操作抽象出函数提供给service使用</li><li>service负责接受controller的调用，负责主要的业务逻辑的编写，一般不需要做参数检查；在编写业务逻辑时使用DAO提供的函数</li><li>controller层主要是接受HTTP请求，对参数进行校验，然后传参给service并接收其结果返回给前端</li></ol></li><li>model模块主要将数据库表与类一一对应，类中设置相应的属性，目的是DAO调用的时候更加规范清晰</li><li>抽象工具类的使用，这个是以前没有涉及到太多的，很多会重复调用的代码，这时将一些工具类单独抽象出来，如<code>log_config.py、locks_handler.py、db_connection.py、thread_pool.py</code>等</li><li>代码复用，将公共方法抽象出来，减少代码冗余，如<code>base_dao.py</code></li><li>将常量统一管理起来，方便修改 <code>constant.py</code></li></ol><h2 id="工程方面："><a href="#工程方面：" class="headerlink" title="工程方面："></a>工程方面：</h2><ol><li><p>在做数据库设计的时候，充分考虑表与表之间的关系，尽量减少返工</p></li><li><p>docker的使用更加熟练了，项目本身是在docker上跑的数据库、前后端的服务也是docker上跑的</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230415225410492.png" alt="image-20230415225410492"></p><p>1. </p></li><li><p>需要继续重视log的使用，在进行越来越大的工程开发时，往往进行debug的机会不大，所以要充分运用log，通过log查bug</p></li><li><p>写代码的时候，问清楚需求，搞清楚具体点的逻辑，按部就班的进行</p></li><li><p>RESTful API的设计使用更加熟练了，毕竟写了超多API</p></li><li><p>apidoc文档创建工具的使用熟悉起来了</p></li><li><p>postman的使用熟练了</p></li><li><p>git的使用逐渐熟练</p></li></ol><h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><p>算是第一个参与的人数较多的真实项目，虽然项目整体不大，所做工作不复杂，但总结了一下还是有不少收获的。而且通过项目认识了几个好朋友，收获颇丰</p><blockquote><p>看了一下git的代码量统计，还是写了一些代码的（虽然有一些是API的文档，hh）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230415225332248.png" alt="image-20230415225332248"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>统计git代码参考链接：</li></ul><p><a href="https://www.cnblogs.com/0616--ataozhijia/p/8081329.html">https://www.cnblogs.com/0616--ataozhijia/p/8081329.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IBM后端开发项目总结&quot;&gt;&lt;a href=&quot;#IBM后端开发项目总结&quot; class=&quot;headerlink&quot; title=&quot;IBM后端开发项目总结&quot;&gt;&lt;/a&gt;IBM后端开发项目总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 项目名称：IBM的资源部署后端开发&lt;/p</summary>
      
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="https://kkkkkong.github.io/tags/Python/"/>
    
    <category term="开发" scheme="https://kkkkkong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leetocode 973</title>
    <link href="https://kkkkkong.github.io/posts/56905.html"/>
    <id>https://kkkkkong.github.io/posts/56905.html</id>
    <published>2023-04-14T08:49:18.000Z</published>
    <updated>2023-04-14T08:52:13.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h4><p>给定一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点，并且是一个整数 <code>k</code> ，返回离原点 <code>(0,0)</code> 最近的 <code>k</code> 个点。</p><p>这里，平面上两点之间的距离是 <strong>欧几里德距离</strong>（ <code>√(x1 - x2)2 + (y1 - y2)2</code> ）。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。除了点坐标的顺序之外，答案 <strong>确保</strong> 是 <strong>唯一</strong> 的。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/closestplane1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,3],[-2,2]]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[-2,2]]</span><br>解释： <br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) 和原点之间的距离为 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)，<br>(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) 和原点之间的距离为 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>)，<br>由于 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>) &lt; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)，(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) 离原点更近。<br>我们只需要距离原点最近的 K = <span class="hljs-number">1</span> 个点，所以答案就是 <span class="hljs-string">[[-2,2]]</span>。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>直接API排序实现返回</li><li>使用优先队列实现（堆）</li></ol><blockquote><p>执行用时：77 ms, 在所有 Java 提交中击败了10.63%的用户</p><p>内存消耗：49.8 MB, 在所有 Java 提交中击败了22.19%的用户</p><p>通过测试用例：87 &#x2F; 87</p><p>时间 O(n)</p><p>空间 O(k)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer[]&gt;&#123;<br>        <span class="hljs-comment">// 一个大顶堆，peek出的是距离最大的元素</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer []o1, Integer []o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> -Double.compare(Math.pow(o1[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>) + Math.pow(o1[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>), Math.pow(o2[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>) + Math.pow(o2[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] kClosest(<span class="hljs-type">int</span>[][] points, <span class="hljs-type">int</span> k) &#123;<br>        MyComparator cmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>();<br>        PriorityQueue&lt;Integer[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;points.length;i++)&#123;<br>            Integer[] tmp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;points[i][<span class="hljs-number">0</span>],points[i][<span class="hljs-number">1</span>]&#125;;<br>            <span class="hljs-keyword">if</span>(i&lt;k)&#123;<br>                queue.offer(tmp);<br>            &#125;<br>            <span class="hljs-comment">// 如果当前元素小于queue中距离最大的元素则更新</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp.compare(tmp,queue.peek())&gt;<span class="hljs-number">0</span>)&#123;<br>                queue.poll();<br>                queue.offer(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> [][]ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            Integer[]tmp=queue.poll();<br>            ans[i][<span class="hljs-number">0</span>]=tmp[<span class="hljs-number">0</span>];<br>            ans[i][<span class="hljs-number">1</span>]=tmp[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;973-最接近原点的-K-个点&quot;&gt;&lt;a href=&quot;#973-最接近原点的-K-个点&quot; class=&quot;header</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>脚本实现docker上的hexo自动部署</title>
    <link href="https://kkkkkong.github.io/posts/61507.html"/>
    <id>https://kkkkkong.github.io/posts/61507.html</id>
    <published>2023-04-14T02:31:15.000Z</published>
    <updated>2023-04-14T03:07:42.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脚本实现docker上的hexo自动部署"><a href="#脚本实现docker上的hexo自动部署" class="headerlink" title="脚本实现docker上的hexo自动部署"></a>脚本实现docker上的hexo自动部署</h1><blockquote><p>这篇文章就是这么上传的hh</p></blockquote><h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>之前把博客部署在了githubpages上，很方便，但是其他人访问的时候一般需要访问外网，而且有些网站在做SEO的时候不会统计githubpages，因此萌生了自己部署的想法。</p><p>所以有了在云服务器上部署hexo博客，并实现了正常访问，看似一切正常，但写博客太痛苦了，我一般习惯在本地typora上写，因为图床什么的都配置好了，但在部署的时候就变麻烦了，要同时同步到github和服务器上，这样才能保证通过<a href="https://kkkkkong.github.io/%E5%92%8Chttp://www.kkkkkong.top/%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E8%AE%BF%E9%97%AE%E3%80%82%E5%9B%A0%E6%AD%A4%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://kkkkkong.github.io/和http://www.kkkkkong.top/都可以及时更新访问。因此需要一个快速部署的解决方案。</a></p><h3 id="现有环境"><a href="#现有环境" class="headerlink" title="现有环境"></a>现有环境</h3><p>GitHubPages上运行一个博客，地址是 <a href="https://kkkkkong.github.io/">https://kkkkkong.github.io/</a></p><p>云服务器的docker容器中运行一个博客，地址是 <a href="http://www.kkkkkong.top/">http://www.kkkkkong.top/</a></p><p>两个地址的内容完全一样</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h3><h4 id="自动代码更新和部署"><a href="#自动代码更新和部署" class="headerlink" title="自动代码更新和部署"></a>自动代码更新和部署</h4><ul><li><p>本地</p><ul><li><p>这个之前博客里写过了，在Windows环境下写一个bat脚本省去了重复的步骤</p></li><li><pre><code class="bat">@echo offhexo clean&amp;&amp;hexo g&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin source&amp;&amp;pause<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>    - 分别是hexo的清空、生成、部署，实际git提交到远程仓库的操作<br><br>- 服务器端<br><br>  - 在本地写完文档并提交之后，此时https:<span class="hljs-regexp">//</span>kkkkkong.github.io<span class="hljs-regexp">/是可以访问的，但是http:/</span><span class="hljs-regexp">/www.kkkkkong.top/</span>无法访问，因为没更新哈，就需要将远程仓库的代码pull下来更新<br><br>  - 在我们使用docker部署hexo时，设置了宿主机目录映射容器目录，因此只需要在<span class="hljs-regexp">/mnt/</span>blog.kong.site操作即可[centos上使用docker部署hexo - 虫兑变的博客 (kkkkkong.top)](http:<span class="hljs-regexp">//</span>www.kkkkkong.top<span class="hljs-regexp">/posts/</span><span class="hljs-number">19452</span>.html)<br><br>  - 主要内容如下，目的就是更新远程的文档到当前目录，然后执行容器命令，将命令输出打印到日志，方便查错误<br><br>    ```shell<br>    cd <span class="hljs-regexp">/mnt/</span>blog.kong.site/<br>    <span class="hljs-comment"># 将执行结果追加到日志文件</span><br>    git pull origin source &gt;&gt; <span class="hljs-regexp">/tmp/gi</span>t_pull_hexo.log<br>    docker exec -it hexo hexo clean &gt;&gt; <span class="hljs-regexp">/tmp/gi</span>t_pull_hexo.log<br>    docker exec -it hexo hexo g &gt;&gt; <span class="hljs-regexp">/tmp/gi</span>t_pull_hexo.log<br>    docker exec -it hexo hexo d &gt;&gt; <span class="hljs-regexp">/tmp/gi</span>t_pull_hexo.log<br></code></pre></td></tr></table></figure></code></pre></li><li><p>这样子每次提交前执行以下脚本就OK了，但这是不是我们想要的效果呢，显然不是，这还是很麻烦，每次更新都要连接服务器进行操作，不是我想要的效果。</p></li></ul></li></ul><h4 id="定时任务设置"><a href="#定时任务设置" class="headerlink" title="定时任务设置"></a>定时任务设置</h4><p>想要实现自动任务，让脚本定时自动执行，那么就要用到了crond制作定时任务了</p><p>进入crontab来编辑定时任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab -e<br></code></pre></td></tr></table></figure><p>设置脚本内容，根据实际情况自行修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里表示每2分钟执行一次pullcoding.sh脚本，并将执行结果输出到git.log文件中</span><br>*/2 * * * * /root/hexo_pull_from_github/pull_code.sh &gt;&gt; /tmp/git_pull_hexo.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">每3个月28号23点59分清除日志文件（防止系统爆炸! ememem, 这点日志怎么可能？但这是&gt;好习惯.）</span><br>59 23 28 */3 * &gt; /tmp/git_pull_hexo.log<br></code></pre></td></tr></table></figure><p>这样子看起来很完美了，我在本地提交了新博客之后，不到两分钟他就会自动更新部署了，但是对于服务器来说，做了很多无用功。存在这样的情况：</p><blockquote><p>明明没有任何博客新增或修改，但服务器仍然每两分钟执行 hexo clean hexo g hexo d，要知道我这服务器一共也就1核2G，都用来跑这个了我还用不用了。</p></blockquote><h4 id="目录监测"><a href="#目录监测" class="headerlink" title="目录监测"></a>目录监测</h4><p>为了解决上面的问题，我搞个检测函数看我博客目录下是不是有文件修改了不就行了，直接问chatgpt，他也很痛快，直接给我写了个函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">函数：check_dir_update</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数：<span class="hljs-variable">$1</span>——需要检测的目录路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回值：0——目录最近1分钟内没有文件被修改，1——目录最近1分钟内有文件被修改</span><br>check_dir_update() &#123;<br>    # 获取当前时间和1分钟前的时间<br>    current_time=$(date +%s)<br>    one_minute_ago=$(date -d &#x27;1 minute ago&#x27; +%s)<br><br>    # 检测目录$1下的文件是否在1分钟内被修改<br>    find $1 -type f -newermt @$one_minute_ago ! -newermt @$current_time | grep -q .<br>    if [ $? -eq 0 ]; then<br>        return 1<br>    else<br>        return 0<br>    fi<br>&#125;<br></code></pre></td></tr></table></figure><p>完美解决，这篇文章就是这么上传的</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pull_code.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">函数：check_dir_update</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数：<span class="hljs-variable">$1</span>——需要检测的目录路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回值：0——目录最近1分钟内没有文件被修改，1——目录最近1分钟内有文件被修改</span><br>check_dir_update() &#123;<br>    # 获取当前时间和1分钟前的时间<br>    current_time=$(date +%s)<br>    one_minute_ago=$(date -d &#x27;1 minute ago&#x27; +%s)<br><br>    # 检测目录$1下的文件是否在1分钟内被修改<br>    find $1 -type f -newermt @$one_minute_ago ! -newermt @$current_time | grep -q .<br>    if [ $? -eq 0 ]; then<br>        return 1<br>    else<br>        return 0<br>    fi<br>&#125;<br><br><br>cd /mnt/blog.kong.site/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将执行结果追加到日志文件</span><br>git pull origin source &gt;&gt; /tmp/git_pull_hexo.log &amp;&amp;&#123;<br>  sleep 5<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">为方便查看，追加一行日期</span><br>  date &gt;&gt; /tmp/git_pull_hexo.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">调用函数check_dir_update检测目录是否最近1分钟内有文件被修改</span><br>  if check_dir_update &quot;/mnt/blog.kong.site/source/_posts/&quot;; then<br>      echo &quot;目录最近1分钟内没有文件被修改&quot; &gt;&gt; /tmp/git_pull_hexo.log<br>  else<br>      echo &quot;目录最近1分钟内有文件被修改&quot; &gt;&gt; /tmp/git_pull_hexo.log<br>      docker exec -it hexo hexo clean &gt;&gt; /tmp/git_pull_hexo.log<br>      docker exec -it hexo hexo g &gt;&gt; /tmp/git_pull_hexo.log<br>      docker exec -it hexo hexo d &gt;&gt; /tmp/git_pull_hexo.log<br>  fi<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里表示每2分钟执行一次pullcoding.sh脚本，并将执行结果输出到git.log文件中</span><br>*/2 * * * * /root/hexo_pull_from_github/pull_code.sh &gt;&gt; /tmp/git_pull_hexo.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">每2个月28号23点59分清除日志文件</span><br>59 23 28 */2 * &gt; /tmp/git_pull_hexo.log<br><br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_15941409/article/details/109855152">备忘 Linux CentOS git每分钟pull代码,git定时更新代码_SDL大华的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/csdn_yasin/article/details/70332796">Linux_git定时更新代码脚本（crontab）_csdn_yasin的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;脚本实现docker上的hexo自动部署&quot;&gt;&lt;a href=&quot;#脚本实现docker上的hexo自动部署&quot; class=&quot;headerlink&quot; title=&quot;脚本实现docker上的hexo自动部署&quot;&gt;&lt;/a&gt;脚本实现docker上的hexo自动部署&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="服务器" scheme="https://kkkkkong.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="docker" scheme="https://kkkkkong.github.io/tags/docker/"/>
    
    <category term="shell" scheme="https://kkkkkong.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>centos上使用docker部署hexo</title>
    <link href="https://kkkkkong.github.io/posts/19452.html"/>
    <id>https://kkkkkong.github.io/posts/19452.html</id>
    <published>2023-04-13T02:54:56.000Z</published>
    <updated>2023-04-14T03:07:50.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>最近有个需求，服务器上运行三个docker容器，目前分别使用ip:4000、ip:18000、ip:18080来访问，但这样子记得很麻烦，ip本身不规律，很不好记，于是有了域名+端口号的写法 <a href="http://kkkkkong.top:4000/">(kkkkkong.top:4000)</a></p><p>但是用久了感觉还是不够流畅，写端口号的方式会显得比较low，因此考虑使用nginx反向代理的方式实现优雅的访问</p><h3 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h3><blockquote><p>现有三个服务分别运行在三个docker容器中，其占用的宿主机端口号分别为4000&#x2F;18000&#x2F;18080，容器内部端口号都为80</p></blockquote><ul><li>采用kkkkkong.top来访问4000端口</li><li>采用kkkkkong.top&#x2F;nextcloud 来访问18000端口</li><li>采用kkkkkong.top&#x2F;opengrok 来访问18080端口</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>先进行hexo的docker版本的部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create -it --name=hexo -e HEXO_SERVER_PORT=4000 -e GIT_USER=&quot;kong&quot; -e GIT_EMAIL=&quot;376634352@qq.com&quot; -v /mnt/blog.kong.site:/app -p 4000:80 bloodstar/hexo<br></code></pre></td></tr></table></figure><h3 id="配置nginx-docker"><a href="#配置nginx-docker" class="headerlink" title="配置nginx -docker"></a>配置nginx -docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name=nginx -d -p 80:80<br></code></pre></td></tr></table></figure><p>修改nginx的配置，通过命令找到其他容器的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect containsID<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230413191601873.png" alt="image-20230413191601873" style="zoom: 67%;" /><p>图中红框部分即为我们需要的容器IP地址</p><h3 id="配置nginx的代理"><a href="#配置nginx的代理" class="headerlink" title="配置nginx的代理"></a>配置nginx的代理</h3><p>进入容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it nginx bash<br></code></pre></td></tr></table></figure><p>找到nginx的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/nginx/conf.d/default.conf<br></code></pre></td></tr></table></figure><p>将你需要的信息添加到location中</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230413191958986.png" alt="image-20230413191958986"></p><p>三个红框分别为匹配规则，匹配路径和匹配的url</p><ul><li>匹配规则可以参考官方文档 <a href="https://nginx.org/">nginx news</a></li><li>匹配路径是设置跟在域名后的名字</li><li>url是由容器的ip+内部暴露的端口号构成</li></ul><p>保存退出，查看配置信息是否可用，看见有successful ，成功（这里如果不留神改错了，会导致重启容器后修改比较麻烦）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -t<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230413192338410.png" alt="image-20230413192338410"></p><p>退出容器重启就可以优雅的访问了</p><p><a href="http://www.kkkkkong.top/">虫兑变的博客 (kkkkkong.top)</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/dotnet261010/p/12596185.html">Docker教程：使用Docker容器运行Nginx并实现反向代理 - .NET开发菜鸟 - 博客园 (cnblogs.com)</a></p><p><a href="https://github.com/appotry/docker-hexo">Appotry&#x2F;docker-hexo： hexo docker 一键部署环境。增加CJK中国环境适配和常用软件，hexo 插件等易用设置。开箱即用。 (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;最近有</summary>
      
    
    
    
    <category term="服务器" scheme="https://kkkkkong.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="docker" scheme="https://kkkkkong.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://kkkkkong.github.io/tags/linux/"/>
    
    <category term="nginx" scheme="https://kkkkkong.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 92</title>
    <link href="https://kkkkkong.github.io/posts/26852.html"/>
    <id>https://kkkkkong.github.io/posts/26852.html</id>
    <published>2023-04-05T01:14:16.000Z</published>
    <updated>2023-04-05T01:22:10.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/rev2ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，主要在于找到被反转的链表，然后切割，与无关字符串断开</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.9 MB, 在所有 Java 提交中击败了84.13%的用户</p><p>通过测试用例：44 &#x2F; 44</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        ListNode zeroNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        ListNode res=zeroNode;<br>        zeroNode.next=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left-<span class="hljs-number">1</span>;i++)&#123;<br>            zeroNode=zeroNode.next;<br>        &#125;<br>        ListNode prev=zeroNode;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>            zeroNode=zeroNode.next;<br>        &#125;<br>        ListNode rightNode=zeroNode;<br>        ListNode leftNode=prev.next;<br>        prev.next=<span class="hljs-literal">null</span>;<br>        ListNode afNode=rightNode.next;<br>        rightNode.next=<span class="hljs-literal">null</span>;<br>        prev.next= reverseList(leftNode);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>            prev=prev.next;<br>        &#125;<br>        prev.next=afNode;<br>        <span class="hljs-keyword">return</span> res.next;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        ListNode prev=<span class="hljs-literal">null</span>;<br>        ListNode curr=head;<br>        <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp=curr.next;<br>            curr.next=prev;<br>            prev=curr;<br>            curr=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;92-反转链表-II&quot;&gt;&lt;a href=&quot;#92-反转链表-II&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 196</title>
    <link href="https://kkkkkong.github.io/posts/44910.html"/>
    <id>https://kkkkkong.github.io/posts/44910.html</id>
    <published>2023-03-22T01:47:12.000Z</published>
    <updated>2023-04-05T01:22:10.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode.cn/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></h4><p>SQL架构</p><p>表: <code>Person</code></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| id          | int     |<br><span class="hljs-section">| email       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br>id是该表的主键列。<br>该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。<br></code></pre></td></tr></table></figure><p>编写一个 SQL <strong>删除语句</strong>来 <strong>删除</strong> 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。</p><p>以 <strong>任意顺序</strong> 返回结果表。 （<strong>注意</strong>： 仅需要写删除语句，将自动对剩余结果进行查询）</p><p>查询结果格式如下所示。</p><p><strong>示例 1:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">输入: <br><span class="hljs-section">Person 表:</span><br><span class="hljs-section">+----+------------------+</span><br><span class="hljs-section">| id | email            |</span><br><span class="hljs-section">+----+------------------+</span><br>| 1  | john@example.com |<br>| 2  | bob@example.com  |<br><span class="hljs-section">| 3  | john@example.com |</span><br><span class="hljs-section">+----+------------------+</span><br><span class="hljs-section">输出: </span><br><span class="hljs-section">+----+------------------+</span><br><span class="hljs-section">| id | email            |</span><br><span class="hljs-section">+----+------------------+</span><br>| 1  | john@example.com |<br><span class="hljs-section">| 2  | bob@example.com  |</span><br><span class="hljs-section">+----+------------------+</span><br>解释: john@example.com重复两次。我们保留最小的Id = 1。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解</li></ol><blockquote><p>执行用时：577 ms, 在所有 MySQL 提交中击败了82.16%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：22 &#x2F; 22</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Please write a <span class="hljs-keyword">DELETE</span> statement <span class="hljs-keyword">and</span> DO <span class="hljs-keyword">NOT</span> write a <span class="hljs-keyword">SELECT</span> statement.<br># Write your MySQL query statement below<br><span class="hljs-keyword">DELETE</span> p1<br><span class="hljs-keyword">from</span><br>person p1,person p2<br><span class="hljs-keyword">where</span> p1.email<span class="hljs-operator">=</span>p2.email <span class="hljs-keyword">and</span> p1.id<span class="hljs-operator">&gt;</span>p2.id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;196-删除重复的电子邮箱&quot;&gt;&lt;a href=&quot;#196-删除重复的电子邮箱&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 182</title>
    <link href="https://kkkkkong.github.io/posts/64622.html"/>
    <id>https://kkkkkong.github.io/posts/64622.html</id>
    <published>2023-03-22T01:37:18.000Z</published>
    <updated>2023-04-05T01:22:10.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode.cn/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></h4><p>SQL架构</p><p>表: <code>Person</code></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| id          | int     |<br><span class="hljs-section">| email       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br>id 是该表的主键列。<br>此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。<br></code></pre></td></tr></table></figure><p>编写一个 SQL 查询来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。</p><p>以 <strong>任意顺序</strong> 返回结果表。</p><p>查询结果格式如下例。</p><p><strong>示例 1:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">输入: <br><span class="hljs-section">Person 表:</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">| id | email   |</span><br><span class="hljs-section">+----+---------+</span><br>| 1  | a@b.com |<br>| 2  | c@d.com |<br><span class="hljs-section">| 3  | a@b.com |</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">输出: </span><br><span class="hljs-section">+---------+</span><br><span class="hljs-section">| Email   |</span><br><span class="hljs-section">+---------+</span><br><span class="hljs-section">| a@b.com |</span><br><span class="hljs-section">+---------+</span><br>解释: a@b.com 出现了两次。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先建立一个子表，在查询</li></ol><blockquote><p>执行用时：378 ms, 在所有 MySQL 提交中击败了58.00%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：15 &#x2F; 15</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span><br>Email<br><span class="hljs-keyword">from</span><br>(<span class="hljs-keyword">select</span><br>email,<span class="hljs-built_in">count</span>(email) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">from</span> person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>email) <span class="hljs-keyword">as</span> tab<br><span class="hljs-keyword">where</span> num <span class="hljs-operator">&gt;</span><span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><ol><li>group by+having</li></ol><blockquote><p>执行用时：435 ms, 在所有 MySQL 提交中击败了15.93%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：15 &#x2F; 15</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span><br>Email<br><span class="hljs-keyword">from</span> <br>Person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>Email<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(Email)<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;182-查找重复的电子邮箱&quot;&gt;&lt;a href=&quot;#182-查找重复的电子邮箱&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 144</title>
    <link href="https://kkkkkong.github.io/posts/65259.html"/>
    <id>https://kkkkkong.github.io/posts/65259.html</id>
    <published>2023-03-22T01:23:30.000Z</published>
    <updated>2023-04-05T01:22:10.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>难度简单1028收藏分享切换为英文接收动态反馈</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了35.01%的用户</p><p>通过测试用例：70 &#x2F; 70</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; list;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        getNode(root);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNode</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ;<br>        list.add(root.val);<br>        getNode(root.left);<br>        getNode(root.right);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 145</title>
    <link href="https://kkkkkong.github.io/posts/15914.html"/>
    <id>https://kkkkkong.github.io/posts/15914.html</id>
    <published>2023-03-22T01:20:51.000Z</published>
    <updated>2023-04-05T01:22:10.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>难度简单1009收藏分享切换为英文接收动态反馈</p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/pre1.jpg" alt="img"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了38.80%的用户</p><p>通过测试用例：68 &#x2F; 68</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;Integer&gt; list;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        getNode(root);<br>        <span class="hljs-keyword">return</span> list;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNode</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ;<br>        getNode(root.left);<br>        getNode(root.right);<br>        list.add(root.val);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DragonOS前三个进程的创建</title>
    <link href="https://kkkkkong.github.io/posts/13195.html"/>
    <id>https://kkkkkong.github.io/posts/13195.html</id>
    <published>2023-03-20T08:43:40.000Z</published>
    <updated>2023-04-05T01:22:10.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统加载过程"><a href="#操作系统加载过程" class="headerlink" title="操作系统加载过程"></a>操作系统加载过程</h2><ol><li>内核引导<ol><li>POST</li><li>BIOS</li><li>MBR：主引导记录</li><li>硬盘启动，grub，选择启用哪个系统</li><li>操作系统：start，手动创建0号进程</li></ol></li><li>加载init，1，2号进程的初始化</li><li>系统初始化：加载开机启动程序 init.d</li><li>建立终端</li><li>用户登录</li></ol><p><img src="https://e1sw9jmnjt.feishu.cn/space/api/box/stream/download/asynccode/?code=NGZlMDI2YTA3NmY3NzQ0MjQyYjUyODVkNWI5YWVhMmNfQlRMc21VVXROWjU5NjljRzFPeUxuRTliYjlUMGdOcXBfVG9rZW46WkNVWmIzbHBZb1NiZTV4c1F3dGNyTGFkbm9lXzE2NzkzMDMzMDg6MTY3OTMwNjkwOF9WNA" alt="img"></p><h2 id="进程创建的时机"><a href="#进程创建的时机" class="headerlink" title="进程创建的时机"></a>进程创建的时机</h2><p>do_fork()</p><p>任何进程都是由其他进程创建的。<strong>操作系统通过系统调用fork(),vfork()和clone()函数来完成进程的创建。</strong></p><ul><li><strong>这三个系统调用最终都调用了内核函数do_fork()</strong></li><li><strong>这三个函数的唯一区别在于随后调用do_fork(0时设置的标志不同。</strong></li></ul><h2 id="进程的功能"><a href="#进程的功能" class="headerlink" title="进程的功能"></a>进程的功能</h2><h3 id="0号进程：IDLE"><a href="#0号进程：IDLE" class="headerlink" title="0号进程：IDLE"></a>0号进程：IDLE</h3><p>系统中的第一个进程，PID为0，是init进程和kthread的父进程，</p><h3 id="1号进程：init"><a href="#1号进程：init" class="headerlink" title="1号进程：init"></a>1号进程：init</h3><p>是第一个用户空间的进程，PID为1，是其他用户空间进程的父进程</p><h3 id="2号进程：kthreadd"><a href="#2号进程：kthreadd" class="headerlink" title="2号进程：kthreadd"></a>2号进程：kthreadd</h3><p>是内核空间其他内核进程的父进程，PID为2，</p><p>负责内核线程的创建工作</p><p>结构树(篇幅原因移除部分子进程)</p><blockquote><p>[root@VM-8-5-centos ~]# pstree 0 -p<br>?()─┬─kthreadd(2)─┬─ata_sff(257)<br>    │             ├─bioset(23)<br>    │             ├─bioset(24)<br>    │             ├─bioset(25)<br>    │             ├─crypto(38)<br>    └─systemd(1)─┬─YDLive(1789)─┬─YDService(2493)─┬─sh(2603)─┬─{sh}(2604)<br>                 │              │                 │          ├─{sh}(2605)<br>                 │              │                 │          ├─{sh}(2609)<br>                 │              │                 │          ├─{sh}(2610)<br>                 │              │                 │          └─{sh}(15243)<br>                 │              │                 ├─{YDService}(2494)<br>                 │              │                 ├─{YDService}(2497)<br>                 │              ├─{YDLive}(1790)<br>                 │              ├─{YDLive}(1796)<br>                 │              └─{YDLive}(6911)<br>                 ├─abrt-dbus(21662)─┬─{abrt-dbus}(21663)<br>                 │                  └─{abrt-dbus}(21665)<br>                 ├─acpid(666)</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/joggingpig/article/details/110239518">Linux中的特殊进程：idle进程、init进程、kthreadd进程_JoggingPig的博客-CSDN博客</a></p><p>sql语句查询过程</p><p>查缓存</p><p>解析器：语法、词法</p><p>优化器：逻辑优化、物理</p><p>执行器：</p><h1 id="解决由于在中断上下文以外，sched-enqueue时，未关中断导致cpu-queue双重加锁的问题-201"><a href="#解决由于在中断上下文以外，sched-enqueue时，未关中断导致cpu-queue双重加锁的问题-201" class="headerlink" title="解决由于在中断上下文以外，sched_enqueue时，未关中断导致cpu_queue双重加锁的问题 #201"></a>解决由于在中断上下文以外，sched_enqueue时，未关中断导致cpu_queue双重加锁的问题 #201</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统加载过程&quot;&gt;&lt;a href=&quot;#操作系统加载过程&quot; class=&quot;headerlink&quot; title=&quot;操作系统加载过程&quot;&gt;&lt;/a&gt;操作系统加载过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内核引导&lt;ol&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;li&gt;BIOS&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="DragonOS" scheme="https://kkkkkong.github.io/categories/DragonOS/"/>
    
    
    <category term="DragonOS" scheme="https://kkkkkong.github.io/tags/DragonOS/"/>
    
  </entry>
  
  <entry>
    <title>docker 部署opengrok方便代码阅读</title>
    <link href="https://kkkkkong.github.io/posts/1728.html"/>
    <id>https://kkkkkong.github.io/posts/1728.html</id>
    <published>2023-03-18T02:41:18.000Z</published>
    <updated>2023-03-18T07:08:09.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>接上次部署NextCloud，继续把原来服务器上的opengrok部署过来。</p><p>opengrok是我们在开发DragonOS的过程中的源码阅读工具，用起来还不错，可以实现函数的跳转，方便快速查找内容。同时还可以查看历史版本。推荐大家使用，让我们一起<strong>RTFSC</strong>(Reading The F**king Source Code!)— Linus</p><h2 id="OpenGrok介绍"><a href="#OpenGrok介绍" class="headerlink" title="OpenGrok介绍"></a>OpenGrok介绍</h2><p>OpenGrok是一种流行的、功能强大的源代码搜索和交叉引用引擎，允许用户在多个存储库和语言中搜索和分析源代码。OpenGrok最初由Sun Microsystems创建，并在后来在CDDL许可下开源。</p><p>OpenGrok提供基于Web的界面，允许用户浏览、搜索和分析源代码，包括代码历史、语法高亮和交叉引用等功能。它支持广泛的编程语言和源代码控制系统，包括Git、Mercurial、Subversion、CVS和ClearCase等。</p><p>OpenGrok广泛应用于软件开发人员、系统管理员和其他需要处理大型代码库的技术专业人员。它可以帮助用户快速找到和分析代码、识别依赖关系和跟踪时间的变化等用例。OpenGrok还具有高度的可定制性，允许用户配置其行为以适应其特定需求。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>本文是在CentOS7.6，docker版本是23.0.1</p><ol><li><p>获取最新opengrok镜像：docker pull opengrok&#x2F;docker</p></li><li><p>运行opengrok容器</p><ol><li><p><code>docker run -d -v &lt;path/to/your/src&gt;:/opengrok/src -e SYNC_PERIOD_MINUTES=30 -p 18080:8080 opengrok/docker:latest</code></p></li><li><p>参数说明</p><ol><li>-d：后台运行</li><li>-v：将宿主机的某个目录挂载到容器内的目录，这里是将某个目录挂载到<code>/opengrok/src</code></li><li>-p：将宿主机的18080端口映射到容器的8080端口</li><li>-e：设置环境变量，SYNC_PERIOD_MINUTES是索引的更新周期，这里设置半小时更新一次</li></ol></li><li><p>映射包含以下目录</p><ol><li><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/opengrok/etc</code></td><td>存储 Web 应用和索引器的配置</td></tr><tr><td><code>/opengrok/data</code></td><td>数据根 - 索引数据</td></tr><tr><td><code>/opengrok/src</code></td><td>源根目录 - 输入数据</td></tr><tr><td><code>/scripts</code></td><td>启动脚本和顶级配置。除非进行调试，否则不要重写。</td></tr></tbody></table></li><li><p>更多配置可以参考opengrok官网，<a href="https://github.com/oracle/opengrok/tree/master/docker">Opengrok&#x2F;docker at Master ·甲骨文&#x2F;Opengrok (github.com)</a></p></li></ol></li></ol></li><li><p>进入容器</p><ol><li><code>docker exec -it &lt;container&gt; bash</code>通过命令进入容器修改你想要的配置</li></ol></li><li><p>访问索引的源代码。一旦索引完成，您就可以使用OpenGrok Web界面搜索和查看您的源代码了。</p><ol><li>我这里通过 <code>ip:18080</code>访问</li></ol></li></ol><blockquote><p>需要注意的是，你的仓库如果是在github上，你需要在保证仓库是完整的放在 &lt;path&#x2F;to&#x2F;your&#x2F;src&gt;下的，我最开始的时候，只是从windows上复制了文件到linux上，但文件夹里没有.git的信息，所以他没被识别为git仓库，所以建索引的时候会报一些错误，导致无法定时更新索引，我猜是因为他找不到目标地址。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/oracle/opengrok/tree/master/docker">Opengrok&#x2F;docker at Master ·甲骨文&#x2F;Opengrok (github.com)</a></p><p><a href="https://blog.csdn.net/yinni11/article/details/81559175">【docker】docker run命令详解_yinni11的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;接上次部署NextCloud，继续把原来服务器上的opengrok部署过来。&lt;/p&gt;
&lt;p&gt;opengrok是我们在开发Dr</summary>
      
    
    
    
    <category term="服务器" scheme="https://kkkkkong.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="docker" scheme="https://kkkkkong.github.io/tags/docker/"/>
    
    <category term="opengrok" scheme="https://kkkkkong.github.io/tags/opengrok/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 183</title>
    <link href="https://kkkkkong.github.io/posts/15535.html"/>
    <id>https://kkkkkong.github.io/posts/15535.html</id>
    <published>2023-03-14T08:06:33.000Z</published>
    <updated>2023-03-18T06:56:06.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode.cn/problems/customers-who-never-order/">183. 从不订购的客户</a></h4><p>难度简单429收藏分享切换为英文接收动态反馈</p><p>SQL架构</p><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p><code>Customers</code> 表：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>-------+<br><span class="hljs-section">| Id | Name  |</span><br><span class="hljs-section">+----+-------+</span><br>| 1  | Joe   |<br>| 2  | Henry |<br>| 3  | Sam   |<br><span class="hljs-section">| 4  | Max   |</span><br><span class="hljs-section">+----+-------+</span><br></code></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------------+<br><span class="hljs-section">| Id | CustomerId |</span><br><span class="hljs-section">+----+------------+</span><br>| 1  | 3          |<br><span class="hljs-section">| 2  | 1          |</span><br><span class="hljs-section">+----+------------+</span><br></code></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------+</span><br><span class="hljs-section">| Customers |</span><br><span class="hljs-section">+-----------+</span><br>| Henry     |<br><span class="hljs-section">| Max       |</span><br><span class="hljs-section">+-----------+</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>leftjoin</li></ol><blockquote><p>执行用时：320 ms, 在所有 MySQL 提交中击败了88.37%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：11 &#x2F; 11</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-keyword">select</span><br>name <span class="hljs-keyword">as</span> Customers<br><br><span class="hljs-keyword">from</span><br><br>customers <span class="hljs-keyword">as</span> c <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> orders <span class="hljs-keyword">as</span> o<br><br><span class="hljs-keyword">on</span> c.id<span class="hljs-operator">=</span>o.customerid<br><br><span class="hljs-keyword">where</span> o.customerid <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;183-从不订购的客户&quot;&gt;&lt;a href=&quot;#183-从不订购的客户&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="数据库" scheme="https://kkkkkong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 225</title>
    <link href="https://kkkkkong.github.io/posts/40665.html"/>
    <id>https://kkkkkong.github.io/posts/40665.html</id>
    <published>2023-03-14T03:47:44.000Z</published>
    <updated>2023-03-14T03:50:02.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;MyStack&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyStack myStack = <span class="hljs-keyword">new</span> MyStack();<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>myStack.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.empty(); <span class="hljs-comment">// 返回 False</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>一个队列模拟：N个长度的队列，出队n-1次，下一次出队的元素就是我们要的。主要主要pop的时候对于top元素的保存</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.2 MB, 在所有 Java 提交中击败了67.93%的用户</p><p>通过测试用例：17 &#x2F; 17</p><p>时间 n</p><p>空间 n</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    ArrayList&lt;Integer&gt; list;<br>    <span class="hljs-type">int</span> top;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        top=<span class="hljs-number">0</span>;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        list.add(x);<br>        top=x;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> size=list.size();<br>        <span class="hljs-keyword">while</span>(size&gt;<span class="hljs-number">1</span>)&#123;<br>            top=list.get(<span class="hljs-number">0</span>);<br>            list.add(list.remove(<span class="hljs-number">0</span>));<br>            size--;<br>        &#125;<br>        <span class="hljs-type">int</span> tmp=list.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> tmp;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;225-用队列实现栈&quot;&gt;&lt;a href=&quot;#225-用队列实现栈&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
