<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-04-05T01:15:46.543Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 92</title>
    <link href="https://kkkkkong.github.io/posts/26852.html"/>
    <id>https://kkkkkong.github.io/posts/26852.html</id>
    <published>2023-04-05T01:14:16.000Z</published>
    <updated>2023-04-05T01:15:46.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/rev2ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，主要在于找到被反转的链表，然后切割，与无关字符串断开</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.9 MB, 在所有 Java 提交中击败了84.13%的用户</p><p>通过测试用例：44 &#x2F; 44</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        ListNode zeroNode=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode res=zeroNode;</span><br><span class="line">        zeroNode.next=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            zeroNode=zeroNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode prev=zeroNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            zeroNode=zeroNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode rightNode=zeroNode;</span><br><span class="line">        ListNode leftNode=prev.next;</span><br><span class="line">        prev.next=<span class="literal">null</span>;</span><br><span class="line">        ListNode afNode=rightNode.next;</span><br><span class="line">        rightNode.next=<span class="literal">null</span>;</span><br><span class="line">        prev.next= reverseList(leftNode);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            prev=prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next=afNode;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode prev=<span class="literal">null</span>;</span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode tmp=curr.next;</span><br><span class="line">            curr.next=prev;</span><br><span class="line">            prev=curr;</span><br><span class="line">            curr=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;92-反转链表-II&quot;&gt;&lt;a href=&quot;#92-反转链表-II&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 196</title>
    <link href="https://kkkkkong.github.io/posts/44910.html"/>
    <id>https://kkkkkong.github.io/posts/44910.html</id>
    <published>2023-03-22T01:47:12.000Z</published>
    <updated>2023-03-22T01:48:17.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode.cn/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></h4><p>SQL架构</p><p>表: <code>Person</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| id          | int     |</span><br><span class="line">| email       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">id是该表的主键列。</span><br><span class="line">该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。</span><br></pre></td></tr></table></figure><p>编写一个 SQL <strong>删除语句</strong>来 <strong>删除</strong> 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。</p><p>以 <strong>任意顺序</strong> 返回结果表。 （<strong>注意</strong>： 仅需要写删除语句，将自动对剩余结果进行查询）</p><p>查询结果格式如下所示。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Person 表:</span><br><span class="line">+----+------------------+</span><br><span class="line">| id | email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">输出: </span><br><span class="line">+----+------------------+</span><br><span class="line">| id | email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br><span class="line">解释: john@example.com重复两次。我们保留最小的Id = 1。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解</li></ol><blockquote><p>执行用时：577 ms, 在所有 MySQL 提交中击败了82.16%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：22 &#x2F; 22</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Please write a <span class="keyword">DELETE</span> statement <span class="keyword">and</span> DO <span class="keyword">NOT</span> write a <span class="keyword">SELECT</span> statement.</span><br><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">DELETE</span> p1</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">person p1,person p2</span><br><span class="line"><span class="keyword">where</span> p1.email<span class="operator">=</span>p2.email <span class="keyword">and</span> p1.id<span class="operator">&gt;</span>p2.id;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;196-删除重复的电子邮箱&quot;&gt;&lt;a href=&quot;#196-删除重复的电子邮箱&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 182</title>
    <link href="https://kkkkkong.github.io/posts/64622.html"/>
    <id>https://kkkkkong.github.io/posts/64622.html</id>
    <published>2023-03-22T01:37:18.000Z</published>
    <updated>2023-03-22T01:39:59.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode.cn/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></h4><p>SQL架构</p><p>表: <code>Person</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| id          | int     |</span><br><span class="line">| email       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">id 是该表的主键列。</span><br><span class="line">此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。</p><p>以 <strong>任意顺序</strong> 返回结果表。</p><p>查询结果格式如下例。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Person 表:</span><br><span class="line">+----+---------+</span><br><span class="line">| id | email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br><span class="line">输出: </span><br><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br><span class="line">解释: a@b.com 出现了两次。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先建立一个子表，在查询</li></ol><blockquote><p>执行用时：378 ms, 在所有 MySQL 提交中击败了58.00%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：15 &#x2F; 15</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">Email</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span></span><br><span class="line">email,<span class="built_in">count</span>(email) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">email) <span class="keyword">as</span> tab</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">&gt;</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>group by+having</li></ol><blockquote><p>执行用时：435 ms, 在所有 MySQL 提交中击败了15.93%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：15 &#x2F; 15</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">Email</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">Email</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(Email)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;182-查找重复的电子邮箱&quot;&gt;&lt;a href=&quot;#182-查找重复的电子邮箱&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 144</title>
    <link href="https://kkkkkong.github.io/posts/65259.html"/>
    <id>https://kkkkkong.github.io/posts/65259.html</id>
    <published>2023-03-22T01:23:30.000Z</published>
    <updated>2023-03-22T01:31:40.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>难度简单1028收藏分享切换为英文接收动态反馈</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了35.01%的用户</p><p>通过测试用例：70 &#x2F; 70</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        getNode(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        getNode(root.left);</span><br><span class="line">        getNode(root.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 145</title>
    <link href="https://kkkkkong.github.io/posts/15914.html"/>
    <id>https://kkkkkong.github.io/posts/15914.html</id>
    <published>2023-03-22T01:20:51.000Z</published>
    <updated>2023-03-22T01:21:54.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>难度简单1009收藏分享切换为英文接收动态反馈</p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/pre1.jpg" alt="img"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了38.80%的用户</p><p>通过测试用例：68 &#x2F; 68</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        getNode(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        getNode(root.left);</span><br><span class="line">        getNode(root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DragonOS前三个进程的创建</title>
    <link href="https://kkkkkong.github.io/posts/13195.html"/>
    <id>https://kkkkkong.github.io/posts/13195.html</id>
    <published>2023-03-20T08:43:40.000Z</published>
    <updated>2023-03-20T11:35:03.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统加载过程"><a href="#操作系统加载过程" class="headerlink" title="操作系统加载过程"></a>操作系统加载过程</h2><ol><li>内核引导<ol><li>POST</li><li>BIOS</li><li>MBR：主引导记录</li><li>硬盘启动，grub，选择启用哪个系统</li><li>操作系统：start，手动创建0号进程</li></ol></li><li>加载init，1，2号进程的初始化</li><li>系统初始化：加载开机启动程序 init.d</li><li>建立终端</li><li>用户登录</li></ol><p><img src="https://e1sw9jmnjt.feishu.cn/space/api/box/stream/download/asynccode/?code=NGZlMDI2YTA3NmY3NzQ0MjQyYjUyODVkNWI5YWVhMmNfQlRMc21VVXROWjU5NjljRzFPeUxuRTliYjlUMGdOcXBfVG9rZW46WkNVWmIzbHBZb1NiZTV4c1F3dGNyTGFkbm9lXzE2NzkzMDMzMDg6MTY3OTMwNjkwOF9WNA" alt="img"></p><h2 id="进程创建的时机"><a href="#进程创建的时机" class="headerlink" title="进程创建的时机"></a>进程创建的时机</h2><p>do_fork()</p><p>任何进程都是由其他进程创建的。<strong>操作系统通过系统调用fork(),vfork()和clone()函数来完成进程的创建。</strong></p><ul><li><strong>这三个系统调用最终都调用了内核函数do_fork()</strong></li><li><strong>这三个函数的唯一区别在于随后调用do_fork(0时设置的标志不同。</strong></li></ul><h2 id="进程的功能"><a href="#进程的功能" class="headerlink" title="进程的功能"></a>进程的功能</h2><h3 id="0号进程：IDLE"><a href="#0号进程：IDLE" class="headerlink" title="0号进程：IDLE"></a>0号进程：IDLE</h3><p>系统中的第一个进程，PID为0，是init进程和kthread的父进程，</p><h3 id="1号进程：init"><a href="#1号进程：init" class="headerlink" title="1号进程：init"></a>1号进程：init</h3><p>是第一个用户空间的进程，PID为1，是其他用户空间进程的父进程</p><h3 id="2号进程：kthreadd"><a href="#2号进程：kthreadd" class="headerlink" title="2号进程：kthreadd"></a>2号进程：kthreadd</h3><p>是内核空间其他内核进程的父进程，PID为2，</p><p>负责内核线程的创建工作</p><p>结构树(篇幅原因移除部分子进程)</p><blockquote><p>[root@VM-8-5-centos ~]# pstree 0 -p<br>?()─┬─kthreadd(2)─┬─ata_sff(257)<br>    │             ├─bioset(23)<br>    │             ├─bioset(24)<br>    │             ├─bioset(25)<br>    │             ├─crypto(38)<br>    └─systemd(1)─┬─YDLive(1789)─┬─YDService(2493)─┬─sh(2603)─┬─{sh}(2604)<br>                 │              │                 │          ├─{sh}(2605)<br>                 │              │                 │          ├─{sh}(2609)<br>                 │              │                 │          ├─{sh}(2610)<br>                 │              │                 │          └─{sh}(15243)<br>                 │              │                 ├─{YDService}(2494)<br>                 │              │                 ├─{YDService}(2497)<br>                 │              ├─{YDLive}(1790)<br>                 │              ├─{YDLive}(1796)<br>                 │              └─{YDLive}(6911)<br>                 ├─abrt-dbus(21662)─┬─{abrt-dbus}(21663)<br>                 │                  └─{abrt-dbus}(21665)<br>                 ├─acpid(666)</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/joggingpig/article/details/110239518">Linux中的特殊进程：idle进程、init进程、kthreadd进程_JoggingPig的博客-CSDN博客</a></p><p>sql语句查询过程</p><p>查缓存</p><p>解析器：语法、词法</p><p>优化器：逻辑优化、物理</p><p>执行器：</p><h1 id="解决由于在中断上下文以外，sched-enqueue时，未关中断导致cpu-queue双重加锁的问题-201"><a href="#解决由于在中断上下文以外，sched-enqueue时，未关中断导致cpu-queue双重加锁的问题-201" class="headerlink" title="解决由于在中断上下文以外，sched_enqueue时，未关中断导致cpu_queue双重加锁的问题 #201"></a>解决由于在中断上下文以外，sched_enqueue时，未关中断导致cpu_queue双重加锁的问题 #201</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统加载过程&quot;&gt;&lt;a href=&quot;#操作系统加载过程&quot; class=&quot;headerlink&quot; title=&quot;操作系统加载过程&quot;&gt;&lt;/a&gt;操作系统加载过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内核引导&lt;ol&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;li&gt;BIOS&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="DragonOS" scheme="https://kkkkkong.github.io/categories/DragonOS/"/>
    
    
    <category term="DragonOS" scheme="https://kkkkkong.github.io/tags/DragonOS/"/>
    
  </entry>
  
  <entry>
    <title>docker 部署opengrok方便代码阅读</title>
    <link href="https://kkkkkong.github.io/posts/1728.html"/>
    <id>https://kkkkkong.github.io/posts/1728.html</id>
    <published>2023-03-18T02:41:18.000Z</published>
    <updated>2023-03-18T07:08:09.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>接上次部署NextCloud，继续把原来服务器上的opengrok部署过来。</p><p>opengrok是我们在开发DragonOS的过程中的源码阅读工具，用起来还不错，可以实现函数的跳转，方便快速查找内容。同时还可以查看历史版本。推荐大家使用，让我们一起<strong>RTFSC</strong>(Reading The F**king Source Code!)— Linus</p><h2 id="OpenGrok介绍"><a href="#OpenGrok介绍" class="headerlink" title="OpenGrok介绍"></a>OpenGrok介绍</h2><p>OpenGrok是一种流行的、功能强大的源代码搜索和交叉引用引擎，允许用户在多个存储库和语言中搜索和分析源代码。OpenGrok最初由Sun Microsystems创建，并在后来在CDDL许可下开源。</p><p>OpenGrok提供基于Web的界面，允许用户浏览、搜索和分析源代码，包括代码历史、语法高亮和交叉引用等功能。它支持广泛的编程语言和源代码控制系统，包括Git、Mercurial、Subversion、CVS和ClearCase等。</p><p>OpenGrok广泛应用于软件开发人员、系统管理员和其他需要处理大型代码库的技术专业人员。它可以帮助用户快速找到和分析代码、识别依赖关系和跟踪时间的变化等用例。OpenGrok还具有高度的可定制性，允许用户配置其行为以适应其特定需求。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>本文是在CentOS7.6，docker版本是23.0.1</p><ol><li><p>获取最新opengrok镜像：docker pull opengrok&#x2F;docker</p></li><li><p>运行opengrok容器</p><ol><li><p><code>docker run -d -v &lt;path/to/your/src&gt;:/opengrok/src -e SYNC_PERIOD_MINUTES=30 -p 18080:8080 opengrok/docker:latest</code></p></li><li><p>参数说明</p><ol><li>-d：后台运行</li><li>-v：将宿主机的某个目录挂载到容器内的目录，这里是将某个目录挂载到<code>/opengrok/src</code></li><li>-p：将宿主机的18080端口映射到容器的8080端口</li><li>-e：设置环境变量，SYNC_PERIOD_MINUTES是索引的更新周期，这里设置半小时更新一次</li></ol></li><li><p>映射包含以下目录</p><ol><li><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/opengrok/etc</code></td><td>存储 Web 应用和索引器的配置</td></tr><tr><td><code>/opengrok/data</code></td><td>数据根 - 索引数据</td></tr><tr><td><code>/opengrok/src</code></td><td>源根目录 - 输入数据</td></tr><tr><td><code>/scripts</code></td><td>启动脚本和顶级配置。除非进行调试，否则不要重写。</td></tr></tbody></table></li><li><p>更多配置可以参考opengrok官网，<a href="https://github.com/oracle/opengrok/tree/master/docker">Opengrok&#x2F;docker at Master ·甲骨文&#x2F;Opengrok (github.com)</a></p></li></ol></li></ol></li><li><p>进入容器</p><ol><li><code>docker exec -it &lt;container&gt; bash</code>通过命令进入容器修改你想要的配置</li></ol></li><li><p>访问索引的源代码。一旦索引完成，您就可以使用OpenGrok Web界面搜索和查看您的源代码了。</p><ol><li>我这里通过 <code>ip:18080</code>访问</li></ol></li></ol><blockquote><p>需要注意的是，你的仓库如果是在github上，你需要在保证仓库是完整的放在 &lt;path&#x2F;to&#x2F;your&#x2F;src&gt;下的，我最开始的时候，只是从windows上复制了文件到linux上，但文件夹里没有.git的信息，所以他没被识别为git仓库，所以建索引的时候会报一些错误，导致无法定时更新索引，我猜是因为他找不到目标地址。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/oracle/opengrok/tree/master/docker">Opengrok&#x2F;docker at Master ·甲骨文&#x2F;Opengrok (github.com)</a></p><p><a href="https://blog.csdn.net/yinni11/article/details/81559175">【docker】docker run命令详解_yinni11的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;接上次部署NextCloud，继续把原来服务器上的opengrok部署过来。&lt;/p&gt;
&lt;p&gt;opengrok是我们在开发Dr</summary>
      
    
    
    
    <category term="服务器" scheme="https://kkkkkong.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="docker" scheme="https://kkkkkong.github.io/tags/docker/"/>
    
    <category term="opengrok" scheme="https://kkkkkong.github.io/tags/opengrok/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 183</title>
    <link href="https://kkkkkong.github.io/posts/15535.html"/>
    <id>https://kkkkkong.github.io/posts/15535.html</id>
    <published>2023-03-14T08:06:33.000Z</published>
    <updated>2023-03-18T06:56:06.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode.cn/problems/customers-who-never-order/">183. 从不订购的客户</a></h4><p>难度简单429收藏分享切换为英文接收动态反馈</p><p>SQL架构</p><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p><code>Customers</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>leftjoin</li></ol><blockquote><p>执行用时：320 ms, 在所有 MySQL 提交中击败了88.37%的用户</p><p>内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p><p>通过测试用例：11 &#x2F; 11</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">name <span class="keyword">as</span> Customers</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"></span><br><span class="line">customers <span class="keyword">as</span> c <span class="keyword">left</span> <span class="keyword">join</span> orders <span class="keyword">as</span> o</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> c.id<span class="operator">=</span>o.customerid</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> o.customerid <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;183-从不订购的客户&quot;&gt;&lt;a href=&quot;#183-从不订购的客户&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="数据库" scheme="https://kkkkkong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 225</title>
    <link href="https://kkkkkong.github.io/posts/40665.html"/>
    <id>https://kkkkkong.github.io/posts/40665.html</id>
    <published>2023-03-14T03:47:44.000Z</published>
    <updated>2023-03-14T03:50:02.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>一个队列模拟：N个长度的队列，出队n-1次，下一次出队的元素就是我们要的。主要主要pop的时候对于top元素的保存</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.2 MB, 在所有 Java 提交中击败了67.93%的用户</p><p>通过测试用例：17 &#x2F; 17</p><p>时间 n</p><p>空间 n</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        list.add(x);</span><br><span class="line">        top=x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> size=list.size();</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            top=list.get(<span class="number">0</span>);</span><br><span class="line">            list.add(list.remove(<span class="number">0</span>));</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp=list.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;225-用队列实现栈&quot;&gt;&lt;a href=&quot;#225-用队列实现栈&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 232</title>
    <link href="https://kkkkkong.github.io/posts/52377.html"/>
    <id>https://kkkkkong.github.io/posts/52377.html</id>
    <published>2023-03-14T03:35:06.000Z</published>
    <updated>2023-03-14T03:50:02.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><p>难度简单857收藏分享切换为英文接收动态反馈</p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>两个栈模拟队列</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了43.68%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(n)，平均O(1)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; s1,s2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        s1=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        s2=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty()&amp;&amp;s2.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 460</title>
    <link href="https://kkkkkong.github.io/posts/23803.html"/>
    <id>https://kkkkkong.github.io/posts/23803.html</id>
    <published>2023-03-14T02:48:40.000Z</published>
    <updated>2023-03-14T03:06:40.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU 缓存</a></h4><p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">// cnt(x) = 键 x 的使用计数</span><br><span class="line">// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lfu = new LFUCache(2);</span><br><span class="line">lfu.put(1, 1);   // cache=[1,_], cnt(1)=1</span><br><span class="line">lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1</span><br><span class="line">lfu.get(1);      // 返回 1</span><br><span class="line">                 // cache=[1,2], cnt(2)=1, cnt(1)=2</span><br><span class="line">lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小</span><br><span class="line">                 // cache=[3,1], cnt(3)=1, cnt(1)=2</span><br><span class="line">lfu.get(2);      // 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      // 返回 3</span><br><span class="line">                 // cache=[3,1], cnt(3)=2, cnt(1)=2</span><br><span class="line">lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                 // cache=[4,3], cnt(4)=1, cnt(3)=2</span><br><span class="line">lfu.get(1);      // 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      // 返回 3</span><br><span class="line">                 // cache=[3,4], cnt(4)=1, cnt(3)=3</span><br><span class="line">lfu.get(4);      // 返回 4</span><br><span class="line">                 // cache=[3,4], cnt(4)=2, cnt(3)=3</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+linkedHashSet：通过三个结构来存储当前情况，<ol><li>key2Val 用来存放key对应的value</li><li>key2Freq 用来存放key出现的频率</li><li>freq2keys 用来存放频率对应的key的列表。因为在频率相同的情况下，需要抛弃最久未使用的，因此需要用有序的结构存储，而且需要O(1)的时间复杂度，因此LinkedHashSet最合适。</li></ol></li><li>整体思路不难，但很多细节，因为要操作很多数据表，CPU快给我干烧了</li></ol><blockquote><p>执行用时：69 ms, 在所有 Java 提交中击败了41.72%的用户</p><p>内存消耗：122.7 MB, 在所有 Java 提交中击败了45.30%的用户</p><p>通过测试用例：25 &#x2F; 25</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    HashMap &lt;Integer,Integer&gt; key2Val=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; key2Freq=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    HashMap&lt;Integer,LinkedHashSet&lt;Integer&gt;&gt; freq2keys=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="type">int</span> minCap=Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> cap=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(key2Val.containsKey(key))&#123;</span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span> key2Val.get(key); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已有key元素，那么修改</span></span><br><span class="line">        <span class="keyword">if</span>(key2Val.containsKey(key))&#123;</span><br><span class="line">            key2Val.put(key,value);</span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有，那么增加</span></span><br><span class="line">        <span class="comment">// 如果超出容量，需要去除lr的键</span></span><br><span class="line">        <span class="keyword">if</span>(key2Val.size()&gt;=cap)&#123;</span><br><span class="line">            removeMinFreq();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加</span></span><br><span class="line">        key2Val.put(key,value);</span><br><span class="line">        key2Freq.put(key,<span class="number">1</span>);</span><br><span class="line">        freq2keys.putIfAbsent(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Integer&gt;());</span><br><span class="line">        freq2keys.get(<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// LinkedHashSet set=freq2keys.getOrDefault(1,new LinkedHashSet&lt;Integer&gt;());</span></span><br><span class="line">        <span class="comment">// set.add(key);</span></span><br><span class="line">        <span class="comment">// freq2keys.put(1,set);</span></span><br><span class="line">        minCap=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMinFreq</span><span class="params">()</span>&#123;</span><br><span class="line">        LinkedHashSet&lt;Integer&gt; set= freq2keys.get(minCap);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> set.iterator().next();</span><br><span class="line">        set.remove(deletedKey);</span><br><span class="line">        <span class="keyword">if</span>(set.isEmpty())&#123;</span><br><span class="line">            freq2keys.remove(minCap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        key2Val.remove(deletedKey);</span><br><span class="line">        key2Freq.remove(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> freq=key2Freq.get(key);</span><br><span class="line"></span><br><span class="line">        LinkedHashSet set=freq2keys.get(freq);</span><br><span class="line">        <span class="comment">// 从set中移除掉当前freq中的队列中的key</span></span><br><span class="line">        set.remove(key);</span><br><span class="line">        <span class="keyword">if</span>(set.isEmpty())&#123;</span><br><span class="line">            freq2keys.remove(freq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将key加入到freq+1的队列中去</span></span><br><span class="line">        freq2keys.putIfAbsent(freq+<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Integer&gt;());</span><br><span class="line">        freq2keys.get(freq+<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 更新key2Freq</span></span><br><span class="line">        key2Freq.put(key,freq+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(minCap==freq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.isEmpty())&#123;</span><br><span class="line">                minCap++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;460-LFU-缓存&quot;&gt;&lt;a href=&quot;#460-LFU-缓存&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS上用docker部署NextCloud，实现多设备文件协同</title>
    <link href="https://kkkkkong.github.io/posts/28348.html"/>
    <id>https://kkkkkong.github.io/posts/28348.html</id>
    <published>2023-03-13T08:35:43.000Z</published>
    <updated>2023-03-13T09:04:05.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>最近上一个服务器到期了，上面部署着以前的NextCloud，又新租了一个服务器，准备重新配置，顺便记录下</p><h2 id="NextCloud介绍"><a href="#NextCloud介绍" class="headerlink" title="NextCloud介绍"></a>NextCloud介绍</h2><p>NextCloud是我以前在寻找OneDrive的平替版找到的一块软件，我平时在实验室、宿舍以及笔记本上要看论文或者写一些文档，当时的文件同步给我造成了很大的困扰，在寻找解决方案时找到了这款软件，用起来比较舒服，传输速度取决于你的服务器带宽，一般来说是够用的，维基百科中对他的介绍是这样的：</p><blockquote><p><strong>Nextcloud</strong>是一套用于创建<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E7%A1%AC%E7%9B%98">网络硬盘</a>的<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BE%9E%E5%BC%8F%E6%9E%B6%E6%A7%8B">客户端－服务器软件</a>。其功能与<a href="https://zh.wikipedia.org/wiki/Dropbox">Dropbox</a>相近，但Nextcloud是<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%8A%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6">自由及开放源代码软件</a>，每个人都可以在私人服务器上安装并执行它。</p><p>与Dropbox等专有服务相比，Nextcloud的开放架构让用户可以利用应用程序的方式在服务器上新增额外的功能，并让用户可以完全掌控自己的资料。</p><p><a href="https://zh.wikipedia.org/zh-cn/Nextcloud">Nextcloud - 维基百科，自由的百科全书 (wikipedia.org)</a></p></blockquote><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>本文是在CentOS7.6，docker版本是23.0.1</p><ol><li><p>安装docker，具体的细节参照菜鸟教程：<a href="https://www.runoob.com/docker/centos-docker-install.html">CentOS Docker 安装 | 菜鸟教程 (runoob.com)</a></p></li><li><p>获取最新版NextCloud镜像</p><ol><li><p>docker search一下现有与NextCloud相关的内容，docker search nextcloud，发现第一个就是，而且是官方高星的</p><ol><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230313164208285.png" alt="image-20230313164208285" style="zoom: 50%;" /></li></ol></li><li><p>docker pull nextcloud 获取最新版本</p></li><li><p>创建容器</p><ol><li><pre><code>docker run -d -p 8080:80 -v /home/nextcloud:/var/www/html --name nextcloud nextcloud</code></pre></li><li><p>-d #容器后台运行</p><p>–name nextcloud #容器名</p><p>-v &#x2F;data&#x2F;nextcloud:&#x2F;var&#x2F;www&#x2F;html #将宿主机的目录&#x2F;data&#x2F;nextcloud挂载到容器的&#x2F;var&#x2F;www&#x2F;html</p><p>-p 18000:80 #将宿主机的端口（此处以18000为例）映射到容器的80端口</p></li></ol></li></ol></li><li><p>web 登录</p><ol><li>第一次使用nextcloud要通过Web端进行配置，记得开启云服务器上对应的端口，这里是18000端口，按照自己的需求配置<ol><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230313164518805.png" alt="image-20230313164518805" style="zoom: 50%;" /></li></ol></li><li>访问ip:18000<ol><li>此处需要设置密码和选择相应的数据库，我这里是个人使用，所以就直接用了SQLLite，如果是多人协作，官方推荐使用mysql等数据库（我这里忘记截图了，就偷个懒）</li></ol></li></ol></li><li><p>客户端下载</p><ol><li>访问官方<a href="https://nextcloud.com/install/">Install - Nextcloud</a>下载对应版本资源，安装然后配置链接即可</li><li>Windows上安装好之后是这个样子，登录到你的账号，注意这里填了地址之后会默认按照https方式链接，我这里会报错，改成http即可</li><li><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230313164953262.png" alt="image-20230313164953262" style="zoom:50%;" /></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h2&gt;&lt;p&gt;最近上一个服务器到期了，上面部署着以前的NextCloud，又新租了一个服务器，准备重新配置，顺便记录下&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="服务器" scheme="https://kkkkkong.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="NextCloud" scheme="https://kkkkkong.github.io/tags/NextCloud/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 146</title>
    <link href="https://kkkkkong.github.io/posts/16234.html"/>
    <id>https://kkkkkong.github.io/posts/16234.html</id>
    <published>2023-03-13T02:24:44.000Z</published>
    <updated>2023-03-13T06:36:03.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h4><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>LinkedHashMap实现</li></ol><blockquote><p>执行用时：52 ms, 在所有 Java 提交中击败了30.61%的用户</p><p>内存消耗：117.7 MB, 在所有 Java 提交中击败了10.73%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(1)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=map.getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans !=-<span class="number">1</span>)&#123;</span><br><span class="line">            makeRecently(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">            map.put(key,value); </span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(map.size()&gt;=cap)&#123;</span><br><span class="line">            <span class="type">int</span> firstKey=map.keySet().iterator().next();</span><br><span class="line">            map.remove(firstKey);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> val=map.get(key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">        map.put(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>自实现双向链表+哈希表：费了老鼻子劲，主要是那几个抽出来操作map和list的函数，需要想清楚他们使用的场景</li></ol><blockquote><p>执行用时：48 ms, 在所有 Java 提交中击败了43.19%的用户</p><p>内存消耗：116.2 MB, 在所有 Java 提交中击败了17.51%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(1)</p><p>空间 O(N)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    int key,val;</span><br><span class="line">    Node prev,next;</span><br><span class="line">    public Node(int key,int val)&#123;</span><br><span class="line">        this.key=key;</span><br><span class="line">        this.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class DoubleList&#123;</span><br><span class="line">    Node head,tail;</span><br><span class="line">    int size;</span><br><span class="line">    public DoubleList()&#123;</span><br><span class="line">        head =new Node(0,0);</span><br><span class="line">        tail =new Node(0,0);</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.prev=head;</span><br><span class="line">        size=0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addNode(Node node)&#123;</span><br><span class="line">        node.prev=tail.prev;</span><br><span class="line">        node.next=tail;</span><br><span class="line"></span><br><span class="line">        tail.prev.next=node;</span><br><span class="line">        tail.prev=node;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    public void removeNode(Node node)&#123;</span><br><span class="line">        node.prev.next=node.next;</span><br><span class="line">        node.next.prev=node.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    public Node removeFirstNode()&#123;</span><br><span class="line">        if(head.next==tail)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node first =head.next;</span><br><span class="line">        this.removeNode(first);</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">    int cap;</span><br><span class="line">    DoubleList list=new DoubleList();</span><br><span class="line">    HashMap&lt;Integer,Node&gt; map=new HashMap();</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        if(!map.containsKey(key))&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        return map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if(map.containsKey(key))&#123;</span><br><span class="line">            deleteKey(key);</span><br><span class="line">            addRecently(key,value);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list.size()&gt;=cap)&#123;</span><br><span class="line">            removeLeastRecently();</span><br><span class="line">        &#125;</span><br><span class="line">        addRecently(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    public void makeRecently(int key)&#123;</span><br><span class="line">        </span><br><span class="line">        Node node=map.get(key);</span><br><span class="line">        list.removeNode(node);</span><br><span class="line">        list.addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteKey(int key)&#123;</span><br><span class="line">        Node node=map.get(key);</span><br><span class="line">        list.removeNode(node);</span><br><span class="line">        map.remove(key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void removeLeastRecently()&#123;</span><br><span class="line">        Node node=list.removeFirstNode();</span><br><span class="line">        map.remove(node.key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // put的处理，将普通元素提到最近使用</span><br><span class="line">    public void addRecently(int key,int value)&#123;</span><br><span class="line">        Node node =new Node(key,value);</span><br><span class="line">        list.addNode(node);</span><br><span class="line">        map.put(key,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;146-LRU-缓存&quot;&gt;&lt;a href=&quot;#146-LRU-缓存&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DragonOS 多核负载均衡</title>
    <link href="https://kkkkkong.github.io/posts/46077.html"/>
    <id>https://kkkkkong.github.io/posts/46077.html</id>
    <published>2023-03-11T06:35:35.000Z</published>
    <updated>2023-03-11T09:49:31.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>操作系统中CPU有多个核，（为了方便介绍，后续称为多个CPU），为了减少每个CPU之间的干扰，每个CPU上都有对应的运行队列。整个操作系统运行的过程中，可能存在有的CPU非常忙，有的CPU非常闲，因此需要有负载均衡来平衡各个CPU之间的负载。</p><p>将pcb从负载较重的CPU上转移到负载相对较轻的CPU上执行，这个过程就是负载均衡</p><h2 id="常见负载均衡方法"><a href="#常见负载均衡方法" class="headerlink" title="常见负载均衡方法"></a>常见负载均衡方法</h2><p>负载均衡的发展历程如下：</p><ol><li>根据运行队列的长度作为当前的负载</li><li>计算过去一段时间的运行的队列数量，加权作为负载</li></ol><h2 id="本文使用方法"><a href="#本文使用方法" class="headerlink" title="本文使用方法"></a>本文使用方法</h2><p>根据过去一段时间的运行队列的活跃程度，以及对应进程的权重作为负载的主要参数</p><ol><li>设置一个load_list用来存放当前核上的pcb加入队列的时钟数</li><li>计算每个核的过去一段时间的运行队列数量<ol><li>在进行入队操作时，通过rdtsc()获取当前的时钟，并将当前时钟加入load_list</li><li>将队首元素中与当前时钟差距大于一个临界值的全部出队列</li></ol></li><li>获取CPU的的负载时，只需要获取对应的load_list的长度即可</li></ol><blockquote><ol><li>关于临界值的判断</li></ol><p>假设load_list队首元素的值为a，当前时钟数为b，当前系统的CPU频率为2.5GHZ，那么(a-b)&#x2F;2.5×10^9^即为两次入队操作经过的时间，假设我们的临界值为t，t的意义为统计过去t秒的CPU的负载情况，那么需要 (a-b)&#x2F;2.5×10^9^&gt;t 是临界情况。</p><p>由于操作系统内核不能做浮点运算，将其调整为 (a-b)&gt;t×2.5×10^9^ 作为临界情况</p><ol start="2"><li>关于时钟数面临被重置导致b&lt;a，经查阅发现rdtsc() 获取的时钟数占据了64位，假设在2.5GHZ的CPU上跑，需要跑两百多年才会归零，因此可以忽略此问题。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230311174759773.png" alt="image-20230311174759773"></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/0c519fc6248b">使用rdtsc测量函数的执行时间 - 简书 (jianshu.com)</a></p><p><a href="http://www.wangkaixuan.tech/?p=901">细说RDTSC的坑 – Dreamer Thinker Doer (wangkaixuan.tech)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是负载均衡&quot;&gt;&lt;a href=&quot;#什么是负载均衡&quot; class=&quot;headerlink&quot; title=&quot;什么是负载均衡&quot;&gt;&lt;/a&gt;什么是负载均衡&lt;/h2&gt;&lt;p&gt;操作系统中CPU有多个核，（为了方便介绍，后续称为多个CPU），为了减少每个CPU之间的干扰，每个C</summary>
      
    
    
    
    <category term="DragonOS" scheme="https://kkkkkong.github.io/categories/DragonOS/"/>
    
    
    <category term="DragonOS" scheme="https://kkkkkong.github.io/tags/DragonOS/"/>
    
    <category term="负载均衡" scheme="https://kkkkkong.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 167</title>
    <link href="https://kkkkkong.github.io/posts/40874.html"/>
    <id>https://kkkkkong.github.io/posts/40874.html</id>
    <published>2023-03-10T01:47:54.000Z</published>
    <updated>2023-03-11T09:49:31.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [2,7,11,15], target = 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+双指针</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了36.44%的用户</p><p>内存消耗：44.3 MB, 在所有 Java 提交中击败了50.61%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(nlongn)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> sum=numbers[left]+numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> []&#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;167-两数之和-II-输入有序数组&quot;&gt;&lt;a href=&quot;#167-两数之和-II-输入有序数组&quot; class=&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习资料</title>
    <link href="https://kkkkkong.github.io/posts/50986.html"/>
    <id>https://kkkkkong.github.io/posts/50986.html</id>
    <published>2023-03-08T12:19:01.000Z</published>
    <updated>2023-03-08T12:24:28.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java复习资料"><a href="#Java复习资料" class="headerlink" title="Java复习资料"></a>Java复习资料</h2><blockquote><p>分享一些在准备Java面试过程中的常用资料，大多是别人整理的笔记</p></blockquote><ul><li>Java基础-尚硅谷康师傅课程笔记<ul><li><a href="https://blog.csdn.net/PorkBird/article/details/113666542">JavaSE目录_程序员卖剩鸭的博客-CSDN博客</a></li></ul></li><li>ssm+SpringBoot 全家桶-黑马程序员<ul><li><a href="https://www.yuque.com/kkuping/yuqzh2/nxtocy#CjngY">SpringMVC · 语雀 (yuque.com)</a></li></ul></li><li>Java常用面试题集合及路线规划<ul><li><a href="https://javaguide.cn/home.html">JavaGuide（Java学习&amp;&amp;面试指南） | JavaGuide(Java面试+学习指南)</a></li><li><a href="https://tobebetterjavaer.com/home.html">Java程序员进阶之路x沉默王二 | Java程序员进阶之路 (tobebetterjavaer.com)</a></li></ul></li><li>LeetCode模板<ul><li><a href="https://labuladong.github.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄</a></li></ul></li></ul><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java复习资料&quot;&gt;&lt;a href=&quot;#Java复习资料&quot; class=&quot;headerlink&quot; title=&quot;Java复习资料&quot;&gt;&lt;/a&gt;Java复习资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;分享一些在准备Java面试过程中的常用资料，大多是别人整理的笔记&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://kkkkkong.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://kkkkkong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 76</title>
    <link href="https://kkkkkong.github.io/posts/52193.html"/>
    <id>https://kkkkkong.github.io/posts/52193.html</id>
    <published>2023-03-08T07:05:06.000Z</published>
    <updated>2023-03-08T08:13:58.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口：</li></ol><blockquote><p>注意：Java 的 Integer，String 等类型判定相等不能使用&#x3D;&#x3D;，而要使用equals，这是包装类的一个细节</p></blockquote><blockquote><p>执行用时：14 ms, 在所有 Java 提交中击败了63.87%的用户</p><p>内存消耗：42.2 MB, 在所有 Java 提交中击败了38.80%的用户</p><p>通过测试用例：267 &#x2F; 267</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;t.length())<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map_s=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map_t=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=t.charAt(i);</span><br><span class="line">            map_t.put(c,map_t.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="type">char</span> c=s.charAt(right);</span><br><span class="line">            map_s.put(c,map_s.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map_t.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">if</span>(map_s.get(c).equals(map_t.get(c)))&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(num==map_t.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans&gt;right-left)&#123;</span><br><span class="line">                    l=left;</span><br><span class="line">                    r=right;</span><br><span class="line">                    ans=right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> c2=s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span>(map_t.containsKey(c2))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map_s.get(c2).equals(map_t.get(c2)))&#123;</span><br><span class="line">                        num--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    map_s.put(c2,map_s.get(c2)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;76-最小覆盖子串&quot;&gt;&lt;a href=&quot;#76-最小覆盖子串&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 34</title>
    <link href="https://kkkkkong.github.io/posts/51810.html"/>
    <id>https://kkkkkong.github.io/posts/51810.html</id>
    <published>2023-03-07T06:41:58.000Z</published>
    <updated>2023-03-07T06:52:22.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>两个二分，分别找左边界和右边界</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：44.2 MB, 在所有 Java 提交中击败了98.88%的用户</p><p>通过测试用例：88 &#x2F; 88</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> []ans=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==nums.length)ans[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">0</span>]=nums[left]==target?left:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;<span class="number">1</span>)ans[<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">1</span>]=nums[left-<span class="number">1</span>]==target?left-<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 704</title>
    <link href="https://kkkkkong.github.io/posts/16137.html"/>
    <id>https://kkkkkong.github.io/posts/16137.html</id>
    <published>2023-03-07T06:21:04.000Z</published>
    <updated>2023-03-07T06:52:22.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>二分</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：42.1 MB, 在所有 Java 提交中击败了50.35%的用户</p><p>通过测试用例：47 &#x2F; 47</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;704-二分查找&quot;&gt;&lt;a href=&quot;#704-二分查找&quot; class=&quot;headerlink&quot; title=&quot;7</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 752</title>
    <link href="https://kkkkkong.github.io/posts/28042.html"/>
    <id>https://kkkkkong.github.io/posts/28042.html</id>
    <published>2023-03-07T03:35:58.000Z</published>
    <updated>2023-03-07T03:37:24.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></h4><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为 <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>BFS</li></ol><blockquote><p>执行用时：86 ms, 在所有 Java 提交中击败了31.88%的用户</p><p>内存消耗：46.8 MB, 在所有 Java 提交中击败了58.50%的用户</p><p>通过测试用例：48 &#x2F; 48</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">up</span><span class="params">(String s,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">char</span> []charArray=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(charArray[i]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            charArray[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            charArray[i]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">down</span><span class="params">(String s,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">char</span> []charArray=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(charArray[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            charArray[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            charArray[i]-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] deadends, String target)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        Set&lt;String&gt; visited=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="comment">// for(String s:deadends)set.add(s);</span></span><br><span class="line">        Collections.addAll(set,deadends);</span><br><span class="line">        queue.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> len=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                String val=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(set.contains(val))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(val.equals(target))&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    String up=up(val,j);</span><br><span class="line">                    String down=down(val,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                        queue.offer(up);</span><br><span class="line">                        visited.add(up);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                        queue.offer(down);</span><br><span class="line">                        visited.add(down);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;752-打开转盘锁&quot;&gt;&lt;a href=&quot;#752-打开转盘锁&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
