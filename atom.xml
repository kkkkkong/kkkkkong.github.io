<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-02-07T02:36:49.745Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 1604</title>
    <link href="https://kkkkkong.github.io/posts/38940.html"/>
    <id>https://kkkkkong.github.io/posts/38940.html</id>
    <published>2023-02-07T02:27:38.000Z</published>
    <updated>2023-02-07T02:36:49.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1604-警告一小时内使用相同员工卡大于等于三次的人"><a href="#1604-警告一小时内使用相同员工卡大于等于三次的人" class="headerlink" title="1604. 警告一小时内使用相同员工卡大于等于三次的人"></a><a href="https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/">1604. 警告一小时内使用相同员工卡大于等于三次的人</a></h4><p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 <strong>警告</strong> 。</p><p>给你字符串数组 <code>keyName</code> 和 <code>keyTime</code> ，其中 <code>[keyName[i], keyTime[i]]</code> 对应一个人的名字和他在 <strong>某一天</strong> 内使用员工卡的时间。</p><p>使用时间的格式是 <strong>24小时制</strong> ，形如 <strong>“HH:MM”</strong> ，比方说 <code>&quot;23:51&quot;</code> 和 <code>&quot;09:49&quot;</code> 。</p><p>请你返回去重后的收到系统警告的员工名字，将它们按 <strong>字典序****升序</strong> 排序后返回。</p><p>请注意 <code>&quot;10:00&quot;</code> - <code>&quot;11:00&quot;</code> 视为一个小时时间范围内，而 <code>&quot;23:51&quot;</code> - <code>&quot;00:10&quot;</code> 不被视为一小时内，因为系统记录的是某一天内的使用情况。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：keyName = [&quot;daniel&quot;,&quot;daniel&quot;,&quot;daniel&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;], keyTime = [&quot;10:00&quot;,&quot;10:40&quot;,&quot;11:00&quot;,&quot;09:00&quot;,&quot;11:00&quot;,&quot;13:00&quot;,&quot;15:00&quot;]</span><br><span class="line">输出：[&quot;daniel&quot;]</span><br><span class="line">解释：&quot;daniel&quot; 在一小时内使用了 3 次员工卡（&quot;10:00&quot;，&quot;10:40&quot;，&quot;11:00&quot;）。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这个题题目示例给人的误导性很强，以为是时间是天然有序的，结果不然</p></blockquote><ol><li>哈希表+排序。按部就班，首先使用哈希表存储keyname和对应的set，然后遍历哈希表，找出一个小时内打卡次数&gt;&#x3D;3的人名，最后将人名按照字典序排序输出（这里的打卡时间是随机的，并非升序，因此需要排序后使用）</li></ol><blockquote><p>执行用时：65 ms, 在所有 Java 提交中击败了72.50%的用户</p><p>内存消耗：61.1 MB, 在所有 Java 提交中击败了67.50%的用户</p><p>通过测试用例：77 &#x2F; 77</p><p>时间 O(NlogN) 根据主要是排序时间</p><p>空间 O(N)，哈希表占用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">alertNames</span><span class="params">(String[] keyName, String[] keyTime)</span> &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> n=keyName.length;</span><br><span class="line">        <span class="comment">// 将数组使用哈希表存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            List&lt;String&gt; tmp=map.getOrDefault(keyName[i],<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">            tmp.add(keyTime[i]);</span><br><span class="line">            map.put(keyName[i],tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历哈希表，找出一个小时内打卡次数&gt;=3的人名</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,List&lt;String&gt;&gt; keyEntry:map.entrySet())&#123;</span><br><span class="line">            String key=keyEntry.getKey();</span><br><span class="line">            List&lt;String&gt; value=keyEntry.getValue();</span><br><span class="line">            <span class="comment">// value 需要经过排序</span></span><br><span class="line">            Collections.sort(value);</span><br><span class="line">            <span class="keyword">if</span>(isMore3(value))&#123;</span><br><span class="line">                res.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对结果进行字典序排序</span></span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMore3</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;list.size()-<span class="number">2</span>;k++)&#123;</span><br><span class="line">            String l=list.get(k);</span><br><span class="line">            String r=list.get(k+<span class="number">2</span>);</span><br><span class="line">            String []lArray=l.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            String []rArray=r.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i=Integer.parseInt(lArray[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> j=Integer.parseInt(rArray[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-i==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> ir=Integer.parseInt(lArray[<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> jr=Integer.parseInt(rArray[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(jr&lt;=ir)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在进行时间的比较时，可以将时间换算为分钟，这样可以减小比较逻辑，对于跨天问题天然有优势</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1604-警告一小时内使用相同员工卡大于等于三次的人&quot;&gt;&lt;a href=&quot;#1604-警告一小时内使用相同员工卡大</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 739</title>
    <link href="https://kkkkkong.github.io/posts/2760.html"/>
    <id>https://kkkkkong.github.io/posts/2760.html</id>
    <published>2023-02-06T11:16:44.000Z</published>
    <updated>2023-02-06T12:28:11.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h4><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力求解，两层for，超时</li></ol><blockquote><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="comment">// 两层for，向后遍历</span></span><br><span class="line">        <span class="type">int</span> n=temperatures.length;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temperatures[j]&gt;temperatures[i])&#123;</span><br><span class="line">                    res[i]=j-i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>找规律，根据题意，从后向前推会比较方便，分为几种情况，用t[i]表示第i天的气温<ul><li>t[i]&lt;t[i+1]<ul><li>res[i]为1</li></ul></li><li>t[i]&gt;&#x3D;t[i+1]<ul><li>if t[i+1]&#x3D;&#x3D;0，那么t[i]&#x3D;0</li><li>否则比较t[i]与t[i+res[i+1]]的大小</li></ul></li></ul></li></ol><p>将+1抽象为+j，那么有循环寻找下一个大值</p><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了99.06%的用户</p><p>内存消耗：51.4 MB, 在所有 Java 提交中击败了96.45%的用户</p><p>通过测试用例：48 &#x2F; 48</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span> n=temperatures.length;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-<span class="number">1</span>-i;j+=res[i+j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(temperatures[i]&lt;temperatures[i+j])&#123;</span><br><span class="line">                    res[i]=j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res[i+j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    res[i]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;739-每日温度&quot;&gt;&lt;a href=&quot;#739-每日温度&quot; class=&quot;headerlink&quot; title=&quot;7</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2331</title>
    <link href="https://kkkkkong.github.io/posts/11980.html"/>
    <id>https://kkkkkong.github.io/posts/11980.html</id>
    <published>2023-02-06T01:07:26.000Z</published>
    <updated>2023-02-06T01:15:12.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2331-计算布尔二叉树的值"><a href="#2331-计算布尔二叉树的值" class="headerlink" title="2331. 计算布尔二叉树的值"></a><a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree/">2331. 计算布尔二叉树的值</a></h4><p>给你一棵 <strong>完整二叉树</strong> 的根，这棵树有以下特征：</p><ul><li><strong>叶子节点</strong> 要么值为 <code>0</code> 要么值为 <code>1</code> ，其中 <code>0</code> 表示 <code>False</code> ，<code>1</code> 表示 <code>True</code> 。</li><li><strong>非叶子节点</strong> 要么值为 <code>2</code> 要么值为 <code>3</code> ，其中 <code>2</code> 表示逻辑或 <code>OR</code> ，<code>3</code> 表示逻辑与 <code>AND</code> 。</li></ul><p><strong>计算</strong> 一个节点的值方式如下：</p><ul><li>如果节点是个叶子节点，那么节点的 <strong>值</strong> 为它本身，即 <code>True</code> 或者 <code>False</code> 。</li><li>否则，<strong>计算</strong> 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong>运算</strong> 。</li></ul><p>返回根节点 <code>root</code> 的布尔运算值。</p><p><strong>完整二叉树</strong> 是每个节点有 <code>0</code> 个或者 <code>2</code> 个孩子的二叉树。</p><p><strong>叶子节点</strong> 是没有孩子的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/example1drawio1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3,null,null,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：上图展示了计算过程。</span><br><span class="line">AND 与运算节点的值为 False AND True = False 。</span><br><span class="line">OR 运算节点的值为 True OR False = True 。</span><br><span class="line">根节点的值为 True ，所以我们返回 true 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归，简单题我重拳出击</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了70.42%的用户</p><p>通过测试用例：75 &#x2F; 75</p><p>时间 O(N)</p><p>空间 O(N)，到不了N，取决于二叉树层数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">evaluateTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=<span class="number">1</span>)<span class="keyword">return</span> root.val==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val==<span class="number">2</span>?evaluateTree(root.left)||evaluateTree(root.right):evaluateTree(root.left)&amp;&amp;evaluateTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2331-计算布尔二叉树的值&quot;&gt;&lt;a href=&quot;#2331-计算布尔二叉树的值&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 538</title>
    <link href="https://kkkkkong.github.io/posts/2728.html"/>
    <id>https://kkkkkong.github.io/posts/2728.html</id>
    <published>2023-02-05T14:07:34.000Z</published>
    <updated>2023-02-05T14:15:06.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/tree.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这个题代码写起来简单，但是想了半天才想明白这个反向的中序遍历该怎么用，以及num的累计值的使用方式</p></blockquote><ol><li>中序遍历，递归，不难发现，题目要求结果的二叉树，如果按照中序遍历，返回的结果中，节点的val是严格递减的，因此采用中序遍历的方法，依次将val累加到节点中</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了28.56%的用户</p><p>通过测试用例：215 &#x2F; 215</p><p>时间 O(N)，二叉树节点数</p><p>空间 O(N)，二叉搜索树的深度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        root.right=convertBST(root.right);</span><br><span class="line">        root.val+= num;</span><br><span class="line">        num=root.val;</span><br><span class="line">        root.left=convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;538-把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#538-把二叉搜索树转换为累加树&quot; class=&quot;head</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 114</title>
    <link href="https://kkkkkong.github.io/posts/44776.html"/>
    <id>https://kkkkkong.github.io/posts/44776.html</id>
    <published>2023-02-05T13:19:25.000Z</published>
    <updated>2023-02-05T14:15:06.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.6 MB, 在所有 Java 提交中击败了99.52%的用户</p><p>通过测试用例：225 &#x2F; 225</p><p>时间 O(N)</p><p>空间 O(N) 树的深度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        root=getDeep(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getDeep</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;        </span><br><span class="line">        TreeNode res=root,tmp=root.right;</span><br><span class="line">        <span class="comment">// 将树的左子树展开后赋给右子树</span></span><br><span class="line">        root.right=getDeep(root.left);</span><br><span class="line">        <span class="comment">// 左子树置空</span></span><br><span class="line">        root.left=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 将右子树遍历到叶子节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将原来的右子树展开</span></span><br><span class="line">        root.right=getDeep(tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;114-二叉树展开为链表&quot;&gt;&lt;a href=&quot;#114-二叉树展开为链表&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 238</title>
    <link href="https://kkkkkong.github.io/posts/51993.html"/>
    <id>https://kkkkkong.github.io/posts/51993.html</id>
    <published>2023-02-05T07:44:53.000Z</published>
    <updated>2023-02-05T14:15:06.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请<strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用除法，但空间不额外申请空间。使用变量保存当前的前缀积与后缀积，向后遍历，前缀积使用乘法扩大，后缀积使用除法缩小。如果遇到当前元素为0，需要重新计算后缀积。</li></ol><blockquote><p>时间 O(N*N)，为0的时候特殊情况，会导致时间复杂度到平方级</p><p>空间 O(1)</p><p>超时</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="comment">// 获取整个数组的乘积</span></span><br><span class="line">        <span class="type">int</span> left_mut=<span class="number">1</span>,right_mut=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一个元素特殊处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            right_mut*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>]=left_mut*right_mut;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            left_mut*=nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 非0时，后缀积除元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                right_mut/=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 0时，需要重新计算后缀积</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right_mut=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    right_mut*=nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]=left_mut*right_mut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>辅助数组，使用两个数组分别保存前缀乘积和后缀乘积，然后某个数字的左右相乘。这里辅助数组的意义是left_mut[i]表示包含i的前缀积，如果表示不包含i的前缀积，那么代码量会更少。</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了28.31%的用户</p><p>内存消耗：49.4 MB, 在所有 Java 提交中击败了70.80%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(N)</p><p>空间 O(N) 使用了辅助数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">// 使用两个数组分别保存前缀和后缀的乘积</span></span><br><span class="line">        <span class="type">int</span> []left_mut=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> []right_mut=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 前缀积</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)left_mut[i]=nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left_mut[i]=left_mut[i-<span class="number">1</span>]*nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后缀积</span></span><br><span class="line">            <span class="type">int</span> j=n-<span class="number">1</span>-i;</span><br><span class="line">            <span class="keyword">if</span>(j==n-<span class="number">1</span>)right_mut[j]=nums[j];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right_mut[j]=right_mut[j+<span class="number">1</span>]*nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)res[i]=right_mut[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==n-<span class="number">1</span>)res[i]=left_mut[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i]=left_mut[i-<span class="number">1</span>]*right_mut[i+<span class="number">1</span>];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用返回数组代替后缀积，暂用返回数组暂时存储后缀积</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：49.2 MB, 在所有 Java 提交中击败了89.30%的用户</p><p>通过测试用例：22 &#x2F; 22</p><p>时间 O(N)</p><p>空间 O(1)，因为返回数组不算空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">// 是返回数组，也是后缀积数组</span></span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n-<span class="number">1</span>)res[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 后缀积不计算当前元素</span></span><br><span class="line">                res[i]=res[i+<span class="number">1</span>]*nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left_mut=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算res</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[i]=left_mut*res[i];</span><br><span class="line">            left_mut*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;238-除自身以外数组的乘积&quot;&gt;&lt;a href=&quot;#238-除自身以外数组的乘积&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 48</title>
    <link href="https://kkkkkong.github.io/posts/65376.html"/>
    <id>https://kkkkkong.github.io/posts/65376.html</id>
    <published>2023-02-05T03:15:13.000Z</published>
    <updated>2023-02-05T03:27:14.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用辅助矩阵：空间O(N)</li><li>原地旋转：找交换位置的规律，矩阵位置是对称的，因此每次交换的位置是有规律的，以最外圈的n个元素为例，前n-1个元素都会交换到对应的位置。将n-1个元素交换完，最外层也就结束了，接下来进入下一层交换元素。</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40 MB, 在所有 Java 提交中击败了93.91%的用户</p><p>通过测试用例：21 &#x2F; 21</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// n表示不重复的圈数</span></span><br><span class="line">        <span class="type">int</span> n=len/<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// i 表示层数-1</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            <span class="comment">// 矩阵中每次交换的元素的横纵坐标</span></span><br><span class="line">            <span class="type">int</span> rui=<span class="number">0</span>+i,ruj=len-<span class="number">1</span>-i,rli=len-<span class="number">1</span>-i,rlj=len-<span class="number">1</span>-i,lli=len-<span class="number">1</span>-i,llj=<span class="number">0</span>+i,lui=<span class="number">0</span>+i,luj=<span class="number">0</span>+i;</span><br><span class="line">            <span class="comment">// j 为单边的第几个元素</span></span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="comment">// 小于当前圈的边长 len/(lu+1)</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;len-<span class="number">1</span>-i)&#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> tmp=matrix[lui][luj];</span><br><span class="line">                matrix[lui][luj]=matrix[lli][llj];</span><br><span class="line">                matrix[lli][llj]=matrix[rli][rlj];</span><br><span class="line">                matrix[rli][rlj]=matrix[rui][ruj];</span><br><span class="line">                matrix[rui][ruj]=tmp;</span><br><span class="line">                <span class="comment">// 向后移动，移动j</span></span><br><span class="line">                luj+=<span class="number">1</span>;</span><br><span class="line">                rui+=<span class="number">1</span>;</span><br><span class="line">                rlj-=<span class="number">1</span>;</span><br><span class="line">                lli-=<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1798</title>
    <link href="https://kkkkkong.github.io/posts/3403.html"/>
    <id>https://kkkkkong.github.io/posts/3403.html</id>
    <published>2023-02-04T15:02:30.000Z</published>
    <updated>2023-02-04T15:08:49.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1798-你能构造出连续值的最大数目"><a href="#1798-你能构造出连续值的最大数目" class="headerlink" title="1798. 你能构造出连续值的最大数目"></a><a href="https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/">1798. 你能构造出连续值的最大数目</a></h4><p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的 <code>n</code> 个硬币。第 <code>i</code> 个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 <code>x</code> ，那么称，你可以 <strong>构造</strong> 出 <code>x</code> 。</p><p>请返回从 <code>0</code> 开始（<strong>包括</strong> <code>0</code> ），你最多能 <strong>构造</strong> 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- 0：什么都不取 []</span><br><span class="line">- 1：取 [1]</span><br><span class="line">从 0 开始，你可以构造出 2 个连续整数。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>贪心，排序后，假设当前的表述范围为[0,n]，数组尾部每多一个数字v，其表示的范围为[0,n]&amp;[0+v,n+v]，那么需要考虑n与v的大小关系，如果v&lt;&#x3D;n+1，则两个范围可以连续上，否则返回结果（看了评论的想法）</li></ol><blockquote><p>执行用时：17 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：48.7 MB, 在所有 Java 提交中击败了92.31%的用户</p><p>通过测试用例：72 &#x2F; 72</p><p>时间 O(n*logn)，主要在排序的时间开销</p><p>空间 O(logn)，排序需要的栈空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumConsecutive</span><span class="params">(<span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:coins)&#123;</span><br><span class="line">            <span class="comment">// +1的目的是刚好i作为reshb的值</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;=res+<span class="number">1</span>)&#123;</span><br><span class="line">                res=res+i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1798-你能构造出连续值的最大数目&quot;&gt;&lt;a href=&quot;#1798-你能构造出连续值的最大数目&quot; class=&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2325</title>
    <link href="https://kkkkkong.github.io/posts/32204.html"/>
    <id>https://kkkkkong.github.io/posts/32204.html</id>
    <published>2023-02-01T01:50:55.000Z</published>
    <updated>2023-02-01T11:37:22.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2325-解密消息"><a href="#2325-解密消息" class="headerlink" title="2325. 解密消息"></a><a href="https://leetcode.cn/problems/decode-the-message/">2325. 解密消息</a></h4><p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p><ol><li>使用 <code>key</code> 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 <strong>顺序</strong> 。</li><li>将替换表与普通英文字母表对齐，形成对照表。</li><li>按照对照表 <strong>替换</strong> <code>message</code> 中的每个字母。</li><li>空格 <code>&#39; &#39;</code> 保持不变。</li></ol><ul><li>例如，<code>key = &quot;***hap***p***y*** ***bo***y&quot;</code>（实际的加密密钥会包含字母表中每个字母 <strong>至少一次</strong>），据此，可以得到部分对照表（<code>&#39;h&#39; -&gt; &#39;a&#39;</code>、<code>&#39;a&#39; -&gt; &#39;b&#39;</code>、<code>&#39;p&#39; -&gt; &#39;c&#39;</code>、<code>&#39;y&#39; -&gt; &#39;d&#39;</code>、<code>&#39;b&#39; -&gt; &#39;e&#39;</code>、<code>&#39;o&#39; -&gt; &#39;f&#39;</code>）。</li></ul><p>返回解密后的消息。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/ex1new4.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：key = &quot;the quick brown fox jumps over the lazy dog&quot;, message = &quot;vkbs bs t suepuv&quot;</span><br><span class="line">输出：&quot;this is a secret&quot;</span><br><span class="line">解释：对照表如上图所示。</span><br><span class="line">提取 &quot;the quick brown fox jumps over the lazy dog&quot; 中每个字母的首次出现可以得到替换表。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表</li></ol><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了50.73%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了62.04%的用户</p><p>通过测试用例：69 &#x2F; 69</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeMessage</span><span class="params">(String key, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用HashMap存储密码的对应值</span></span><br><span class="line">        Map&lt;Character,Character&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;key.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!map.containsKey(c))&#123;</span><br><span class="line">                map.put(c,(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+num));</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历message翻译</span></span><br><span class="line">        <span class="type">char</span>[] res=<span class="keyword">new</span> <span class="title class_">char</span>[message.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;message.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=message.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res[i]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i]=map.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用数组代替哈希表，<em>对于以字母作为索引的操作，能用定长数组就不要用哈希，因为映射本身需要资源，而且无论分配空间还是寻址，堆区都不如栈区</em></li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了77.37%的用户</p><p>内存消耗：40.2 MB, 在所有 Java 提交中击败了95.62%的用户</p><p>通过测试用例：69 &#x2F; 69</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeMessage</span><span class="params">(String key, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数组存储字典值</span></span><br><span class="line">        <span class="type">char</span>[] map=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历key，存储密码值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;key.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!Character.isLowerCase(map[c-<span class="string">&#x27;a&#x27;</span>]))&#123;</span><br><span class="line">                map[c-<span class="string">&#x27;a&#x27;</span>]=(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+num);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 翻译</span></span><br><span class="line">        <span class="type">char</span>[] res=<span class="keyword">new</span> <span class="title class_">char</span>[message.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;message.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=message.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res[i]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i]=map[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2325-解密消息&quot;&gt;&lt;a href=&quot;#2325-解密消息&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode  1669</title>
    <link href="https://kkkkkong.github.io/posts/52549.html"/>
    <id>https://kkkkkong.github.io/posts/52549.html</id>
    <published>2023-01-30T14:02:15.000Z</published>
    <updated>2023-01-30T14:05:32.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1669-合并两个链表"><a href="#1669-合并两个链表" class="headerlink" title="1669. 合并两个链表"></a><a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></h4><p>给你两个链表 <code>list1</code> 和 <code>list2</code> ，它们包含的元素分别为 <code>n</code> 个和 <code>m</code> 个。</p><p>请你将 <code>list1</code> 中下标从 <code>a</code> 到 <code>b</code> 的全部节点都删除，并将<code>list2</code> 接在被删除节点的位置。</p><p>下图中蓝色边和节点展示了操作后的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/fig1.png" alt="img"></p><p>请你返回结果链表的头指针。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/merge_linked_list_ex1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]</span><br><span class="line">输出：[0,1,2,1000000,1000001,1000002,5]</span><br><span class="line">解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，按流程办事</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：45.1 MB, 在所有 Java 提交中击败了15.14%的用户</p><p>通过测试用例：61 &#x2F; 61</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeInBetween</span><span class="params">(ListNode list1, <span class="type">int</span> a, <span class="type">int</span> b, ListNode list2)</span> &#123;</span><br><span class="line">        ListNode res=list1;</span><br><span class="line">        <span class="comment">// 找到a节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            list1=list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将a以后的暂存在tmp</span></span><br><span class="line">        ListNode tmp=list1.next;</span><br><span class="line">        <span class="comment">// 将list2的拼接上</span></span><br><span class="line">        list1.next=list2;</span><br><span class="line">        <span class="comment">// 访问到list2的末尾</span></span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span>&amp;&amp;list1.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list1=list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除a到b的中间元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b-a;i++)&#123;</span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list1.next=tmp.next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1669-合并两个链表&quot;&gt;&lt;a href=&quot;#1669-合并两个链表&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2315</title>
    <link href="https://kkkkkong.github.io/posts/36300.html"/>
    <id>https://kkkkkong.github.io/posts/36300.html</id>
    <published>2023-01-29T06:34:08.000Z</published>
    <updated>2023-01-29T06:49:26.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2315-统计星号"><a href="#2315-统计星号" class="headerlink" title="2315. 统计星号"></a><a href="https://leetcode.cn/problems/count-asterisks/">2315. 统计星号</a></h4><p>给你一个字符串 <code>s</code> ，每 <strong>两个</strong> 连续竖线 <code>&#39;|&#39;</code> 为 <strong>一对</strong> 。换言之，第一个和第二个 <code>&#39;|&#39;</code> 为一对，第三个和第四个 <code>&#39;|&#39;</code> 为一对，以此类推。</p><p>请你返回 <strong>不在</strong> 竖线对之间，<code>s</code> 中 <code>&#39;*&#39;</code> 的数目。</p><p><strong>注意</strong>，每个竖线 <code>&#39;|&#39;</code> 都会 <strong>恰好</strong> 属于一个对。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;l|*e*et|c**o|*de|&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：不在竖线对之间的字符加粗加斜体后，得到字符串：&quot;l|*e*et|c**o|*de|&quot; 。</span><br><span class="line">第一和第二条竖线 &#x27;|&#x27; 之间的字符不计入答案。</span><br><span class="line">同时，第三条和第四条竖线 &#x27;|&#x27; 之间的字符也不计入答案。</span><br><span class="line">不在竖线对之间总共有 2 个星号，所以我们返回 2 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>遍历模拟：使用一个bool位作为是否为竖线中间的标记，如果不在竖线中间并且为*时，进行统计，如果遇到|，则将标记位取反</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了53.58%的用户</p><p>通过测试用例：69 &#x2F; 69</p><p>时间 O(n)</p><p>空间O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countAsterisks</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="type">boolean</span> isEven=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>&amp;&amp;isEven)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                isEven=!isEven;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2315-统计星号&quot;&gt;&lt;a href=&quot;#2315-统计星号&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1664</title>
    <link href="https://kkkkkong.github.io/posts/14367.html"/>
    <id>https://kkkkkong.github.io/posts/14367.html</id>
    <published>2023-01-28T03:42:28.000Z</published>
    <updated>2023-01-28T03:50:13.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1664-生成平衡数组的方案数"><a href="#1664-生成平衡数组的方案数" class="headerlink" title="1664. 生成平衡数组的方案数"></a><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/">1664. 生成平衡数组的方案数</a></h4><p>给你一个整数数组 <code>nums</code> 。你需要选择 <strong>恰好</strong> 一个下标（下标从 <strong>0</strong> 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p><p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p><ul><li>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。</li><li>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。</li><li>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。</li></ul><p>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 <strong>平衡数组</strong> 。</p><p>请你返回删除操作后，剩下的数组 <code>nums</code> 是 <strong>平衡数组</strong> 的 <strong>方案数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1,6,4]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。</span><br><span class="line">删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。</span><br><span class="line">删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。</span><br><span class="line">删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。</span><br><span class="line">只有一种让剩余数组成为平衡数组的方案。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>奇偶前缀和：四个变量模拟计算结果，从后往前依次移除元素，因为题目设定每次只移除一个元素，因此在从后向前移动的过程中，right元素的奇偶性是变换的</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了85.71%的用户</p><p>内存消耗：51.9 MB, 在所有 Java 提交中击败了21.80%的用户</p><p>通过测试用例：105 &#x2F; 105</p><p>时间 O(n)</p><p>空间 O(1)</p><p>竟然和官方题解是一样的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">waysToMakeFair</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 分别新建变量表示奇数和与偶数和，并将其分为左右两部分表示</span></span><br><span class="line">        <span class="type">int</span> odd_sum_left=<span class="number">0</span>,odd_sum_right=<span class="number">0</span>,even_sum_left=<span class="number">0</span>,even_sum_right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>)!=<span class="number">0</span>) odd_sum_left+=nums[i];</span><br><span class="line">            <span class="keyword">else</span> even_sum_left+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                odd_sum_left-=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                even_sum_left-=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将两个right交换相加到left中</span></span><br><span class="line">            <span class="keyword">if</span>(odd_sum_left+even_sum_right==even_sum_left+odd_sum_right)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                odd_sum_right+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                even_sum_right+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1664-生成平衡数组的方案数&quot;&gt;&lt;a href=&quot;#1664-生成平衡数组的方案数&quot; class=&quot;header</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2309</title>
    <link href="https://kkkkkong.github.io/posts/6349.html"/>
    <id>https://kkkkkong.github.io/posts/6349.html</id>
    <published>2023-01-27T03:15:47.000Z</published>
    <updated>2023-01-27T03:18:48.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2309-兼具大小写的最好英文字母"><a href="#2309-兼具大小写的最好英文字母" class="headerlink" title="2309. 兼具大小写的最好英文字母"></a><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/">2309. 兼具大小写的最好英文字母</a></h4><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p><p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p><p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> <strong>更好</strong> 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 <strong>后</strong> 出现。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;lEeTcOdE&quot;</span><br><span class="line">输出：&quot;E&quot;</span><br><span class="line">解释：</span><br><span class="line">字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>通过数组存储状态，遍历访问数组，获取状态，并存取最大值</li></ol><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了36.94%的用户</p><p>内存消耗：40.1 MB, 在所有 Java 提交中击败了75.37%的用户</p><p>通过测试用例：113 &#x2F; 113</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greatestLetter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> max=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 数组值为1，表示有小写字母；数组值为2，表示有大写字母</span></span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isUpperCase(c))&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[c-<span class="string">&#x27;A&#x27;</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    max=Math.max(max,c-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp[c-<span class="string">&#x27;A&#x27;</span>]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(Character.isLowerCase(c))&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                    max=Math.max(max,c-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp[c-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:String.valueOf((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+max));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2309-兼具大小写的最好英文字母&quot;&gt;&lt;a href=&quot;#2309-兼具大小写的最好英文字母&quot; class=&quot;he</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1663</title>
    <link href="https://kkkkkong.github.io/posts/64094.html"/>
    <id>https://kkkkkong.github.io/posts/64094.html</id>
    <published>2023-01-26T13:15:59.000Z</published>
    <updated>2023-01-27T03:18:48.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1663-具有给定数值的最小字符串"><a href="#1663-具有给定数值的最小字符串" class="headerlink" title="1663. 具有给定数值的最小字符串"></a><a href="https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/">1663. 具有给定数值的最小字符串</a></h4><p><strong>小写字符</strong> 的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。</p><p>字符串由若干小写字符组成，<strong>字符串的数值</strong> 为各字符的数值之和。例如，字符串 <code>&quot;abe&quot;</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。</p><p>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。</p><p>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p><ul><li><code>x</code> 是 <code>y</code> 的一个前缀；</li><li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, k = 27</span><br><span class="line">输出：&quot;aay&quot;</span><br><span class="line">解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代模拟，根据题目描述，要找的字符串是<strong>严格非递减</strong>的，我们默认字符串都是a组成；从后向前模拟，根据剩余值大小进行修改</li></ol><blockquote><p>执行用时：9 ms, 在所有 Java 提交中击败了86.29%的用户</p><p>内存消耗：41.5 MB, 在所有 Java 提交中击败了74.19%的用户</p><p>通过测试用例：94 &#x2F; 94</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSmallestString</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span> []res_char=<span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="comment">// 全部赋初值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res_char[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k-=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">25</span>)&#123;</span><br><span class="line">                res_char[i]=<span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">                k-=<span class="number">25</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;=<span class="number">25</span>)&#123;</span><br><span class="line">                res_char[i]+=k;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res_char);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1663-具有给定数值的最小字符串&quot;&gt;&lt;a href=&quot;#1663-具有给定数值的最小字符串&quot; class=&quot;he</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1828</title>
    <link href="https://kkkkkong.github.io/posts/15996.html"/>
    <id>https://kkkkkong.github.io/posts/15996.html</id>
    <published>2023-01-24T02:12:47.000Z</published>
    <updated>2023-01-24T02:15:54.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1828-统计一个圆中点的数目"><a href="#1828-统计一个圆中点的数目" class="headerlink" title="1828. 统计一个圆中点的数目"></a><a href="https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/">1828. 统计一个圆中点的数目</a></h4><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p><p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在 <code>(xj, yj)</code> 且半径为 <code>rj</code> 的圆。</p><p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/chrome_2021-03-25_22-34-16.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]</span><br><span class="line">输出：[3,2,2]</span><br><span class="line">解释：所有的点和圆如上图所示。</span><br><span class="line">queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>两层遍历，枚举</li></ol><blockquote><p>执行用时：35 ms, 在所有 Java 提交中击败了51.59%的用户</p><p>内存消耗：42.2 MB, 在所有 Java 提交中击败了37.70%的用户</p><p>通过测试用例：66 &#x2F; 66</p><p>时间 O(n*m)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countPoints(<span class="type">int</span>[][] points, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queries.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> []query=queries[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> []point:points)&#123;</span><br><span class="line">                <span class="type">int</span> query_x=query[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> query_y=query[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> r=query[<span class="number">2</span>];</span><br><span class="line">                <span class="type">int</span> point_x=point[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> point_y=point[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 判断是否在圆内，点到圆心距离是否小于等于半径 x*x+y*y&lt;=r*r</span></span><br><span class="line">                <span class="keyword">if</span>((Math.pow((query_x-point_x),<span class="number">2</span>)+Math.pow((query_y-point_y),<span class="number">2</span>))&lt;=(r*r))&#123;</span><br><span class="line">                    res[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1828-统计一个圆中点的数目&quot;&gt;&lt;a href=&quot;#1828-统计一个圆中点的数目&quot; class=&quot;header</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2303</title>
    <link href="https://kkkkkong.github.io/posts/8013.html"/>
    <id>https://kkkkkong.github.io/posts/8013.html</id>
    <published>2023-01-23T05:39:22.000Z</published>
    <updated>2023-01-23T05:45:51.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2303-计算应缴税款总额"><a href="#2303-计算应缴税款总额" class="headerlink" title="2303. 计算应缴税款总额"></a><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">2303. 计算应缴税款总额</a></h4><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10-5</code> 的结果将被视作正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：brackets = [[3,50],[7,10],[12,25]], income = 10</span><br><span class="line">输出：2.65000</span><br><span class="line">解释：</span><br><span class="line">前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。</span><br><span class="line">接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。</span><br><span class="line">最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。</span><br><span class="line">需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，从前到后遍历数组，如果income大于upper，计算upper以前的税收；否则，income小于等于upper，计算income以前的税收，遍历终止</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了22.05%的用户</p><p>通过测试用例：227 &#x2F; 227</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateTax</span><span class="params">(<span class="type">int</span>[][] brackets, <span class="type">int</span> income)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []get:brackets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(income&gt;get[<span class="number">0</span>])&#123;</span><br><span class="line">                res+=((get[<span class="number">0</span>]-pre)*get[<span class="number">1</span>])/<span class="number">100.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res+=((income-pre)*get[<span class="number">1</span>])/<span class="number">100.0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=get[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2303-计算应缴税款总额&quot;&gt;&lt;a href=&quot;#2303-计算应缴税款总额&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1817</title>
    <link href="https://kkkkkong.github.io/posts/51772.html"/>
    <id>https://kkkkkong.github.io/posts/51772.html</id>
    <published>2023-01-20T11:56:30.000Z</published>
    <updated>2023-01-20T12:06:15.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1817-查找用户活跃分钟数"><a href="#1817-查找用户活跃分钟数" class="headerlink" title="1817. 查找用户活跃分钟数"></a><a href="https://leetcode.cn/problems/finding-the-users-active-minutes/">1817. 查找用户活跃分钟数</a></h4><p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 <code>IDi</code> 的用户在 <code>timei</code> 分钟时执行了某个操作。</p><p><strong>多个用户</strong> 可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p><p>指定用户的 <strong>用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p><p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 &lt;= j &lt;= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p><p>返回上面描述的答案数组 <code>answer</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5</span><br><span class="line">输出：[0,2,0,0,0]</span><br><span class="line">解释：</span><br><span class="line">ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）</span><br><span class="line">ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2</span><br><span class="line">2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表存储：使用<code>HashMap &lt;Integer,HashSet&lt;Integer&gt;&gt;</code>储存信息</li></ol><blockquote><p>执行用时：16 ms, 在所有 Java 提交中击败了86.21%的用户</p><p>内存消耗：52.4 MB, 在所有 Java 提交中击败了9.20%的用户</p><p>通过测试用例：38 &#x2F; 38</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findingUsersActiveMinutes(<span class="type">int</span>[][] logs, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span> [k];</span><br><span class="line">        HashMap &lt;Integer,HashSet&lt;Integer&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;logs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> key=logs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> value=logs[i][<span class="number">1</span>];</span><br><span class="line">            HashSet set=map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br><span class="line">            set.add(value);</span><br><span class="line">            map.put(key,set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(HashSet set:map.values())&#123;</span><br><span class="line">            res[set.size()-<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1817-查找用户活跃分钟数&quot;&gt;&lt;a href=&quot;#1817-查找用户活跃分钟数&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2299</title>
    <link href="https://kkkkkong.github.io/posts/34970.html"/>
    <id>https://kkkkkong.github.io/posts/34970.html</id>
    <published>2023-01-19T01:57:11.000Z</published>
    <updated>2023-01-20T12:06:15.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2299-强密码检验器-II"><a href="#2299-强密码检验器-II" class="headerlink" title="2299. 强密码检验器 II"></a><a href="https://leetcode.cn/problems/strong-password-checker-ii/">2299. 强密码检验器 II</a></h4><p>如果一个密码满足以下所有条件，我们称它是一个 <strong>强</strong> 密码：</p><ul><li>它有至少 <code>8</code> 个字符。</li><li>至少包含 <strong>一个小写英文</strong> 字母。</li><li>至少包含 <strong>一个大写英文</strong> 字母。</li><li>至少包含 <strong>一个数字</strong> 。</li><li>至少包含 <strong>一个特殊字符</strong> 。特殊字符为：<code>&quot;!@#$%^&amp;*()-+&quot;</code> 中的一个。</li><li>它 <strong>不</strong> 包含 <code>2</code> 个连续相同的字符（比方说 <code>&quot;aab&quot;</code> 不符合该条件，但是 <code>&quot;aba&quot;</code> 符合该条件）。</li></ul><p>给你一个字符串 <code>password</code> ，如果它是一个 <strong>强</strong> 密码，返回 <code>true</code>，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：password = &quot;IloveLe3tcode!&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：密码满足所有的要求，所以我们返回 true 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟，这里的判断方法可以用Character里的现有方法替代</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了69.57%的用户</p><p>内存消耗：39.5 MB, 在所有 Java 提交中击败了53.26%的用户</p><p>通过测试用例：148 &#x2F; 148</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">strongPasswordCheckerII</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=password.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">8</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> have_big=<span class="literal">false</span>,have_small=<span class="literal">false</span>,have_num=<span class="literal">false</span>,have_sp=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span> pre=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        String sp=<span class="string">&quot;!@#$%^&amp;*()-+&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=password.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=c;</span><br><span class="line">            <span class="keyword">if</span>(sp.contains(String.valueOf(c)))&#123;</span><br><span class="line">                have_sp=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 大写字母</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c-<span class="string">&#x27;A&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;A&#x27;</span>&lt;<span class="number">26</span>)&#123;</span><br><span class="line">                have_big=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c-<span class="string">&#x27;a&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;a&#x27;</span>&lt;<span class="number">26</span>)&#123;</span><br><span class="line">                have_small=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;0&#x27;</span>&lt;<span class="number">10</span>)&#123;</span><br><span class="line">                have_num=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> have_big&amp;&amp;have_num&amp;&amp;have_small&amp;&amp;have_sp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2299-强密码检验器-II&quot;&gt;&lt;a href=&quot;#2299-强密码检验器-II&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 461</title>
    <link href="https://kkkkkong.github.io/posts/39994.html"/>
    <id>https://kkkkkong.github.io/posts/39994.html</id>
    <published>2023-01-18T01:54:22.000Z</published>
    <updated>2023-01-18T01:57:02.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode.cn/problems/hamming-distance/">461. 汉明距离</a></h4><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 1, y = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>位运算</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.6 MB, 在所有 Java 提交中击败了31.43%的用户</p><p>通过测试用例：149 &#x2F; 149</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>||y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果末尾不同</span></span><br><span class="line">            <span class="keyword">if</span>((x&amp;<span class="number">1</span>)!=(y&amp;<span class="number">1</span>))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;461-汉明距离&quot;&gt;&lt;a href=&quot;#461-汉明距离&quot; class=&quot;headerlink&quot; title=&quot;4</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 338</title>
    <link href="https://kkkkkong.github.io/posts/2888.html"/>
    <id>https://kkkkkong.github.io/posts/2888.html</id>
    <published>2023-01-18T01:16:15.000Z</published>
    <updated>2023-01-18T01:57:02.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></h4><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,1]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>迭代，遍历每个元素，依次获取</li></ol><blockquote><p>执行用时：12 ms, 在所有 Java 提交中击败了6.33%的用户</p><p>内存消耗：45.1 MB, 在所有 Java 提交中击败了96.57%的用户</p><p>通过测试用例：15 &#x2F; 15</p><p>将除法和取余运算修改为位运算</p><p>执行用时：5 ms, 在所有 Java 提交中击败了18.58%的用户</p><p>内存消耗：45.6 MB, 在所有 Java 提交中击败了37.43%的用户</p><p>通过测试用例：15 &#x2F; 15</p><p>时间 O(n*logn)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=i;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    res[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">                num/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=i;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((num&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                    res[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">                num=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>找规律：可以发现，把数字分为两种情况，奇数和偶数<ol><li>奇数：n中1的个数为n-1的个数+1</li><li>偶数：末尾一定为0，对应的1的个数为去掉末尾0的个数</li></ol></li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了99.98%的用户</p><p>内存消耗：45.5 MB, 在所有 Java 提交中击败了52.85%的用户</p><p>通过测试用例：15 &#x2F; 15</p><p>时间 O(n)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果是偶数</span></span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                res[i]=res[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i]=res[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;338-比特位计数&quot;&gt;&lt;a href=&quot;#338-比特位计数&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
