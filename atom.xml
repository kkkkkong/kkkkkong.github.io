<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-02-19T08:01:33.145Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 930</title>
    <link href="https://kkkkkong.github.io/posts/53097.html"/>
    <id>https://kkkkkong.github.io/posts/53097.html</id>
    <published>2023-02-19T07:17:09.000Z</published>
    <updated>2023-02-19T08:01:33.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930. 和相同的二元子数组"></a><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></h4><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：hashmap存放sum出现的次数</li></ol><blockquote><p>执行用时：20 ms, 在所有 Java 提交中击败了59.25%的用户</p><p>内存消耗：46.1 MB, 在所有 Java 提交中击败了35.95%的用户</p><p>通过测试用例：60 &#x2F; 60</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="comment">// hashmap存放sum出现的次数</span></span><br><span class="line">        Map &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(sum-goal,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=-<span class="number">1</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动窗口，重点打开思路，因为数组中只有0和1，需要使用两个左指针来表示right固定的情况下，有多少种情况满足</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了78.77%的用户</p><p>内存消耗：45.2 MB, 在所有 Java 提交中击败了60.27%的用户</p><p>通过测试用例：60 &#x2F; 60</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> left1=<span class="number">0</span>,left2=<span class="number">0</span>,right=<span class="number">0</span>,ans=<span class="number">0</span>,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            sum1+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left1&lt;=right&amp;&amp;sum1&gt;goal)&#123;</span><br><span class="line">                sum1-=nums[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left2&lt;=right&amp;&amp;sum2&gt;=goal)&#123;</span><br><span class="line">                sum2-=nums[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=left2-left1;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;930-和相同的二元子数组&quot;&gt;&lt;a href=&quot;#930-和相同的二元子数组&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 724</title>
    <link href="https://kkkkkong.github.io/posts/24328.html"/>
    <id>https://kkkkkong.github.io/posts/24328.html</id>
    <published>2023-02-19T02:26:13.000Z</published>
    <updated>2023-02-19T02:34:22.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/">724. 寻找数组的中心下标</a></h4><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了73.45%的用户</p><p>内存消耗：42.4 MB, 在所有 Java 提交中击败了32.02%的用户</p><p>通过测试用例：746 &#x2F; 746</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []sum=<span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum[i]=sum[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i]==sum[n]-sum[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前缀和优化，不需要使用数组存储，只需要用一个变量记录当前的数组和是多少即可</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了36.89%的用户</p><p>内存消耗：42 MB, 在所有 Java 提交中击败了75.86%的用户</p><p>通过测试用例：746 &#x2F; 746</p><p>时间 O(N)</p><p>空间 O(1)</p><p>一样的代码，运行两次，也不知道是为何两次差距这么大</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了10.93%的用户</p><p>通过测试用例：746 &#x2F; 746</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==sum-pre-nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;724-寻找数组的中心下标&quot;&gt;&lt;a href=&quot;#724-寻找数组的中心下标&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 560</title>
    <link href="https://kkkkkong.github.io/posts/40106.html"/>
    <id>https://kkkkkong.github.io/posts/40106.html</id>
    <published>2023-02-18T07:49:42.000Z</published>
    <updated>2023-02-18T08:04:17.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：查找tmp[i]-k出现的次数</li></ol><blockquote><p>执行用时：17 ms, 在所有 Java 提交中击败了98.66%的用户</p><p>内存消耗：45.6 MB, 在所有 Java 提交中击败了39.34%的用户</p><p>通过测试用例：93 &#x2F; 93</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        tmp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp[i]=tmp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找tmp[i]-k出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> q=tmp[i]-k;</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="number">0</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(q,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(tmp[i],map.getOrDefault(tmp[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法一的优化，笑死，优化完，时间翻倍了</li></ol><blockquote><p>执行用时：29 ms, 在所有 Java 提交中击败了40.76%的用户</p><p>内存消耗：44.9 MB, 在所有 Java 提交中击败了63.23%的用户</p><p>通过测试用例：93 &#x2F; 93</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="type">int</span> q=sum-k;</span><br><span class="line">            <span class="type">int</span> value=map.getOrDefault(q,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;560-和为-K-的子数组&quot;&gt;&lt;a href=&quot;#560-和为-K-的子数组&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 528</title>
    <link href="https://kkkkkong.github.io/posts/39593.html"/>
    <id>https://kkkkkong.github.io/posts/39593.html</id>
    <published>2023-02-18T03:41:24.000Z</published>
    <updated>2023-02-18T08:04:17.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a><a href="https://leetcode.cn/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4><p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p><p>请你实现一个函数 <code>pickIndex</code> ，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code> 的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p><ul><li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，<code>75%</code>）。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1]],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,0]</span><br><span class="line">解释：</span><br><span class="line">Solution solution = new Solution([1]);</span><br><span class="line">solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+二分查找，重点是将权重数组以前缀和的形式表示出来，假设总权重和为sum，那么在[1,sum]上随机取数字，落在权重大的区间上的概率更大。二分查找只是更快的查到<strong>下标最大的小于x的区间</strong>在哪</li></ol><p>int x&#x3D;(int)(Math.random()*sum)+1;的取值很重要，random返回的是[0,1)的数字，不加1永远取不到sum的右边界</p><blockquote><p>执行用时：25 ms, 在所有 Java 提交中击败了45.06%的用户</p><p>内存消耗：45.8 MB, 在所有 Java 提交中击败了80.66%的用户</p><p>通过测试用例：57 &#x2F; 57</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> []pre;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        pre=<span class="keyword">new</span> <span class="title class_">int</span>[w.length];</span><br><span class="line">        pre[<span class="number">0</span>]=w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">            pre[i]=pre[i-<span class="number">1</span>]+w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum=Arrays.stream(w).sum();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pickIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> x=(<span class="type">int</span>)(Math.random()*sum)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(pre,x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> []pre,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=pre.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[mid]&lt;x)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;528-按权重随机选择&quot;&gt;&lt;a href=&quot;#528-按权重随机选择&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 525</title>
    <link href="https://kkkkkong.github.io/posts/24424.html"/>
    <id>https://kkkkkong.github.io/posts/24424.html</id>
    <published>2023-02-17T03:20:26.000Z</published>
    <updated>2023-02-17T07:15:50.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a href="https://leetcode.cn/problems/contiguous-array/">525. 连续数组</a></h4><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>这里的变0为-1真的是神来之笔</p></blockquote><ol><li>前缀和+变0为-1，将0变为-1后，主要统计前缀和，将第一次出现的元素保存到map中。特殊的，和为0的表示天然符合题目要求</li></ol><blockquote><p>执行用时：13 ms, 在所有 Java 提交中击败了97.19%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了95.36%的用户</p><p>通过测试用例：564 &#x2F; 564</p><p>时间 O(n)</p><p>空间 O(n)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)nums[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存放第一个和为k的元素位置</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                ans=Math.max(ans,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tmp=map.getOrDefault(sum,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp==-<span class="number">1</span>)&#123;</span><br><span class="line">                map.put(sum,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans=Math.max(ans,i-tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;525-连续数组&quot;&gt;&lt;a href=&quot;#525-连续数组&quot; class=&quot;headerlink&quot; title=&quot;5</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 209</title>
    <link href="https://kkkkkong.github.io/posts/64472.html"/>
    <id>https://kkkkkong.github.io/posts/64472.html</id>
    <published>2023-02-17T02:14:09.000Z</published>
    <updated>2023-02-17T07:15:50.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>前缀和+二分查找 时空 O(NLogN) O(1)</li><li>前缀和作差+滑动窗口，这里的额外数组使用n+1长度更舒服，tmp[i]表示前i个元素的和</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了15.24%的用户</p><p>内存消耗：49.6 MB, 在所有 Java 提交中击败了7.48%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">// 数组计数，tmp[i]表示前i个元素的和</span></span><br><span class="line">        <span class="type">int</span> []tmp=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        tmp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp[i]=tmp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp[n-<span class="number">1</span>]&lt;target)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp[<span class="number">0</span>]&gt;=target)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,ans=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[j]&gt;=target)&#123;</span><br><span class="line">                ans=Math.min(ans,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp[j]-tmp[i]&lt;target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(tmp[j]-tmp[i]&gt;=target)&#123;</span><br><span class="line">                    ans=Math.min(ans,j-i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前缀和+滑动窗口，改进版</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：49.2 MB, 在所有 Java 提交中击败了14.99%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> ans=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;n)&#123;</span><br><span class="line">            sum+=nums[end++];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                ans=Math.min(ans,end-start);</span><br><span class="line">                sum-=nums[start++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans==Integer.MAX_VALUE?<span class="number">0</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;209-长度最小的子数组&quot;&gt;&lt;a href=&quot;#209-长度最小的子数组&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 2341</title>
    <link href="https://kkkkkong.github.io/posts/7886.html"/>
    <id>https://kkkkkong.github.io/posts/7886.html</id>
    <published>2023-02-16T01:09:05.000Z</published>
    <updated>2023-02-16T02:35:57.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2341-数组能形成多少数对"><a href="#2341-数组能形成多少数对" class="headerlink" title="2341. 数组能形成多少数对"></a><a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/">2341. 数组能形成多少数对</a></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p><ul><li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li><li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li></ul><p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p><p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中 <code>answer[0]</code> 是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,1,3,2,2]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：</span><br><span class="line">nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。</span><br><span class="line">nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。</span><br><span class="line">nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。</span><br><span class="line">无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+枚举：排序后遍历数组，如果一个数和他后面的数相等，那么说明这两个数需要移除，否则继续向后移动</li></ol><blockquote><p>时间 O(NLogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfPairs(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> []ans=<span class="keyword">new</span> <span class="title class_">int</span> []&#123;<span class="number">0</span>,n&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                ans[<span class="number">0</span>]++;</span><br><span class="line">                ans[<span class="number">1</span>]-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>哈希+枚举</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了54.00%的用户</p><p>内存消耗：40.3 MB, 在所有 Java 提交中击败了40.80%的用户</p><p>通过测试用例：128 &#x2F; 128</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfPairs(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Boolean&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,!map.getOrDefault(i,<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">if</span>(map.get(i))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ans,n-ans*<span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2341-数组能形成多少数对&quot;&gt;&lt;a href=&quot;#2341-数组能形成多少数对&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 647</title>
    <link href="https://kkkkkong.github.io/posts/15898.html"/>
    <id>https://kkkkkong.github.io/posts/15898.html</id>
    <published>2023-02-15T01:38:38.000Z</published>
    <updated>2023-02-16T02:35:57.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>找规律+中心扩展法：参考题解，非常巧妙的应用了回文串的规律，将回文串的长度分为奇偶两种情况，<strong>枚举每一个回文中心，并用两个指针向左右两边扩展，两个指针指向相同的时候，就扩展，否则就返回</strong></li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户</p><p>内存消耗：39.4 MB, 在所有 Java 提交中击败了84.78%的用户</p><p>通过测试用例：130 &#x2F; 130</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            count(s,i,i);</span><br><span class="line">            count(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))&#123;</span><br><span class="line">            num++;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>马拉车算法，还没吃透</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了84.76%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了75.45%的用户</p><p>通过测试用例：130 &#x2F; 130</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        StringBuffer t=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;$#&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            t.append(s.charAt(i));</span><br><span class="line">            t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        n=t.length();</span><br><span class="line">        t.append(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> []f=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> iMax=<span class="number">0</span>,rMax=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=i&lt;=rMax?Math.min(rMax-i+<span class="number">1</span>,f[<span class="number">2</span>*iMax-i]):<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t.charAt(i+f[i])==t.charAt(i-f[i]))&#123;</span><br><span class="line">                ++f[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+f[i]-<span class="number">1</span>&gt;rMax)&#123;</span><br><span class="line">                iMax=i;</span><br><span class="line">                rMax=i+f[i]-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=f[i]/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;647-回文子串&quot;&gt;&lt;a href=&quot;#647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;6</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1124</title>
    <link href="https://kkkkkong.github.io/posts/14764.html"/>
    <id>https://kkkkkong.github.io/posts/14764.html</id>
    <published>2023-02-14T12:29:10.000Z</published>
    <updated>2023-02-14T13:04:05.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a><a href="https://leetcode.cn/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a></h4><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hours = [9,9,6,0,6,6,9]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的表现良好时间段是 [9,9,6]。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+前缀和：将原问题转化为和大于0的最小子数组的问题，通过前缀和求解。</li></ol><p>如果hours[i]&gt;8，则arr[i]为1，否则为-1，然后再用arr[i]表示前i个元素的和，要寻找i和j，使得在i&lt;j时，arr[i]-arr[j]&gt;0（也就意味着i到j之间的和大于0，也即问题的求解）</p><p>对于arr[i]，有两种情况</p><ul><li>arr[i]&gt;0，表示前i+1个元素的和是表现良好的时间段</li><li>arr[i]&lt;&#x3D;0，则需要找到一个j，满足j&lt;i，arr[i]-arr[j]&gt;0，对于arr[j]来说，存在两种情况<ul><li>j&lt;i时，不存在arr[i]-arr[j]&gt;0，</li><li>j&lt;i时，存在arr[i]-arr[j]&gt;0，那么此时也一定存在arr[i]-arr[j]&#x3D;1，也即arr[j]&#x3D;arr[i]-1，使用哈希表存储第一次出现的arr[j]即可</li></ul></li></ul><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了70.25%的用户</p><p>内存消耗：42.1 MB, 在所有 Java 提交中击败了44.50%的用户</p><p>通过测试用例：98 &#x2F; 98</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=hours.length;</span><br><span class="line">        <span class="type">int</span> [] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        arr[<span class="number">0</span>]=hours[<span class="number">0</span>]&gt;<span class="number">8</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i]=arr[i-<span class="number">1</span>]+(hours[i]&gt;<span class="number">8</span>?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans=Math.max(ans,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> tmp=map.getOrDefault(arr[i]-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(tmp!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    ans=Math.max(ans,i-tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                map.putIfAbsent(arr[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1124-表现良好的最长时间段&quot;&gt;&lt;a href=&quot;#1124-表现良好的最长时间段&quot; class=&quot;header</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1234</title>
    <link href="https://kkkkkong.github.io/posts/43357.html"/>
    <id>https://kkkkkong.github.io/posts/43357.html</id>
    <published>2023-02-13T09:30:25.000Z</published>
    <updated>2023-02-13T09:32:31.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a></h4><p>有一个只含有 <code>&#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39;</code> 四种字符，且长度为 <code>n</code> 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 <code>n/4</code> 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 <code>s</code>，请通过「替换一个子串」的方式，使原字符串 <code>s</code> 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 <strong>任何</strong> 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;QWER&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：s 已经是平衡的了。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>暴力解法，超时了</p></li><li><p>滑动窗口，重要的是窗口左右移动的时机</p></li></ol><blockquote><p>执行用时：10 ms, 在所有 Java 提交中击败了22.95%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了43.44%的用户</p><p>通过测试用例：40 &#x2F; 40</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []cnt=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        String t=<span class="string">&quot;QWER&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnt[t.indexOf(s.charAt(i))]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m=n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]==m&amp;&amp;cnt[<span class="number">1</span>]==m&amp;&amp;cnt[<span class="number">2</span>]==m&amp;&amp;cnt[<span class="number">3</span>]==m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cnt[t.indexOf(s.charAt(j))]--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;cnt[<span class="number">0</span>]&lt;=m&amp;&amp;cnt[<span class="number">1</span>]&lt;=m&amp;&amp;cnt[<span class="number">2</span>]&lt;=m&amp;&amp;cnt[<span class="number">3</span>]&lt;=m)&#123;</span><br><span class="line">                ans=Math.min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">                cnt[t.indexOf(s.charAt(i++))]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1234-替换子串得到平衡字符串&quot;&gt;&lt;a href=&quot;#1234-替换子串得到平衡字符串&quot; class=&quot;head</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CPU架构</title>
    <link href="https://kkkkkong.github.io/posts/27701.html"/>
    <id>https://kkkkkong.github.io/posts/27701.html</id>
    <published>2023-02-13T07:04:00.000Z</published>
    <updated>2023-02-13T09:32:31.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主流CPU指令集"><a href="#主流CPU指令集" class="headerlink" title="主流CPU指令集"></a>主流CPU指令集</h2><table><thead><tr><th align="center">架构</th><th align="center">指令集位数</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">x86</td><td align="center">32</td><td align="center">Intel开发，CPU架构习惯以86结尾，所以之后被称之为x86</td></tr><tr><td align="center">AMD64</td><td align="center">64</td><td align="center">32位向64位演进时，AMD更早的开发除了兼容x86(32位)指令集的处理器</td></tr><tr><td align="center">x86_64</td><td align="center">64</td><td align="center">Intel为了迈向64位，设计了IA-64（不兼容x86），但反响不好，因此采用了AMD64，并在此基础进行扩充，改名为x86_64，两种差别不大（现在用的intel&#x2F;amd的桌面级CPU基本上都是x86_64）</td></tr><tr><td align="center">ARM</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ARM-V8</td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>x86是一种CISC的指令集</p><p>非x86，一般是RISC指令集</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主流CPU指令集&quot;&gt;&lt;a href=&quot;#主流CPU指令集&quot; class=&quot;headerlink&quot; title=&quot;主流CPU指令集&quot;&gt;&lt;/a&gt;主流CPU指令集&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;架构&lt;/th&gt;
&lt;</summary>
      
    
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 39</title>
    <link href="https://kkkkkong.github.io/posts/4003.html"/>
    <id>https://kkkkkong.github.io/posts/4003.html</id>
    <published>2023-02-13T02:23:12.000Z</published>
    <updated>2023-02-13T02:38:15.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+深度优先搜索+递归</li></ol><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230213102600206.png" alt="image-20230213102600206" style="zoom: 33%;" /><p>图片来源：题解</p><p>使用一个数字，target做减法，不断减少直到target&lt;&#x3D;0，但这样做会出现重复路径，因此需要去重</p><p>去重方法为：同一层的节点，已经使用过的数字不在考虑，也即</p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/image-20230213102848235.png" alt="image-20230213102848235" style="zoom:33%;" /><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了75.79%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了82.05%的用户</p><p>通过测试用例：160 &#x2F; 160</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> len=candidates.length;</span><br><span class="line"></span><br><span class="line">        ArrayDeque&lt;Integer&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">        dfs(candidates,<span class="number">0</span>,len,path,target,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] candidates,<span class="type">int</span> begin,<span class="type">int</span> len,ArrayDeque&lt;Integer&gt; path,<span class="type">int</span> target,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;len;i++)&#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates,i,len,path,target-candidates[i],ans);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝之后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> len=candidates.length;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        ArrayDeque&lt;Integer&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">        dfs(candidates,<span class="number">0</span>,len,path,target,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] candidates,<span class="type">int</span> begin,<span class="type">int</span> len,ArrayDeque&lt;Integer&gt; path,<span class="type">int</span> target,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates,i,len,path,target-candidates[i],ans);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DragonOS 实时调度器相关API</title>
    <link href="https://kkkkkong.github.io/posts/56746.html"/>
    <id>https://kkkkkong.github.io/posts/56746.html</id>
    <published>2023-02-12T01:55:50.000Z</published>
    <updated>2023-02-12T12:20:33.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时进程调度器相关的api"><a href="#实时进程调度器相关的api" class="headerlink" title="实时进程调度器相关的api"></a>实时进程调度器相关的api</h1><p>&amp;emsp;&amp;emsp; RT（realtime scheduler），实时调度器。实时调度是为了完成实时处理任务而分配CPU的调度方法。</p><p>&amp;emsp;&amp;emsp;DragonOS的进程分为“实时进程”和“普通进程”两类；实时进程的优先级高于普通进程，如果当前的系统的执行队列中有“实时进程”，RT调度器会优先选择实时进程；如果队列中会有多个实时进程，调度器会选择优先级最高的实时进程来执行；</p><h2 id="1-RTQueue-介绍"><a href="#1-RTQueue-介绍" class="headerlink" title="1. RTQueue 介绍"></a>1. RTQueue 介绍</h2><p>&amp;emsp;&amp;emsp; RTQueue是用来存放state为running的实时进程的调度队列，每个CPU维护一个RTQueue，主要使用Vec作为主要存储结构来实现。</p><h3 id="1-1-主要函数"><a href="#1-1-主要函数" class="headerlink" title="1.1 主要函数"></a>1.1 主要函数</h3><ol><li><p><strong>enqueue():</strong> 将pcb入队列</p></li><li><p><strong>dequeue():</strong> 将pcb出队列</p></li></ol><h2 id="2-SchedulerRT-介绍"><a href="#2-SchedulerRT-介绍" class="headerlink" title="2. SchedulerRT 介绍"></a>2. SchedulerRT 介绍</h2><p>&amp;emsp;&amp;emsp; RT调度器类，主要实现了RT调度器类的初始化以及调度功能函数。</p><h3 id="2-1-主要函数"><a href="#2-1-主要函数" class="headerlink" title="2.1 主要函数"></a>2.1 主要函数</h3><ol><li><p><strong>pick_next_task_rt():</strong> 获取当前CPU中的第一个需要执行的RT pcb</p></li><li><p><strong>sched():</strong> 是对于Scheduler trait的sched()实现，是实时进程进行调度时的逻辑处理，该函数会返回接下来要执行的pcb，若没有符合要求的pcb，返回None</p></li><li><p><strong>enqueue():</strong> 同样是对于Scheduler trait的sched()实现，将一个pcb加入调度器的调度队列</p></li></ol><h3 id="2-2-内核调度策略"><a href="#2-2-内核调度策略" class="headerlink" title="2.2 内核调度策略"></a>2.2 内核调度策略</h3><p>目前在DragonOS中，主要的调度策略有SCHED_NORMAL 策略 | SCHED_FIFO 策略 | SCHED_RT 策略，具体的调度策略为：</p><ol><li><p><strong>SCHED_NORMAL 策略</strong>：SCHED_NORMAL 是“绝对公平调度策略”，该策略的进程使用CFS进行调度。</p></li><li><p><strong>SCHED_FIFO 策略</strong>：SCHED_FIFO是“实时进程调度策略”，这是一种先进先出的调度策略，该策略不涉及到CPU时间片机制，在没有更高优先级进程的前提下，只能等待其他进程主动释放CPU资源；在SCHED_FIFO策略中，被调度器调度运行的进程，其运行时长不受限制，可以运行任意长的时间。</p></li><li><p><strong>SCHED_RR 策略</strong>：SCHED_RR是“实时进程调度策略”，使用的是时间片轮转机制，对应进程的time_slice会在运行时减少，进程使用完CPU时间片后，会加入该CPU的与该进程优先级相同的执行队列中。同时，释放CPU资源，CPU的使用权会被分配给下一个执行的进程</p></li></ol><h2 id="3-Q-amp-A"><a href="#3-Q-amp-A" class="headerlink" title="3. Q&amp;A"></a>3. Q&amp;A</h2><ol><li><p>如何创建实时进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">pcb_name</span> =</span> kthread_run_rt(&amp;fn_name, <span class="literal">NULL</span>, <span class="string">&quot;test create rt pcb&quot;</span>);</span><br></pre></td></tr></table></figure><p>  其中kthread_run_rt，是创建内核实时线程的宏</p></li><li><p>pcb中涉及到实时进程的字段含义</p><ol><li><p><strong>policy：</strong>实时进程的策略，目前有：SCHED_FIFO与SCHED_RR</p></li><li><p><strong>priority:</strong> 实时进程的优先级，范围为0-99，数字越大，表示优先级越高</p></li><li><p><strong>rt_time_slice:</strong> 调度策略为 “RR” 的实时进程的时间片，默认为100，随着CPU运行而减少，在rt_time_slice为0时，将时间片赋初值并将该进程加入执行队列。</p></li></ol></li><li><p>如何实时进程存储队列</p><ul><li>目前是使用 Vec 来保存，因为具体实现的逻辑原因，目前的入队列和出队列都是对队尾的操作，因此会有如下现象：系统中有<strong>多个优先级相同的实时进程</strong>等待运行时，会出现<strong>饥饿现象</strong>，也即上一个因为时间片耗尽的进程会在下一个执行，造成同优先级等待的进程饥饿。</li></ul></li><li><p>TODO</p><ol><li><p>将存储实时进程的队列改为使用双向链表存储（或者其他办法解决上述的饥饿问题）</p></li><li><p>多核CPU的实时调度</p><ul><li>目前的实时调度是针对单核CPU的，需要实现多核CPU的实时调度</li></ul></li><li><p>RT进程带宽比</p><ul><li><p>由于实时任务的优先级高于普通任务，因而为了防止cpu消耗型的实时任务一直占用cpu引发其他任务”饥饿”的情况发生，linux内核采用了带宽限制手段来抑制实时任务的运行时间</p></li><li><p><strong>带宽限制：</strong>在任务调度中带宽限制就是指一定周期内一个队列上任务可运行的最大时间</p></li></ul></li><li><p>多个CPU之间实现<strong>负载均衡</strong></p><ul><li>最开始linux采用跟踪每个CPU的运行队列的负载情况来进行负载计算和决策</li><li>之后linux引入PELT <code>PELT, Per-entity load tracking </code>，通过跟踪每个调度实体的负载贡献来计算CPU负载，来进行调度决策</li></ul></li><li><p>更远：组调度</p><ul><li><strong>要解决的问题：</strong>A和B两个用户使用同一台机器，A用户16个进程，B用户2个进程，如果按照进程的个数来分配CPU资源，显然A用户会占据大量的CPU时间，这对于B用户是不公平的。组调度就可以解决这个问题，分别将A、B用户进程划分成组，并将两组的权重设置成占比50%即可。（调度时不再以进程为单位，而是以进程组作为调度实体）</li></ul></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时进程调度器相关的api&quot;&gt;&lt;a href=&quot;#实时进程调度器相关的api&quot; class=&quot;headerlink&quot; title=&quot;实时进程调度器相关的api&quot;&gt;&lt;/a&gt;实时进程调度器相关的api&lt;/h1&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp; RT（re</summary>
      
    
    
    
    
    <category term="学习" scheme="https://kkkkkong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="实时调度器" scheme="https://kkkkkong.github.io/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 148</title>
    <link href="https://kkkkkong.github.io/posts/64491.html"/>
    <id>https://kkkkkong.github.io/posts/64491.html</id>
    <published>2023-02-09T06:54:04.000Z</published>
    <updated>2023-02-10T01:31:29.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h4><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/sort_list_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>排序+链表：将链表存储在ArrayList中，使用库函数sort，然后在写入链表中，返回。自己没有写sort</li></ol><blockquote><p>执行用时：18 ms, 在所有 Java 提交中击败了14.19%的用户</p><p>内存消耗：52.4 MB, 在所有 Java 提交中击败了7.16%的用户</p><p>通过测试用例：30 &#x2F; 30</p><p>时间 O(NLogN)</p><p>空间O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode ans=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode res=ans;</span><br><span class="line">        ListNode tmp=head;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort(Comparator.naturalOrder());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            ans.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(list.get(i));</span><br><span class="line">            ans=ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归+归并排序：首先将链表找到链表的中间节点一分为二进行排序，将排序后的两个链表合并，参考《两个有序链表的合并》，此方法由于使用了递归，所以空间复杂度为O(logN)，尚未达到常数级</li></ol><blockquote><p>执行用时：11 ms, 在所有 Java 提交中击败了55.92%的用户</p><p>内存消耗：49.8 MB, 在所有 Java 提交中击败了48.05%的用户</p><p>通过测试用例：30 &#x2F; 30</p><p>时间 O(NLogN)</p><p>空间 O(logN)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head,ListNode tail)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next==tail)&#123;</span><br><span class="line">            head.next=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode low=head,fast=head;</span><br><span class="line">        ListNode tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail)&#123;</span><br><span class="line">            low=low.next;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail)&#123;</span><br><span class="line">                fast=fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid=low;</span><br><span class="line">        ListNode left=sortList(tmp,mid);</span><br><span class="line">        ListNode right=sortList(mid,tail);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        ListNode ans=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode tmp=ans;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span>&amp;&amp;node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val&lt;=node2.val)&#123;</span><br><span class="line">                ans.next=node1;</span><br><span class="line">                node1=node1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.next=node2;</span><br><span class="line">                node2=node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ans.next=node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.next=node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>遍历，重度参考了官方题解</li></ol><blockquote><p>执行用时：15 ms, 在所有 Java 提交中击败了30.16%的用户</p><p>内存消耗：49.4 MB, 在所有 Java 提交中击败了64.19%的用户</p><p>通过测试用例：30 &#x2F; 30</p><p>时间 O(NLogN)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        <span class="comment">// 首先获取链表长度</span></span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode ans=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="comment">// 将链表分成slenth长的段，初始为1，合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> slen=<span class="number">1</span>;slen&lt;length;slen&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode curr=ans.next,prev=ans;</span><br><span class="line">            <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 需要排序的第一个元素</span></span><br><span class="line">                ListNode head1=curr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;slen&amp;&amp;curr.next!=<span class="literal">null</span>;i++)&#123;</span><br><span class="line">                    curr=curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要排序的第二个元素</span></span><br><span class="line">                ListNode head2=curr.next;</span><br><span class="line">                curr.next=<span class="literal">null</span>;</span><br><span class="line">                curr=head2;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;slen&amp;&amp;curr!=<span class="literal">null</span>&amp;&amp;curr.next!=<span class="literal">null</span>;i++)&#123;</span><br><span class="line">                    curr=curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保存后续未排序元素的头节点，并将排序的部分切分</span></span><br><span class="line">                <span class="comment">// 这句话会导致超时</span></span><br><span class="line">                <span class="comment">// ListNode next=new ListNode();</span></span><br><span class="line">                ListNode next=<span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    next=curr.next;</span><br><span class="line">                    curr.next=<span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ListNode merged=merge(head1,head2);</span><br><span class="line">                prev.next=merged;</span><br><span class="line">                <span class="keyword">while</span>(prev.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    prev=prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr=next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        ListNode ans=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode tmp=ans;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span>&amp;&amp;node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val&lt;=node2.val)&#123;</span><br><span class="line">                ans.next=node1;</span><br><span class="line">                node1=node1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.next=node2;</span><br><span class="line">                node2=node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ans.next=node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.next=node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;148-排序链表&quot;&gt;&lt;a href=&quot;#148-排序链表&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1797</title>
    <link href="https://kkkkkong.github.io/posts/2315.html"/>
    <id>https://kkkkkong.github.io/posts/2315.html</id>
    <published>2023-02-09T01:43:48.000Z</published>
    <updated>2023-02-10T01:31:29.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1797-设计一个验证系统"><a href="#1797-设计一个验证系统" class="headerlink" title="1797. 设计一个验证系统"></a><a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></h4><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code> 类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li></ul><p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/copy-of-pc68_q2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;AuthenticationManager&quot;, &quot;renew&quot;, &quot;generate&quot;, &quot;countUnexpiredTokens&quot;, &quot;generate&quot;, &quot;renew&quot;, &quot;renew&quot;, &quot;countUnexpiredTokens&quot;]</span><br><span class="line">[[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, null, null, 0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。</span><br><span class="line">authenticationManager.renew(&quot;aaa&quot;, 1); // 时刻 1 时，没有验证码的 tokenId 为 &quot;aaa&quot; ，没有验证码被更新。</span><br><span class="line">authenticationManager.generate(&quot;aaa&quot;, 2); // 时刻 2 时，生成一个 tokenId 为 &quot;aaa&quot; 的新验证码。</span><br><span class="line">authenticationManager.countUnexpiredTokens(6); // 时刻 6 时，只有 tokenId 为 &quot;aaa&quot; 的验证码未过期，所以返回 1 。</span><br><span class="line">authenticationManager.generate(&quot;bbb&quot;, 7); // 时刻 7 时，生成一个 tokenId 为 &quot;bbb&quot; 的新验证码。</span><br><span class="line">authenticationManager.renew(&quot;aaa&quot;, 8); // tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，且 8 &gt;= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。</span><br><span class="line">authenticationManager.renew(&quot;bbb&quot;, 10); // tokenId 为 &quot;bbb&quot; 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。</span><br><span class="line">authenticationManager.countUnexpiredTokens(15); // tokenId 为 &quot;bbb&quot; 的验证码在时刻 15 过期，tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>按部就班，主要就是看过期时间和当前时间的关系，没啥意思</li></ol><blockquote><p>执行用时：51 ms, 在所有 Java 提交中击败了68.23%的用户</p><p>内存消耗：42.6 MB, 在所有 Java 提交中击败了85.88%的用户</p><p>通过测试用例：90 &#x2F; 90</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> myTimeToLive;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthenticationManager</span><span class="params">(<span class="type">int</span> timeToLive)</span> &#123;</span><br><span class="line">        myTimeToLive=timeToLive;</span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">(String tokenId, <span class="type">int</span> currentTime)</span> &#123;</span><br><span class="line">        map.put(tokenId,currentTime+myTimeToLive);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renew</span><span class="params">(String tokenId, <span class="type">int</span> currentTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> endTime=map.getOrDefault(tokenId,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(endTime&gt;currentTime)&#123;</span><br><span class="line">            map.put(tokenId,currentTime+myTimeToLive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countUnexpiredTokens</span><span class="params">(<span class="type">int</span> currentTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> value:map.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;currentTime)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AuthenticationManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AuthenticationManager obj = new AuthenticationManager(timeToLive);</span></span><br><span class="line"><span class="comment"> * obj.generate(tokenId,currentTime);</span></span><br><span class="line"><span class="comment"> * obj.renew(tokenId,currentTime);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.countUnexpiredTokens(currentTime);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1797-设计一个验证系统&quot;&gt;&lt;a href=&quot;#1797-设计一个验证系统&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 105</title>
    <link href="https://kkkkkong.github.io/posts/65064.html"/>
    <id>https://kkkkkong.github.io/posts/65064.html</id>
    <published>2023-02-08T11:06:03.000Z</published>
    <updated>2023-02-08T11:38:19.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>递归，根据前序和中序的特性，前序数组的第一个元素一定为根节点，那么在中序数组中找到该节点，在中序数组中，该节点左侧的都是left上的节点，对应数量在前序数组的root节点之后，以此将其分开</li></ol><blockquote><p>执行用时：9 ms, 在所有 Java 提交中击败了8.56%的用户</p><p>内存消耗：86.4 MB, 在所有 Java 提交中击败了5.00%的用户</p><p>通过测试用例：203 &#x2F; 203</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> tmp=preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(inorder[i]!=tmp)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left=buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">        root.right=buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归但不使用 Arrays.copyOfRange，</li></ol><blockquote><p>执行用时：3 ms, 在所有 Java 提交中击败了42.85%的用户</p><p>内存消耗：40.9 MB, 在所有 Java 提交中击败了97.12%的用户</p><p>通过测试用例：203 &#x2F; 203</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">myBuildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span> preI,<span class="type">int</span> preJ, <span class="type">int</span>[] inorder,<span class="type">int</span> inI,<span class="type">int</span> inJ)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preJ&lt;preI)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preI]);</span><br><span class="line">        <span class="type">int</span> i=inI;</span><br><span class="line">        <span class="keyword">while</span>(inorder[i]!=preorder[preI])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left=myBuildTree(preorder,preI+<span class="number">1</span>,preI+i-inI,inorder,inI,i-<span class="number">1</span>);</span><br><span class="line">        root.right=myBuildTree(preorder,preI+<span class="number">1</span>+i-inI,preJ,inorder,i+<span class="number">1</span>,inJ );</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#105-从前序与中序遍历序列构造二叉树&quot; class</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1233</title>
    <link href="https://kkkkkong.github.io/posts/27420.html"/>
    <id>https://kkkkkong.github.io/posts/27420.html</id>
    <published>2023-02-08T08:40:58.000Z</published>
    <updated>2023-02-08T11:38:19.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h4><p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的 <strong>子文件夹</strong> 。</p><p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。</p><ul><li>例如，<code>&quot;/leetcode&quot;</code> 和 <code>&quot;/leetcode/problems&quot;</code> 都是有效的路径，而空字符串和 <code>&quot;/&quot;</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]</span><br><span class="line">输出：[&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]</span><br><span class="line">解释：&quot;/a/b/&quot; 是 &quot;/a&quot; 的子文件夹，而 &quot;/c/d/e&quot; 是 &quot;/c/d&quot; 的子文件夹。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力求解</li></ol><blockquote><p>超时</p><p>时间 O(N*N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeSubfolders</span><span class="params">(String[] folder)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;folder.length;i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> isChild=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;folder.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isChildFolder(folder[i],folder[j]))&#123;</span><br><span class="line">                        isChild=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isChild)&#123;</span><br><span class="line">                ans.add(folder[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断a是否是b的子文件夹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChildFolder</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length()&lt;=b.length())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a.startsWith(b)&amp;&amp;a.charAt(b.length())==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>排序+规律，核心的规律为：在将字符串数组按照字典序排序之后，父子文件夹是相邻的，并且父在前，子在后。</li></ol><blockquote><p>执行用时：43 ms, 在所有 Java 提交中击败了82.84%的用户</p><p>内存消耗：51.5 MB, 在所有 Java 提交中击败了30.77%的用户</p><p>通过测试用例：32 &#x2F; 32</p><p>时间 O(NLogN)，排序算法复杂度</p><p>空间 O(N)，排序算法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeSubfolders</span><span class="params">(String[] folder)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Arrays.sort(folder);</span><br><span class="line">        String tmp=folder[<span class="number">0</span>];</span><br><span class="line">        ans.add(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;folder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isChildFolder(folder[i],tmp))&#123;</span><br><span class="line">                tmp=folder[i];</span><br><span class="line">                ans.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断a是否是b的子文件夹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChildFolder</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length()&lt;=b.length())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a.startsWith(b)&amp;&amp;a.charAt(b.length())==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;1233-删除子文件夹&quot;&gt;&lt;a href=&quot;#1233-删除子文件夹&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 287</title>
    <link href="https://kkkkkong.github.io/posts/65374.html"/>
    <id>https://kkkkkong.github.io/posts/65374.html</id>
    <published>2023-02-07T12:38:48.000Z</published>
    <updated>2023-02-08T11:38:19.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因题目要求不修改数组且空间复杂度为O(1)，因此有些思路不可用，如</p><ol><li><p>排序+遍历</p><ol><li><blockquote><p>时间 O(NlogN)、空间 O(N)</p></blockquote></li></ol></li><li><p>哈希表</p><ol><li>时间 O(N)、空间 O(N)</li></ol></li></ol><p>符合题目要求的思路</p><ol><li>两层for，暴力求解</li></ol><blockquote><p>超时</p><p>时间 O(N*N)</p><p>空间 O(1)</p></blockquote><ol start="2"><li>参考题解，二进制法。核心思想：考虑数字的第 i 位，nums数组中的数字，第 i 位为1的数字个数为x；[1,n]中的数字，第 i 位为1的数字个数为y，x&gt;y是 &lt;&#x3D;&gt; 重复的数字第 i 位为1。</li></ol><blockquote><p>执行用时：48 ms, 在所有 Java 提交中击败了5.05%的用户</p><p>内存消耗：58.4 MB, 在所有 Java 提交中击败了84.90%的用户</p><p>通过测试用例：58 &#x2F; 58</p><p>时间 O(NlogN)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">// 记录n的最大位数</span></span><br><span class="line">        <span class="type">int</span> bitMax=<span class="number">31</span>;</span><br><span class="line">        <span class="comment">// 找到n-1的有效位数</span></span><br><span class="line">        <span class="keyword">while</span>((n-<span class="number">1</span>)&gt;&gt;bitMax==<span class="number">0</span>)&#123;</span><br><span class="line">            bitMax--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> bit=<span class="number">0</span>;bit&lt;=bitMax;bit++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i]&amp;(<span class="number">1</span>&lt;&lt;bit))!=<span class="number">0</span>)&#123;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp; (i&amp;(<span class="number">1</span>&lt;&lt;bit))!=<span class="number">0</span>)&#123;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">                res|=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>双指针，将数组问题转换为环形链表问题</li></ol><blockquote><p>如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，<br>其映射关系 n-&gt;f(n) 为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>4-&gt;2<br>同样的，我们从下标为 0 出发，根据<br>f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。<br>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;……</p></blockquote><blockquote><p>评论区大神：（<strong>这应该是142题的解法证明，关键在于理解在找到环以后，为什么fast和从0开始向前移动，会同时到达环形开始点</strong>） low &#x3D; fast 时，快慢指针相遇，low 走过的距离是初始点（0）到环状开始的点 （x） 加上 环状开始的点（x） 到相遇点（y） 这段距离，而fast走过的距离是 初始点（0）到环状开始的点（x），点（x） 到点（y），点（y）到点（x），点（x）到点（y）。又因为fast走过的距离是low的两倍，设0到x长度为a，x到y长度为b,则有2*（a+b） &#x3D; a+ b+ (y到x的距离) + b，则y到x的距离就等于0到x的距离。所以当新的两个指针 一个从0出发，一个从相遇点y出发时，他们走到的相同的值就是环状开始的点，即x点。</p><p>执行用时：4 ms, 在所有 Java 提交中击败了93.31%的用户</p><p>内存消耗：59 MB, 在所有 Java 提交中击败了29.98%的用户</p><p>通过测试用例：58 &#x2F; 58</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=nums[<span class="number">0</span>],fast=nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow=nums[slow];</span><br><span class="line">            fast=nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre1=<span class="number">0</span>,pre2=fast;</span><br><span class="line">        <span class="keyword">while</span>(pre1!=pre2)&#123;</span><br><span class="line">            pre1=nums[pre1];</span><br><span class="line">            pre2=nums[pre2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;287-寻找重复数&quot;&gt;&lt;a href=&quot;#287-寻找重复数&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 102</title>
    <link href="https://kkkkkong.github.io/posts/15465.html"/>
    <id>https://kkkkkong.github.io/posts/15465.html</id>
    <published>2023-02-07T11:48:50.000Z</published>
    <updated>2023-02-08T11:38:19.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用list按顺序存储节点，由于返回值 List&lt;List<Integer>&gt;，因此需要记录每层的节点数，获取一个节点，上层节点数减一，没添加一个节点，下层节点数加一；获取的节点值加入list，上层节点数为0时，将list加入结果队列并置空。</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了60.14%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了26.37%的用户</p><p>通过测试用例：34 &#x2F; 34</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 使用list存储子节点，从list头部访问一个节点时，将其子节点将入队尾</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;TreeNode&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 使用num存储当前层和下一层的节点数</span></span><br><span class="line">        <span class="type">int</span> numUp=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> numLow=<span class="number">0</span>;</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        List&lt;Integer&gt; value=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">while</span>(!tmp.isEmpty())&#123;</span><br><span class="line">            TreeNode node=tmp.get(<span class="number">0</span>);</span><br><span class="line">            tmp.remove(<span class="number">0</span>);</span><br><span class="line">            value.add(node.val);</span><br><span class="line">            numUp--;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tmp.add(node.left);</span><br><span class="line">                numLow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tmp.add(node.right);</span><br><span class="line">                numLow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numUp==<span class="number">0</span>)&#123;</span><br><span class="line">                res.add(value);</span><br><span class="line">                value=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                numUp=numLow;</span><br><span class="line">                numLow=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据官方题解，使用ArrayDeque试了一下，效果差不多</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了60.14%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了83.45%的用户</p><p>通过测试用例：34 &#x2F; 34</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 使用list存储子节点，从list头部访问一个节点时，将其子节点将入队尾</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用num存储当前层和下一层的节点数</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; value=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            <span class="type">int</span> n=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span>queue.poll();</span><br><span class="line">                value.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 49</title>
    <link href="https://kkkkkong.github.io/posts/16289.html"/>
    <id>https://kkkkkong.github.io/posts/16289.html</id>
    <published>2023-02-07T10:33:57.000Z</published>
    <updated>2023-02-08T11:38:19.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+排序，首先将字符串按字母顺序排列，然后使用哈希表存储，添加原字符串到返回结果中</li></ol><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了80.00%的用户</p><p>内存消耗：44.7 MB, 在所有 Java 提交中击败了37.70%的用户</p><p>通过测试用例：118 &#x2F; 118</p><p>时间 O(NlogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 将字符串按字母顺序排列</span></span><br><span class="line">            <span class="type">char</span>[] strToChar=strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(strToChar);</span><br><span class="line">            String tmp=<span class="keyword">new</span> <span class="title class_">String</span>(strToChar);</span><br><span class="line">            <span class="comment">// 使用哈希表存储，添加原字符串到返回结果中</span></span><br><span class="line">            List&lt;String&gt; value=map.getOrDefault(tmp,<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">            value.add(strs[i]);</span><br><span class="line">            map.put(tmp,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; value:map.values())&#123;</span><br><span class="line">            res.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>评论区：在美版leetcode上看到大神的思路，用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。（这个用质数表示真的很骚啊！！!）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;49-字母异位词分组&quot;&gt;&lt;a href=&quot;#49-字母异位词分组&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
