<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫兑变的博客</title>
  
  <subtitle>我的博客</subtitle>
  <link href="https://kkkkkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kkkkkong.github.io/"/>
  <updated>2023-03-06T14:04:50.920Z</updated>
  <id>https://kkkkkong.github.io/</id>
  
  <author>
    <name>Kong Weichao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github 首页个人信息展示</title>
    <link href="https://kkkkkong.github.io/posts/18448.html"/>
    <id>https://kkkkkong.github.io/posts/18448.html</id>
    <published>2023-03-06T12:35:20.000Z</published>
    <updated>2023-03-06T14:04:50.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github首页配置"><a href="#github首页配置" class="headerlink" title="github首页配置"></a>github首页配置</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>美化github首页，成果如下，欢迎访问</p><p><a href="https://github.com/kkkkkong">kkkkkong (kong) (github.com)</a></p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li>创建github同名仓库</li><li>填写README.md</li><li>配置README.md</li></ol><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>问题描述</p><blockquote><p>Error: Pushing to <a href="https://github.com/kkkkkong/kkkkkong">https://github.com/kkkkkong/kkkkkong</a> remote: Permission to kkkkkong&#x2F;kkkkkong.git denied to github-actions[bot]. fatal: unable to access ‘<a href="https://github.com/kkkkkong/kkkkkong/&#39;">https://github.com/kkkkkong/kkkkkong/&#39;</a>: The requested URL returned error: 403</p></blockquote><p>这个错误意味着你尝试将代码推送到GitHub上的一个仓库，但是你没有足够的权限来进行这个操作。具体地说，这个错误信息显示了github-actions[bot]被拒绝了权限，因此无法推送代码到这个仓库。</p><p>我尝试了以下操作</p><ol><li>首先可能是因为github action没有权限，因此创建访问令牌或者使用ssh秘钥，然后配置文件被我修改成这样<ol><li>首先，在你的GitHub账户中生成一个新的访问令牌。你可以按照以下步骤来生成一个GitHub访问令牌：<ol><li>首先，登录到你的GitHub帐户中。</li><li>点击右上角的你的头像，然后选择”Settings”。</li><li>在左侧菜单中，选择”Developer settings”，然后选择”Personal access tokens”。</li><li>点击”Generate new token”按钮。</li><li>在”Note”字段中，为你的访问令牌添加一个描述性的名称。</li><li>选择所需的权限。根据你的需求，你可以选择只授予必要的权限，以便最大程度地减少安全风险。如果你不确定要选择哪些权限，请参考<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">GitHub官方文档</a>。</li><li>点击”Generate token”按钮。</li><li>复制生成的访问令牌。请注意，此令牌仅在此时显示，你必须复制它以后才能使用。</li><li>将该访问令牌安全地保存在一个安全的位置，以便以后使用。</li></ol></li><li>将生成的访问令牌添加到你的GitHub存储库的<code>Secrets</code>中。在你的存储库中，点击<code>Settings</code>，然后点击<code>Secrets</code>，再点击<code>New repository secret</code>按钮来添加一个新的秘密。你需要将秘密的名称设置为<code>ACCESS_TOKEN</code>，并将生成的访问令牌作为值输入。</li><li>在你的workflow文件中，使用<code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code>来引用你的访问令牌。</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Action for generating a contribution graph with a snake eating your contributions.</span><br><span class="line"></span><br><span class="line">name: Generate Snake</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: &quot;0 0 * * *&quot;</span><br><span class="line">  workflow_dispatch:</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@v2.3.4</span><br><span class="line">      </span><br><span class="line">      - name: Generate Snake</span><br><span class="line">        uses: Platane/snk@master</span><br><span class="line">        id: snake-gif</span><br><span class="line">        with:</span><br><span class="line">          github_user_name: $&#123;&#123; github.repository_owner &#125;&#125;</span><br><span class="line">          gif_out_path: ./assets/github-contribution-grid-snake.gif</span><br><span class="line">          svg_out_path: ./assets/github-contribution-grid-snake.svg</span><br><span class="line">          github_token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line"></span><br><span class="line">      - name: Push to GitHub</span><br><span class="line">        uses: EndBug/add-and-commit@v7.2.1</span><br><span class="line">        with:</span><br><span class="line">          branch: main</span><br><span class="line">          message: &#x27;Generate Contribution Snake&#x27;</span><br><span class="line">          author_name: Your Name</span><br><span class="line">          author_email: yourname@example.com</span><br><span class="line">          force: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>我的仍然不起作用，后来发现仓库默认情况下，新存储库没有适当的工作流权限。修改后可以运行了<ol><li>转到存储库<strong>Setting</strong></li><li>选择<strong>Actions</strong>&gt;&gt;&gt;<strong>General</strong></li><li>在”工作流权限(Workflow permissions)”中，选择<code>Read and write permissions</code></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/9513280ff5fd4ac8867c6ba44346a290.png" alt="img"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/454597068">Github 首页美化教程（一）：打造个性化的GitHub首页 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_42282187/article/details/124766382?spm=1001.2014.3001.5501">【Git】workflows 部署 vuepress 错误“The process ‘&#x2F;usr&#x2F;bin&#x2F;git‘ failed with exit code 128“_the process ‘&#x2F;usr&#x2F;bin&#x2F;git’ failed with exit code 1_菜鸟点滴的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;github首页配置&quot;&gt;&lt;a href=&quot;#github首页配置&quot; class=&quot;headerlink&quot; title=&quot;github首页配置&quot;&gt;&lt;/a&gt;github首页配置&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="github" scheme="https://kkkkkong.github.io/categories/github/"/>
    
    
    <category term="github" scheme="https://kkkkkong.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 47</title>
    <link href="https://kkkkkong.github.io/posts/64288.html"/>
    <id>https://kkkkkong.github.io/posts/64288.html</id>
    <published>2023-03-06T09:08:01.000Z</published>
    <updated>2023-03-06T09:40:23.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素重复的不可重复选的排列问题</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了41.88%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了89.25%的用户</p><p>通过测试用例：33 &#x2F; 33</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> []used=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backTrack(nums,used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> []nums,<span class="type">boolean</span> []used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i])||used[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            backTrack(nums,used);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            used[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;47-全排列-II&quot;&gt;&lt;a href=&quot;#47-全排列-II&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 40</title>
    <link href="https://kkkkkong.github.io/posts/14689.html"/>
    <id>https://kkkkkong.github.io/posts/14689.html</id>
    <published>2023-03-06T06:40:04.000Z</published>
    <updated>2023-03-06T09:40:23.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h4><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素可重复的不可重复选的组合问题。如果不进行第二段剪枝的话会超时</li></ol><blockquote><p>执行用时：4 ms, 在所有 Java 提交中击败了43.75%的用户</p><p>内存消耗：41.7 MB, 在所有 Java 提交中击败了65.39%的用户</p><p>通过测试用例：176 &#x2F; 176</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTrack(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> []candidates,<span class="type">int</span> target,<span class="type">int</span> start,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            backTrack(candidates,target,i+<span class="number">1</span>,sum+candidates[i]);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;40-组合总和-II&quot;&gt;&lt;a href=&quot;#40-组合总和-II&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 90</title>
    <link href="https://kkkkkong.github.io/posts/43365.html"/>
    <id>https://kkkkkong.github.io/posts/43365.html</id>
    <published>2023-03-06T06:22:59.000Z</published>
    <updated>2023-03-06T06:28:46.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素重复不可复选问题，需要提前排序</li></ol><blockquote><p>执行用时：1 ms, 在所有 Java 提交中击败了99.17%的用户</p><p>内存消耗：41.6 MB, 在所有 Java 提交中击败了76.27%的用户</p><p>通过测试用例：20 &#x2F; 20</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;begin)&amp;&amp;(nums[i]==nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTrace(nums,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;90-子集-II&quot;&gt;&lt;a href=&quot;#90-子集-II&quot; class=&quot;headerlink&quot; title=&quot;9</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 77</title>
    <link href="https://kkkkkong.github.io/posts/2848.html"/>
    <id>https://kkkkkong.github.io/posts/2848.html</id>
    <published>2023-03-06T02:57:08.000Z</published>
    <updated>2023-03-06T03:03:51.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯：元素无重复不可复选问题</li></ol><blockquote><p>执行用时：18 ms, 在所有 Java 提交中击败了25.06%的用户</p><p>内存消耗：42.9 MB, 在所有 Java 提交中击败了37.61%的用户</p><p>通过测试用例：27 &#x2F; 27</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTrace(n,<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> begin,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;begin&lt;=n;begin++)&#123;</span><br><span class="line">            list.add(begin);</span><br><span class="line">            backTrace(n,begin+<span class="number">1</span>,k);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;77-组合&quot;&gt;&lt;a href=&quot;#77-组合&quot; class=&quot;headerlink&quot; title=&quot;77. 组合&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 78</title>
    <link href="https://kkkkkong.github.io/posts/3936.html"/>
    <id>https://kkkkkong.github.io/posts/3936.html</id>
    <published>2023-03-06T02:32:06.000Z</published>
    <updated>2023-03-06T03:03:51.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+组合：元素无重复不可重复选问题</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了6.15%的用户</p><p>通过测试用例：10 &#x2F; 10</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        getSets(nums,<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSets</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;begin&lt;nums.length;begin++)&#123;</span><br><span class="line">            list.add(nums[begin]);</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            getSets(nums,begin+<span class="number">1</span>,list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>稍微修改一下</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了10.75%的用户</p><p>通过测试用例：10 &#x2F; 10</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        getSets(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSets</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">        <span class="keyword">for</span>(;begin&lt;nums.length;begin++)&#123;</span><br><span class="line">            list.add(nums[begin]);</span><br><span class="line">            getSets(nums,begin+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;78-子集&quot;&gt;&lt;a href=&quot;#78-子集&quot; class=&quot;headerlink&quot; title=&quot;78. 子集&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>一台电脑连接多个github账户如何配置秘钥</title>
    <link href="https://kkkkkong.github.io/posts/37835.html"/>
    <id>https://kkkkkong.github.io/posts/37835.html</id>
    <published>2023-03-04T14:05:22.000Z</published>
    <updated>2023-03-04T14:16:50.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室多个人使用同一台服务器，使用git时配置秘钥分别连接自己的github账户，此时会出现总是匹配一个固定的秘钥的情况</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-生成秘钥"><a href="#1-生成秘钥" class="headerlink" title="1. 生成秘钥"></a>1. 生成秘钥</h3><p>此处具体细节和网上的一样，假设生成两个秘钥，名字分别为id_rsa和id_rsa_bak，对应的公钥为后缀多了.pub</p><h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="2. 编辑配置文件"></a>2. 编辑配置文件</h3><p>编辑<code>.ssh/config</code>文件，内容为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 第一个</span><br><span class="line">Host github_one</span><br><span class="line">Hostname github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># 第二个</span><br><span class="line">Host github_two</span><br><span class="line">Hostname github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_bak</span><br></pre></td></tr></table></figure><blockquote><p>网上的大部分教程都是避其锋芒，配置里大多是不同的网站，比如github和gitee，明显不符合我们的需求</p></blockquote><p>把公钥放在对应的github账户上，然后执行下面的命令即可</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github_one</span><br><span class="line">ssh -T git@github_two</span><br></pre></td></tr></table></figure><h3 id="3-关联仓库"><a href="#3-关联仓库" class="headerlink" title="3. 关联仓库"></a>3. 关联仓库</h3><p>在以后关联仓库的时候，把@后面的内容要修改为对应的host</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github_one:xxx/example.git # public user</span><br><span class="line">git remote add origin git@github_two:xxx/example.git # priavate user</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/107341502">一台电脑双GitHub账户配置 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;实验室多个人使用同一台服务器，使用git时配置秘钥分别连接自己的github账户，此时会出现总是匹配一个固定的秘钥的情况&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="git" scheme="https://kkkkkong.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://kkkkkong.github.io/tags/git/"/>
    
    <category term="github" scheme="https://kkkkkong.github.io/tags/github/"/>
    
    <category term="ssh" scheme="https://kkkkkong.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 51</title>
    <link href="https://kkkkkong.github.io/posts/27041.html"/>
    <id>https://kkkkkong.github.io/posts/27041.html</id>
    <published>2023-03-02T08:37:21.000Z</published>
    <updated>2023-03-04T14:16:50.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h4><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>回溯+哈希：做前序状态记录比较麻烦，导致效率不高</li></ol><blockquote><p>执行用时：9 ms, 在所有 Java 提交中击败了10.60%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了34.87%的用户</p><p>通过测试用例：9 &#x2F; 9</p><p>时间 O(NLogN)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backTrack(n,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(),<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n,List&lt;String&gt; list,HashMap&lt;Integer,Integer&gt; used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==n)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used.containsValue(i))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> x=used.getOrDefault(used.size()-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(x!=-<span class="number">1</span>&amp;&amp;!isTrue(used,i,n))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> []c=<span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">            Arrays.fill(c,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            c[i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            used.put(used.size(),i);</span><br><span class="line">            list.add(String.valueOf(c));</span><br><span class="line">            backTrack(n,list,used);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            used.remove(used.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrue</span><span class="params">(HashMap&lt;Integer,Integer&gt; used,<span class="type">int</span> i,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> j=used.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;j;t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used.getOrDefault(t,-<span class="number">1</span>)==i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t+i&lt;n&amp;&amp;j-t&gt;=<span class="number">0</span>;t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used.getOrDefault(j-t,-<span class="number">1</span>)==i+t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=j&amp;&amp;t&lt;=i;t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used.getOrDefault(j-t,-<span class="number">1</span>)==i-t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; class=&quot;headerlink&quot; title=&quot;51.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 46</title>
    <link href="https://kkkkkong.github.io/posts/15329.html"/>
    <id>https://kkkkkong.github.io/posts/15329.html</id>
    <published>2023-03-02T02:50:05.000Z</published>
    <updated>2023-03-04T14:16:50.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>哈希表+回溯：引入了额外的哈希表，但浪费时间，可能是在数组与list的转换上，需要用到stream来装箱</li></ol><blockquote><p>执行用时：2 ms, 在所有 Java 提交中击败了8.40%的用户</p><p>内存消耗：41.9 MB, 在所有 Java 提交中击败了28.32%的用户</p><p>通过测试用例：26 &#x2F; 26</p><p>时间 O(N!)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; tmpNums=Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line">        backTrack(tmpNums,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; nums,List&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            tmp.add(nums.get(<span class="number">0</span>));</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tmp));</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> num=nums.get(i);</span><br><span class="line">            tmp.add(num);</span><br><span class="line">            nums.remove(i);</span><br><span class="line">            backTrack(nums,tmp);</span><br><span class="line">            nums.add(i,num);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>回溯：使用额外的数组来标记是否使用了某元素</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.8 MB, 在所有 Java 提交中击败了44.06%的用户</p><p>通过测试用例：26 &#x2F; 26</p><p>时间 O(N!)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> []used=<span class="keyword">new</span> <span class="title class_">boolean</span> [nums.length];</span><br><span class="line">        backTrack(nums,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(),used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> [] nums,List&lt;Integer&gt; tmp,<span class="type">boolean</span> []used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size()==nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)<span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            backTrack(nums,tmp,used);</span><br><span class="line">            used[i]=<span class="literal">false</span>;</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全排列&quot; class=&quot;headerlink&quot; title=&quot;46. 全</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 322</title>
    <link href="https://kkkkkong.github.io/posts/40137.html"/>
    <id>https://kkkkkong.github.io/posts/40137.html</id>
    <published>2023-03-01T03:05:28.000Z</published>
    <updated>2023-03-04T14:16:50.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h4><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>暴力解 超时</li><li>加备忘录</li></ol><blockquote><p>执行用时：142 ms, 在所有 Java 提交中击败了5.00%的用户</p><p>内存消耗：43.3 MB, 在所有 Java 提交中击败了5.08%的用户</p><p>通过测试用例：189 &#x2F; 189</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getChange(coins,amount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&lt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(amount))<span class="keyword">return</span> map.get(amount);</span><br><span class="line">        <span class="type">int</span> ans=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:coins)&#123;</span><br><span class="line">            <span class="type">int</span> tmp=getChange(coins,amount-i);</span><br><span class="line">            <span class="keyword">if</span>(tmp==-<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans=Math.min(ans,tmp+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans==Integer.MAX_VALUE?-<span class="number">1</span>:ans;</span><br><span class="line">        map.put(amount,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自底向上，dp数组迭代，来自题解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;322-零钱兑换&quot;&gt;&lt;a href=&quot;#322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;3</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 344</title>
    <link href="https://kkkkkong.github.io/posts/15946.html"/>
    <id>https://kkkkkong.github.io/posts/15946.html</id>
    <published>2023-02-28T07:19:44.000Z</published>
    <updated>2023-02-28T07:28:00.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>双指针，简单题我重拳出击</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：47.8 MB, 在所有 Java 提交中击败了94.56%的用户</p><p>通过测试用例：477 &#x2F; 477</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,n=s.length,right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> tmp=s[left];</span><br><span class="line">            s[left]=s[right];</span><br><span class="line">            s[right]=tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 83</title>
    <link href="https://kkkkkong.github.io/posts/14372.html"/>
    <id>https://kkkkkong.github.io/posts/14372.html</id>
    <published>2023-02-28T07:01:20.000Z</published>
    <updated>2023-02-28T07:04:15.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/list1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>双指针</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.9 MB, 在所有 Java 提交中击败了69.93%的用户</p><p>通过测试用例：166 &#x2F; 166</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode low=head,fast=head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.val==low.val)&#123;</span><br><span class="line">                low.next=fast.next;</span><br><span class="line">                fast=low.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fast=fast.next;</span><br><span class="line">                low=low.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;83-删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#83-删除排序链表中的重复元素&quot; class=&quot;header</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 26</title>
    <link href="https://kkkkkong.github.io/posts/39906.html"/>
    <id>https://kkkkkong.github.io/posts/39906.html</id>
    <published>2023-02-28T06:35:28.000Z</published>
    <updated>2023-02-28T07:04:15.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。</p><p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p><p>不要使用额外的空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>快慢指针</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：43.3 MB, 在所有 Java 提交中击败了29.47%的用户</p><p>通过测试用例：361 &#x2F; 361</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">1</span>,fast=<span class="number">1</span>,n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[low]=nums[i];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;26-删除有序数组中的重复项&quot;&gt;&lt;a href=&quot;#26-删除有序数组中的重复项&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 86</title>
    <link href="https://kkkkkong.github.io/posts/15332.html"/>
    <id>https://kkkkkong.github.io/posts/15332.html</id>
    <published>2023-02-28T03:11:28.000Z</published>
    <updated>2023-02-28T07:04:15.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h4><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kong-PR/Typora-picture@latest/img/partition.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,3,2,5,2], x = 3</span><br><span class="line">输出：[1,2,2,4,3,5]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>注意要断开原指针的链接</li></ol><blockquote><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.1 MB, 在所有 Java 提交中击败了40.53%的用户</p><p>通过测试用例：168 &#x2F; 168</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        ListNode ans=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>),p=ans;</span><br><span class="line">        ListNode tail=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>),p2=tail;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val&lt;x)&#123;</span><br><span class="line">                p.next=head;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p2.next=head;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">            ListNode tmp=head.next;</span><br><span class="line">            head.next=<span class="literal">null</span>;</span><br><span class="line">            head=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=tail.next;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;86-分隔链表&quot;&gt;&lt;a href=&quot;#86-分隔链表&quot; class=&quot;headerlink&quot; title=&quot;86.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 904</title>
    <link href="https://kkkkkong.github.io/posts/64616.html"/>
    <id>https://kkkkkong.github.io/posts/64616.html</id>
    <published>2023-02-28T02:04:57.000Z</published>
    <updated>2023-02-28T07:04:15.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h4><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑动窗口+哈希表</li></ol><blockquote><p>执行用时：42 ms, 在所有 Java 提交中击败了64.08%的用户</p><p>内存消耗：50.6 MB, 在所有 Java 提交中击败了52.45%的用户</p><p>通过测试用例：91 &#x2F; 91</p><p>时间 O(N)</p><p>空间 O(1),最多只用3个空间的map，可以看做是常数空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,n=fruits.length,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            map.put(fruits[right],map.getOrDefault(fruits[right],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">while</span>(map.size()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> value=map.get(fruits[left]);</span><br><span class="line">                <span class="keyword">if</span>(value&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    map.put(fruits[left],value-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;904-水果成篮&quot;&gt;&lt;a href=&quot;#904-水果成篮&quot; class=&quot;headerlink&quot; title=&quot;9</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 395</title>
    <link href="https://kkkkkong.github.io/posts/28303.html"/>
    <id>https://kkkkkong.github.io/posts/28303.html</id>
    <published>2023-02-28T01:34:21.000Z</published>
    <updated>2023-02-28T07:04:15.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h4><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaabb&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>分治：递归返回条件：s.length()&lt;k或找到符合条件的s</li></ol><blockquote><p>执行用时：4 ms, 在所有 Java 提交中击败了60.30%的用户</p><p>内存消耗：41.3 MB, 在所有 Java 提交中击败了34.40%的用户</p><p>通过测试用例：37 &#x2F; 37</p><p>时间 O(N<em>26</em>26)</p><p>空间 O(26*26）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=s.charAt(i);</span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(c)&lt;k)&#123;</span><br><span class="line">                <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(String str:s.split(String.valueOf(c)))&#123;</span><br><span class="line">                    res=Math.max(res,longestSubstring(str,k));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;395-至少有-K-个重复字符的最长子串&quot;&gt;&lt;a href=&quot;#395-至少有-K-个重复字符的最长子串&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 978</title>
    <link href="https://kkkkkong.github.io/posts/51562.html"/>
    <id>https://kkkkkong.github.io/posts/51562.html</id>
    <published>2023-02-27T03:31:23.000Z</published>
    <updated>2023-02-27T03:37:49.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h4><p>给定一个整数数组 <code>arr</code> ，返回 <code>arr</code> 的 <em>最大湍流子数组的<strong>长度</strong></em> 。</p><p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 <strong>湍流子数组</strong> 。</p><p>更正式地来说，当 <code>arr</code> 的子数组 <code>A[i], A[i+1], ..., A[j]</code> 满足仅满足下列条件时，我们称其为<em>湍流子数组</em>：</p><ul><li><p>若 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt;= k &lt; j</span><br></pre></td></tr></table></figure><p> ：</p><ul><li>当 <code>k</code> 为奇数时， <code>A[k] &gt; A[k+1]</code>，且</li><li>当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li></ul></li><li><p>或 </p><p>若 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt;= k &lt; j</span><br></pre></td></tr></table></figure><p> ：</p><ul><li>当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code> ，且</li><li>当 <code>k</code> 为奇数时， <code>A[k] &lt; A[k+1]</code>。</li></ul></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [9,4,2,10,7,8,8,1,9]</span><br><span class="line">输出：5</span><br><span class="line">解释：arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑窗，使用一个boolean类型变量记录情况，</li></ol><p>面向测试用例编程</p><blockquote><p>执行用时：6 ms, 在所有 Java 提交中击败了43.97%的用户</p><p>内存消耗：45.5 MB, 在所有 Java 提交中击败了70.82%的用户</p><p>通过测试用例：91 &#x2F; 91</p><p>时间 O(N)</p><p>空间 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxTurbulenceSize</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,n=arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">boolean</span> judge=arr[<span class="number">0</span>]&gt;arr[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果符合条件</span></span><br><span class="line">            <span class="keyword">if</span>((arr[right]&gt;arr[right+<span class="number">1</span>])==judge&amp;&amp;arr[right]!=arr[right+<span class="number">1</span>])&#123;</span><br><span class="line">                right++;</span><br><span class="line">                judge=!judge;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[right]==arr[right+<span class="number">1</span>])right++;</span><br><span class="line">                left=right;</span><br><span class="line">                <span class="keyword">if</span>(right&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">                    judge=arr[right]&gt;arr[right+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;978-最长湍流子数组&quot;&gt;&lt;a href=&quot;#978-最长湍流子数组&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 567</title>
    <link href="https://kkkkkong.github.io/posts/24299.html"/>
    <id>https://kkkkkong.github.io/posts/24299.html</id>
    <published>2023-02-27T02:32:34.000Z</published>
    <updated>2023-02-27T03:37:49.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h4><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>滑窗：滑窗更新字符出现的次数，两数组相等时为true，但每次判断是否相等需要O(N)，因此使用一个变量来保存二者之间的距离</li></ol><blockquote><p>执行用时：5 ms, 在所有 Java 提交中击败了79.71%的用户</p><p>内存消耗：41.5 MB, 在所有 Java 提交中击败了46.65%的用户</p><p>通过测试用例：108 &#x2F; 108</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组存放字母出现的次数</span></span><br><span class="line">        <span class="type">int</span> []s1Count=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> []s2Count=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 滑窗更新字符出现的次数，两数组相等时为true，但每次判断是否相等需要O(N)，因此使用一个变量来保存二者之间的距离</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,s1Len=s1.length(),s2Len=s2.length();</span><br><span class="line">        <span class="type">int</span> diff=s1Len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1Len;i++)&#123;</span><br><span class="line">            s1Count[s1.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s2Len)&#123;</span><br><span class="line">            <span class="type">char</span> c=s2.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(s2Count[c-<span class="string">&#x27;a&#x27;</span>]&lt;s1Count[c-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                diff--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125;</span><br><span class="line">            s2Count[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;s1Len)&#123;</span><br><span class="line">                <span class="type">char</span> c2=s2.charAt(left);</span><br><span class="line">                <span class="keyword">if</span>(s2Count[c2-<span class="string">&#x27;a&#x27;</span>]&lt;=s1Count[c2-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    diff--;</span><br><span class="line">                &#125;</span><br><span class="line">                s2Count[c2-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;567-字符串的排列&quot;&gt;&lt;a href=&quot;#567-字符串的排列&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习</title>
    <link href="https://kkkkkong.github.io/posts/34491.html"/>
    <id>https://kkkkkong.github.io/posts/34491.html</id>
    <published>2023-02-22T11:31:11.000Z</published>
    <updated>2023-02-27T03:37:49.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ol><li>介绍下 Java 内存区域（运行时数据区）<ol><li>（方法区、堆）线程共享，不安全</li><li>（栈、本地方法区、程序计数器）线程独享，安全</li></ol></li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）<br>1. </li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）<ol><li></li></ol></li></ol><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ol><li>如何判断对象是否死亡（两种方法）。<ol><li>引用计数法<ol><li>给对象中添加一个引用计数器<ol><li>每当有一个地方引用它，计数器加一</li><li>当引用失效时，计数器减一</li><li>任何时候计数器为0都说明对象不可能再被使用了</li></ol></li><li>此方法简单，效率高。但目前主流的虚拟机并没有使用该方法，因为无法解决循环引用问题</li></ol></li><li>可达性分析算法<ol><li>基本思想是通过一些列“GC root” 的对象作为起点，从这些节点向下搜索，节点走过的路径称为引用链，当一个对象到GC root没有任何引用链的时候，则证明该对象是不可用的，需要回收。</li></ol></li></ol></li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。<ol><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ol></li><li>如何判断一个常量是废弃常量<ol><li>没有被任何String对象引用的常量就是废弃常量</li></ol></li><li>如何判断一个类是无用的类<ol><li>三点<ol><li>加载该类的Classloader被回收</li><li>类对应的实例都被回收</li><li>该类对应的java.lang.class对象没有在任何地方被引用，也无法通过反射机制访问该类的方法</li></ol></li></ol></li><li>垃圾收集有哪些算法，各自的特点？<ol><li>标记清除-容易产生碎片</li><li>标记复制-占用空间比较大</li><li>标记整理-</li><li>分代回收- 将java堆中的对象分为新生代、老年代和永久代</li></ol></li><li>HotSpot 为什么要分为新生代和老年代？<ol><li>方便垃圾回收，新生代每次回收都会有大量对象死去，因此选用标记清除算法，每次只需要少量的对象复制空间即可完成回收；而老年代多是存活纪律较高的对象，而且没有额外的空间去怼他进行分配担保，所以选用标记清除或标记整理进行回收</li></ol></li><li>常见的垃圾回收器有哪些？<ol><li>serial收集器</li><li>parNew</li><li>Parallel Scavenge</li><li>Serial Old</li><li>Parallel Old</li><li>CMS<ol><li>以获取最短回收时间为目标的收集器，第一个真正的并发收集器</li></ol></li><li>G1</li><li>ZGC</li></ol></li><li>介绍一下 CMS,G1 收集器。<br>1. </li><li>Minor Gc 和 Full GC 有什么不同呢？<ol><li>Minor GC 回收年轻代</li><li>Full GC： 负责从整个内存区回收</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经典面试题&quot;&gt;&lt;a href=&quot;#经典面试题&quot; class=&quot;headerlink&quot; title=&quot;经典面试题&quot;&gt;&lt;/a&gt;经典面试题&lt;/h2&gt;&lt;h3 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://kkkkkong.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://kkkkkong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 438</title>
    <link href="https://kkkkkong.github.io/posts/51961.html"/>
    <id>https://kkkkkong.github.io/posts/51961.html</id>
    <published>2023-02-21T06:29:10.000Z</published>
    <updated>2023-02-21T06:34:06.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>数组差+滑窗，用两个数组分别表示字符串p中字母出现的次数以及滑窗中字母出现的次数，方便统计，采用变量diff表示两个数组的不同字母数。diff为0时，将left指针加入结果集中</li></ol><blockquote><p>执行用时：8 ms, 在所有 Java 提交中击败了67.39%的用户</p><p>内存消耗：42.7 MB, 在所有 Java 提交中击败了38.45%的用户</p><p>通过测试用例：64 &#x2F; 64</p><p>时间 O(N)</p><p>空间 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []ptmp=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> []stmp=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,n=s.length();</span><br><span class="line">        <span class="type">int</span> plen=p.length();</span><br><span class="line">        <span class="type">int</span> diff=plen;</span><br><span class="line">        List&lt;Integer&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;plen;i++)&#123;</span><br><span class="line">            ptmp[p.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span>&gt;plen)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmp[s.charAt(left)-<span class="string">&#x27;a&#x27;</span>]&lt;=ptmp[s.charAt(left)-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    diff--;</span><br><span class="line">                &#125;</span><br><span class="line">                stmp[s.charAt(left)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmp[s.charAt(right)-<span class="string">&#x27;a&#x27;</span>]&gt;=ptmp[s.charAt(right)-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    diff--;</span><br><span class="line">                &#125;</span><br><span class="line">                stmp[s.charAt(right)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;438-找到字符串中所有字母异位词&quot;&gt;&lt;a href=&quot;#438-找到字符串中所有字母异位词&quot; class=&quot;he</summary>
      
    
    
    
    <category term="leetcode" scheme="https://kkkkkong.github.io/categories/leetcode/"/>
    
    
    <category term="刷题" scheme="https://kkkkkong.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
